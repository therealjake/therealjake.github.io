{"version":3,"file":"static/js/452.9d5f9101.chunk.js","mappings":"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","sources":["../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Materials/materialDefines.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Misc/sceneOptimizer.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Cameras/targetCamera.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Lights/light.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Lights/shadowLight.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Lights/directionalLight.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Lights/hemisphericLight.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Maths/math.size.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Materials/Textures/thinTexture.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Materials/Textures/baseTexture.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Misc/copyTools.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Materials/Textures/texture.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Engines/renderTargetWrapper.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Engines/WebGL/webGLRenderTargetWrapper.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Engines/Extensions/engine.renderTarget.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Engines/Extensions/engine.renderTargetCube.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Materials/effectRenderer.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/postprocess.vertex.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/pass.fragment.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Misc/dumpTools.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Materials/Textures/renderTargetTexture.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/PostProcesses/postProcess.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/kernelBlurVaryingDeclaration.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/packingFunctions.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/kernelBlurFragment.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/kernelBlurFragment2.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/kernelBlur.fragment.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/kernelBlur.vertex.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/PostProcesses/blurPostProcess.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Materials/effectFallbacks.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/bayerDitherFunctions.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapFragmentExtraDeclaration.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapFragment.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/shadowMap.fragment.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/helperFunctions.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/meshVertexDeclaration.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapUboDeclaration.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertex.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobal.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesVertex.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesVertex.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Lights/Shadows/shadowGenerator.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/depth.fragment.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/depth.vertex.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Rendering/depthRenderer.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/minmaxRedux.fragment.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Misc/minMaxReducer.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Misc/depthReducer.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Lights/Shadows/cascadedShadowGenerator.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Lights/Shadows/shadowGeneratorSceneComponent.js","../node_modules/@3d-dice/dice-box/src/components/world/lights.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Meshes/Builders/boxBuilder.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Materials/prePassConfiguration.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Materials/pushMaterial.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Materials/materialFlags.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/decalFragmentDeclaration.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultFragmentDeclaration.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultUboDeclaration.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/oitDeclaration.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/mainUVVaryingDeclaration.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerFragmentDeclaration.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/fresnelFunction.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/reflectionFunction.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingDeclaration.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingFunctions.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentMainFunctions.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentFunctions.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthDeclaration.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragment.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/decalFragment.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/depthPrePass.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragment.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/oitFragment.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/default.fragment.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertexDeclaration.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Materials/materialPluginBase.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Materials/material.detailMapConfiguration.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Materials/standardMaterial.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingCompatibility.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/materials/shadowOnly/shadowOnly.fragment.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/materials/shadowOnly/shadowOnly.vertex.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/materials/shadowOnly/shadowOnlyMaterial.js","../node_modules/@3d-dice/dice-box/src/components/Container.js","../node_modules/@3d-dice/dice-box/node_modules/@babylonjs/materials/custom/customMaterial.js","../node_modules/@3d-dice/dice-box/src/components/ThemeLoader.js","../node_modules/@3d-dice/dice-box/src/components/world.onscreen.js","../node_modules/@3d-dice/dice-box/src/components/world/engine.js","../node_modules/@3d-dice/dice-box/src/components/world/scene.js","../node_modules/@3d-dice/dice-box/src/components/world/camera.js"],"sourcesContent":["/**\n * Manages the defines for the Material\n */\nexport class MaterialDefines {\n    /**\n     * Creates a new instance\n     * @param externalProperties list of external properties to inject into the object\n     */\n    constructor(externalProperties) {\n        /** @internal */\n        this._keys = [];\n        this._isDirty = true;\n        /** @internal */\n        this._areLightsDirty = true;\n        /** @internal */\n        this._areLightsDisposed = false;\n        /** @internal */\n        this._areAttributesDirty = true;\n        /** @internal */\n        this._areTexturesDirty = true;\n        /** @internal */\n        this._areFresnelDirty = true;\n        /** @internal */\n        this._areMiscDirty = true;\n        /** @internal */\n        this._arePrePassDirty = true;\n        /** @internal */\n        this._areImageProcessingDirty = true;\n        /** @internal */\n        this._normals = false;\n        /** @internal */\n        this._uvs = false;\n        /** @internal */\n        this._needNormals = false;\n        /** @internal */\n        this._needUVs = false;\n        this._externalProperties = externalProperties;\n        // Initialize External Properties\n        if (externalProperties) {\n            for (const prop in externalProperties) {\n                if (Object.prototype.hasOwnProperty.call(externalProperties, prop)) {\n                    this._setDefaultValue(prop);\n                }\n            }\n        }\n    }\n    /**\n     * Specifies if the material needs to be re-calculated\n     */\n    get isDirty() {\n        return this._isDirty;\n    }\n    /**\n     * Marks the material to indicate that it has been re-calculated\n     */\n    markAsProcessed() {\n        this._isDirty = false;\n        this._areAttributesDirty = false;\n        this._areTexturesDirty = false;\n        this._areFresnelDirty = false;\n        this._areLightsDirty = false;\n        this._areLightsDisposed = false;\n        this._areMiscDirty = false;\n        this._arePrePassDirty = false;\n        this._areImageProcessingDirty = false;\n    }\n    /**\n     * Marks the material to indicate that it needs to be re-calculated\n     */\n    markAsUnprocessed() {\n        this._isDirty = true;\n    }\n    /**\n     * Marks the material to indicate all of its defines need to be re-calculated\n     */\n    markAllAsDirty() {\n        this._areTexturesDirty = true;\n        this._areAttributesDirty = true;\n        this._areLightsDirty = true;\n        this._areFresnelDirty = true;\n        this._areMiscDirty = true;\n        this._areImageProcessingDirty = true;\n        this._isDirty = true;\n    }\n    /**\n     * Marks the material to indicate that image processing needs to be re-calculated\n     */\n    markAsImageProcessingDirty() {\n        this._areImageProcessingDirty = true;\n        this._isDirty = true;\n    }\n    /**\n     * Marks the material to indicate the lights need to be re-calculated\n     * @param disposed Defines whether the light is dirty due to dispose or not\n     */\n    markAsLightDirty(disposed = false) {\n        this._areLightsDirty = true;\n        this._areLightsDisposed = this._areLightsDisposed || disposed;\n        this._isDirty = true;\n    }\n    /**\n     * Marks the attribute state as changed\n     */\n    markAsAttributesDirty() {\n        this._areAttributesDirty = true;\n        this._isDirty = true;\n    }\n    /**\n     * Marks the texture state as changed\n     */\n    markAsTexturesDirty() {\n        this._areTexturesDirty = true;\n        this._isDirty = true;\n    }\n    /**\n     * Marks the fresnel state as changed\n     */\n    markAsFresnelDirty() {\n        this._areFresnelDirty = true;\n        this._isDirty = true;\n    }\n    /**\n     * Marks the misc state as changed\n     */\n    markAsMiscDirty() {\n        this._areMiscDirty = true;\n        this._isDirty = true;\n    }\n    /**\n     * Marks the prepass state as changed\n     */\n    markAsPrePassDirty() {\n        this._arePrePassDirty = true;\n        this._isDirty = true;\n    }\n    /**\n     * Rebuilds the material defines\n     */\n    rebuild() {\n        this._keys.length = 0;\n        for (const key of Object.keys(this)) {\n            if (key[0] === \"_\") {\n                continue;\n            }\n            this._keys.push(key);\n        }\n        if (this._externalProperties) {\n            for (const name in this._externalProperties) {\n                if (this._keys.indexOf(name) === -1) {\n                    this._keys.push(name);\n                }\n            }\n        }\n    }\n    /**\n     * Specifies if two material defines are equal\n     * @param other - A material define instance to compare to\n     * @returns - Boolean indicating if the material defines are equal (true) or not (false)\n     */\n    isEqual(other) {\n        if (this._keys.length !== other._keys.length) {\n            return false;\n        }\n        for (let index = 0; index < this._keys.length; index++) {\n            const prop = this._keys[index];\n            if (this[prop] !== other[prop]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Clones this instance's defines to another instance\n     * @param other - material defines to clone values to\n     */\n    cloneTo(other) {\n        if (this._keys.length !== other._keys.length) {\n            other._keys = this._keys.slice(0);\n        }\n        for (let index = 0; index < this._keys.length; index++) {\n            const prop = this._keys[index];\n            other[prop] = this[prop];\n        }\n    }\n    /**\n     * Resets the material define values\n     */\n    reset() {\n        this._keys.forEach((prop) => this._setDefaultValue(prop));\n    }\n    _setDefaultValue(prop) {\n        var _a, _b, _c, _d, _e;\n        const type = (_c = (_b = (_a = this._externalProperties) === null || _a === void 0 ? void 0 : _a[prop]) === null || _b === void 0 ? void 0 : _b.type) !== null && _c !== void 0 ? _c : typeof this[prop];\n        const defValue = (_e = (_d = this._externalProperties) === null || _d === void 0 ? void 0 : _d[prop]) === null || _e === void 0 ? void 0 : _e.default;\n        switch (type) {\n            case \"number\":\n                this[prop] = defValue !== null && defValue !== void 0 ? defValue : 0;\n                break;\n            case \"string\":\n                this[prop] = defValue !== null && defValue !== void 0 ? defValue : \"\";\n                break;\n            default:\n                this[prop] = defValue !== null && defValue !== void 0 ? defValue : false;\n                break;\n        }\n    }\n    /**\n     * Converts the material define values to a string\n     * @returns - String of material define information\n     */\n    toString() {\n        let result = \"\";\n        for (let index = 0; index < this._keys.length; index++) {\n            const prop = this._keys[index];\n            const value = this[prop];\n            const type = typeof value;\n            switch (type) {\n                case \"number\":\n                case \"string\":\n                    result += \"#define \" + prop + \" \" + value + \"\\n\";\n                    break;\n                default:\n                    if (value) {\n                        result += \"#define \" + prop + \"\\n\";\n                    }\n                    break;\n            }\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=materialDefines.js.map","import { EngineStore } from \"../Engines/engineStore.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Observable } from \"./observable.js\";\n/**\n * Defines the root class used to create scene optimization to use with SceneOptimizer\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class SceneOptimization {\n    /**\n     * Gets a string describing the action executed by the current optimization\n     * @returns description string\n     */\n    getDescription() {\n        return \"\";\n    }\n    /**\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n     * @param scene defines the current scene where to apply this optimization\n     * @param optimizer defines the current optimizer\n     * @returns true if everything that can be done was applied\n     */\n    apply(scene, optimizer) {\n        return true;\n    }\n    /**\n     * Creates the SceneOptimization object\n     * @param priority defines the priority of this optimization (0 by default which means first in the list)\n     */\n    constructor(\n    /**\n     * Defines the priority of this optimization (0 by default which means first in the list)\n     */\n    priority = 0) {\n        this.priority = priority;\n    }\n}\n/**\n * Defines an optimization used to reduce the size of render target textures\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class TextureOptimization extends SceneOptimization {\n    /**\n     * Gets a string describing the action executed by the current optimization\n     * @returns description string\n     */\n    getDescription() {\n        return \"Reducing render target texture size to \" + this.maximumSize;\n    }\n    /**\n     * Creates the TextureOptimization object\n     * @param priority defines the priority of this optimization (0 by default which means first in the list)\n     * @param maximumSize defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter\n     * @param step defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.\n     */\n    constructor(\n    /**\n     * Defines the priority of this optimization (0 by default which means first in the list)\n     */\n    priority = 0, \n    /**\n     * Defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter\n     */\n    maximumSize = 1024, \n    /**\n     * Defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.\n     */\n    step = 0.5) {\n        super(priority);\n        this.priority = priority;\n        this.maximumSize = maximumSize;\n        this.step = step;\n    }\n    /**\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n     * @param scene defines the current scene where to apply this optimization\n     * @param optimizer defines the current optimizer\n     * @returns true if everything that can be done was applied\n     */\n    apply(scene, optimizer) {\n        let allDone = true;\n        for (let index = 0; index < scene.textures.length; index++) {\n            const texture = scene.textures[index];\n            if (!texture.canRescale || texture.getContext) {\n                continue;\n            }\n            const currentSize = texture.getSize();\n            const maxDimension = Math.max(currentSize.width, currentSize.height);\n            if (maxDimension > this.maximumSize) {\n                texture.scale(this.step);\n                allDone = false;\n            }\n        }\n        return allDone;\n    }\n}\n/**\n * Defines an optimization used to increase or decrease the rendering resolution\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class HardwareScalingOptimization extends SceneOptimization {\n    /**\n     * Gets a string describing the action executed by the current optimization\n     * @returns description string\n     */\n    getDescription() {\n        return \"Setting hardware scaling level to \" + this._currentScale;\n    }\n    /**\n     * Creates the HardwareScalingOptimization object\n     * @param priority defines the priority of this optimization (0 by default which means first in the list)\n     * @param maximumScale defines the maximum scale to use (2 by default)\n     * @param step defines the step to use between two passes (0.5 by default)\n     */\n    constructor(\n    /**\n     * Defines the priority of this optimization (0 by default which means first in the list)\n     */\n    priority = 0, \n    /**\n     * Defines the maximum scale to use (2 by default)\n     */\n    maximumScale = 2, \n    /**\n     * Defines the step to use between two passes (0.5 by default)\n     */\n    step = 0.25) {\n        super(priority);\n        this.priority = priority;\n        this.maximumScale = maximumScale;\n        this.step = step;\n        this._currentScale = -1;\n        this._directionOffset = 1;\n    }\n    /**\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n     * @param scene defines the current scene where to apply this optimization\n     * @param optimizer defines the current optimizer\n     * @returns true if everything that can be done was applied\n     */\n    apply(scene, optimizer) {\n        if (this._currentScale === -1) {\n            this._currentScale = scene.getEngine().getHardwareScalingLevel();\n            if (this._currentScale > this.maximumScale) {\n                this._directionOffset = -1;\n            }\n        }\n        this._currentScale += this._directionOffset * this.step;\n        scene.getEngine().setHardwareScalingLevel(this._currentScale);\n        return this._directionOffset === 1 ? this._currentScale >= this.maximumScale : this._currentScale <= this.maximumScale;\n    }\n}\n/**\n * Defines an optimization used to remove shadows\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class ShadowsOptimization extends SceneOptimization {\n    /**\n     * Gets a string describing the action executed by the current optimization\n     * @returns description string\n     */\n    getDescription() {\n        return \"Turning shadows on/off\";\n    }\n    /**\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n     * @param scene defines the current scene where to apply this optimization\n     * @param optimizer defines the current optimizer\n     * @returns true if everything that can be done was applied\n     */\n    apply(scene, optimizer) {\n        scene.shadowsEnabled = optimizer.isInImprovementMode;\n        return true;\n    }\n}\n/**\n * Defines an optimization used to turn post-processes off\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class PostProcessesOptimization extends SceneOptimization {\n    /**\n     * Gets a string describing the action executed by the current optimization\n     * @returns description string\n     */\n    getDescription() {\n        return \"Turning post-processes on/off\";\n    }\n    /**\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n     * @param scene defines the current scene where to apply this optimization\n     * @param optimizer defines the current optimizer\n     * @returns true if everything that can be done was applied\n     */\n    apply(scene, optimizer) {\n        scene.postProcessesEnabled = optimizer.isInImprovementMode;\n        return true;\n    }\n}\n/**\n * Defines an optimization used to turn lens flares off\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class LensFlaresOptimization extends SceneOptimization {\n    /**\n     * Gets a string describing the action executed by the current optimization\n     * @returns description string\n     */\n    getDescription() {\n        return \"Turning lens flares on/off\";\n    }\n    /**\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n     * @param scene defines the current scene where to apply this optimization\n     * @param optimizer defines the current optimizer\n     * @returns true if everything that can be done was applied\n     */\n    apply(scene, optimizer) {\n        scene.lensFlaresEnabled = optimizer.isInImprovementMode;\n        return true;\n    }\n}\n/**\n * Defines an optimization based on user defined callback.\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class CustomOptimization extends SceneOptimization {\n    /**\n     * Gets a string describing the action executed by the current optimization\n     * @returns description string\n     */\n    getDescription() {\n        if (this.onGetDescription) {\n            return this.onGetDescription();\n        }\n        return \"Running user defined callback\";\n    }\n    /**\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n     * @param scene defines the current scene where to apply this optimization\n     * @param optimizer defines the current optimizer\n     * @returns true if everything that can be done was applied\n     */\n    apply(scene, optimizer) {\n        if (this.onApply) {\n            return this.onApply(scene, optimizer);\n        }\n        return true;\n    }\n}\n/**\n * Defines an optimization used to turn particles off\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class ParticlesOptimization extends SceneOptimization {\n    /**\n     * Gets a string describing the action executed by the current optimization\n     * @returns description string\n     */\n    getDescription() {\n        return \"Turning particles on/off\";\n    }\n    /**\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n     * @param scene defines the current scene where to apply this optimization\n     * @param optimizer defines the current optimizer\n     * @returns true if everything that can be done was applied\n     */\n    apply(scene, optimizer) {\n        scene.particlesEnabled = optimizer.isInImprovementMode;\n        return true;\n    }\n}\n/**\n * Defines an optimization used to turn render targets off\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class RenderTargetsOptimization extends SceneOptimization {\n    /**\n     * Gets a string describing the action executed by the current optimization\n     * @returns description string\n     */\n    getDescription() {\n        return \"Turning render targets off\";\n    }\n    /**\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n     * @param scene defines the current scene where to apply this optimization\n     * @param optimizer defines the current optimizer\n     * @returns true if everything that can be done was applied\n     */\n    apply(scene, optimizer) {\n        scene.renderTargetsEnabled = optimizer.isInImprovementMode;\n        return true;\n    }\n}\n/**\n * Defines an optimization used to merge meshes with compatible materials\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class MergeMeshesOptimization extends SceneOptimization {\n    constructor() {\n        super(...arguments);\n        this._canBeMerged = (abstractMesh) => {\n            if (!(abstractMesh instanceof Mesh)) {\n                return false;\n            }\n            const mesh = abstractMesh;\n            if (mesh.isDisposed()) {\n                return false;\n            }\n            if (!mesh.isVisible || !mesh.isEnabled()) {\n                return false;\n            }\n            if (mesh.instances.length > 0) {\n                return false;\n            }\n            if (mesh.skeleton || mesh.hasLODLevels) {\n                return false;\n            }\n            if (mesh.getTotalVertices() === 0) {\n                return false;\n            }\n            return true;\n        };\n    }\n    /**\n     * Gets or sets a boolean which defines if optimization octree has to be updated\n     */\n    static get UpdateSelectionTree() {\n        return MergeMeshesOptimization._UpdateSelectionTree;\n    }\n    /**\n     * Gets or sets a boolean which defines if optimization octree has to be updated\n     */\n    static set UpdateSelectionTree(value) {\n        MergeMeshesOptimization._UpdateSelectionTree = value;\n    }\n    /**\n     * Gets a string describing the action executed by the current optimization\n     * @returns description string\n     */\n    getDescription() {\n        return \"Merging similar meshes together\";\n    }\n    /**\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n     * @param scene defines the current scene where to apply this optimization\n     * @param optimizer defines the current optimizer\n     * @param updateSelectionTree defines that the selection octree has to be updated (false by default)\n     * @returns true if everything that can be done was applied\n     */\n    apply(scene, optimizer, updateSelectionTree) {\n        const globalPool = scene.meshes.slice(0);\n        let globalLength = globalPool.length;\n        for (let index = 0; index < globalLength; index++) {\n            const currentPool = new Array();\n            const current = globalPool[index];\n            // Checks\n            if (!this._canBeMerged(current)) {\n                continue;\n            }\n            currentPool.push(current);\n            // Find compatible meshes\n            for (let subIndex = index + 1; subIndex < globalLength; subIndex++) {\n                const otherMesh = globalPool[subIndex];\n                if (!this._canBeMerged(otherMesh)) {\n                    continue;\n                }\n                if (otherMesh.material !== current.material) {\n                    continue;\n                }\n                if (otherMesh.checkCollisions !== current.checkCollisions) {\n                    continue;\n                }\n                currentPool.push(otherMesh);\n                globalLength--;\n                globalPool.splice(subIndex, 1);\n                subIndex--;\n            }\n            if (currentPool.length < 2) {\n                continue;\n            }\n            // Merge meshes\n            Mesh.MergeMeshes(currentPool, undefined, true);\n        }\n        // Call the octree system optimization if it is defined.\n        const sceneAsAny = scene;\n        if (sceneAsAny.createOrUpdateSelectionOctree) {\n            if (updateSelectionTree != undefined) {\n                if (updateSelectionTree) {\n                    sceneAsAny.createOrUpdateSelectionOctree();\n                }\n            }\n            else if (MergeMeshesOptimization.UpdateSelectionTree) {\n                sceneAsAny.createOrUpdateSelectionOctree();\n            }\n        }\n        return true;\n    }\n}\nMergeMeshesOptimization._UpdateSelectionTree = false;\n/**\n * Defines a list of options used by SceneOptimizer\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class SceneOptimizerOptions {\n    /**\n     * Creates a new list of options used by SceneOptimizer\n     * @param targetFrameRate defines the target frame rate to reach (60 by default)\n     * @param trackerDuration defines the interval between two checks (2000ms by default)\n     */\n    constructor(\n    /**\n     * Defines the target frame rate to reach (60 by default)\n     */\n    targetFrameRate = 60, \n    /**\n     * Defines the interval between two checks (2000ms by default)\n     */\n    trackerDuration = 2000) {\n        this.targetFrameRate = targetFrameRate;\n        this.trackerDuration = trackerDuration;\n        /**\n         * Gets the list of optimizations to apply\n         */\n        this.optimizations = new Array();\n    }\n    /**\n     * Add a new optimization\n     * @param optimization defines the SceneOptimization to add to the list of active optimizations\n     * @returns the current SceneOptimizerOptions\n     */\n    addOptimization(optimization) {\n        this.optimizations.push(optimization);\n        return this;\n    }\n    /**\n     * Add a new custom optimization\n     * @param onApply defines the callback called to apply the custom optimization (true if everything that can be done was applied)\n     * @param onGetDescription defines the callback called to get the description attached with the optimization.\n     * @param priority defines the priority of this optimization (0 by default which means first in the list)\n     * @returns the current SceneOptimizerOptions\n     */\n    addCustomOptimization(onApply, onGetDescription, priority = 0) {\n        const optimization = new CustomOptimization(priority);\n        optimization.onApply = onApply;\n        optimization.onGetDescription = onGetDescription;\n        this.optimizations.push(optimization);\n        return this;\n    }\n    /**\n     * Creates a list of pre-defined optimizations aimed to reduce the visual impact on the scene\n     * @param targetFrameRate defines the target frame rate (60 by default)\n     * @returns a SceneOptimizerOptions object\n     */\n    static LowDegradationAllowed(targetFrameRate) {\n        const result = new SceneOptimizerOptions(targetFrameRate);\n        let priority = 0;\n        result.addOptimization(new MergeMeshesOptimization(priority));\n        result.addOptimization(new ShadowsOptimization(priority));\n        result.addOptimization(new LensFlaresOptimization(priority));\n        // Next priority\n        priority++;\n        result.addOptimization(new PostProcessesOptimization(priority));\n        result.addOptimization(new ParticlesOptimization(priority));\n        // Next priority\n        priority++;\n        result.addOptimization(new TextureOptimization(priority, 1024));\n        return result;\n    }\n    /**\n     * Creates a list of pre-defined optimizations aimed to have a moderate impact on the scene visual\n     * @param targetFrameRate defines the target frame rate (60 by default)\n     * @returns a SceneOptimizerOptions object\n     */\n    static ModerateDegradationAllowed(targetFrameRate) {\n        const result = new SceneOptimizerOptions(targetFrameRate);\n        let priority = 0;\n        result.addOptimization(new MergeMeshesOptimization(priority));\n        result.addOptimization(new ShadowsOptimization(priority));\n        result.addOptimization(new LensFlaresOptimization(priority));\n        // Next priority\n        priority++;\n        result.addOptimization(new PostProcessesOptimization(priority));\n        result.addOptimization(new ParticlesOptimization(priority));\n        // Next priority\n        priority++;\n        result.addOptimization(new TextureOptimization(priority, 512));\n        // Next priority\n        priority++;\n        result.addOptimization(new RenderTargetsOptimization(priority));\n        // Next priority\n        priority++;\n        result.addOptimization(new HardwareScalingOptimization(priority, 2));\n        return result;\n    }\n    /**\n     * Creates a list of pre-defined optimizations aimed to have a big impact on the scene visual\n     * @param targetFrameRate defines the target frame rate (60 by default)\n     * @returns a SceneOptimizerOptions object\n     */\n    static HighDegradationAllowed(targetFrameRate) {\n        const result = new SceneOptimizerOptions(targetFrameRate);\n        let priority = 0;\n        result.addOptimization(new MergeMeshesOptimization(priority));\n        result.addOptimization(new ShadowsOptimization(priority));\n        result.addOptimization(new LensFlaresOptimization(priority));\n        // Next priority\n        priority++;\n        result.addOptimization(new PostProcessesOptimization(priority));\n        result.addOptimization(new ParticlesOptimization(priority));\n        // Next priority\n        priority++;\n        result.addOptimization(new TextureOptimization(priority, 256));\n        // Next priority\n        priority++;\n        result.addOptimization(new RenderTargetsOptimization(priority));\n        // Next priority\n        priority++;\n        result.addOptimization(new HardwareScalingOptimization(priority, 4));\n        return result;\n    }\n}\n/**\n * Class used to run optimizations in order to reach a target frame rate\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class SceneOptimizer {\n    /**\n     * Gets or sets a boolean indicating if the optimizer is in improvement mode\n     */\n    get isInImprovementMode() {\n        return this._improvementMode;\n    }\n    set isInImprovementMode(value) {\n        this._improvementMode = value;\n    }\n    /**\n     * Gets the current priority level (0 at start)\n     */\n    get currentPriorityLevel() {\n        return this._currentPriorityLevel;\n    }\n    /**\n     * Gets the current frame rate checked by the SceneOptimizer\n     */\n    get currentFrameRate() {\n        return this._currentFrameRate;\n    }\n    /**\n     * Gets or sets the current target frame rate (60 by default)\n     */\n    get targetFrameRate() {\n        return this._targetFrameRate;\n    }\n    /**\n     * Gets or sets the current target frame rate (60 by default)\n     */\n    set targetFrameRate(value) {\n        this._targetFrameRate = value;\n    }\n    /**\n     * Gets or sets the current interval between two checks (every 2000ms by default)\n     */\n    get trackerDuration() {\n        return this._trackerDuration;\n    }\n    /**\n     * Gets or sets the current interval between two checks (every 2000ms by default)\n     */\n    set trackerDuration(value) {\n        this._trackerDuration = value;\n    }\n    /**\n     * Gets the list of active optimizations\n     */\n    get optimizations() {\n        return this._options.optimizations;\n    }\n    /**\n     * Creates a new SceneOptimizer\n     * @param scene defines the scene to work on\n     * @param options defines the options to use with the SceneOptimizer\n     * @param autoGeneratePriorities defines if priorities must be generated and not read from SceneOptimization property (true by default)\n     * @param improvementMode defines if the scene optimizer must run the maximum optimization while staying over a target frame instead of trying to reach the target framerate (false by default)\n     */\n    constructor(scene, options, autoGeneratePriorities = true, improvementMode = false) {\n        this._isRunning = false;\n        this._currentPriorityLevel = 0;\n        this._targetFrameRate = 60;\n        this._trackerDuration = 2000;\n        this._currentFrameRate = 0;\n        this._improvementMode = false;\n        /**\n         * Defines an observable called when the optimizer reaches the target frame rate\n         */\n        this.onSuccessObservable = new Observable();\n        /**\n         * Defines an observable called when the optimizer enables an optimization\n         */\n        this.onNewOptimizationAppliedObservable = new Observable();\n        /**\n         * Defines an observable called when the optimizer is not able to reach the target frame rate\n         */\n        this.onFailureObservable = new Observable();\n        if (!options) {\n            this._options = new SceneOptimizerOptions();\n        }\n        else {\n            this._options = options;\n        }\n        if (this._options.targetFrameRate) {\n            this._targetFrameRate = this._options.targetFrameRate;\n        }\n        if (this._options.trackerDuration) {\n            this._trackerDuration = this._options.trackerDuration;\n        }\n        if (autoGeneratePriorities) {\n            let priority = 0;\n            for (const optim of this._options.optimizations) {\n                optim.priority = priority++;\n            }\n        }\n        this._improvementMode = improvementMode;\n        this._scene = scene || EngineStore.LastCreatedScene;\n        this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => {\n            this._sceneDisposeObserver = null;\n            this.dispose();\n        });\n    }\n    /**\n     * Stops the current optimizer\n     */\n    stop() {\n        this._isRunning = false;\n    }\n    /**\n     * Reset the optimizer to initial step (current priority level = 0)\n     */\n    reset() {\n        this._currentPriorityLevel = 0;\n    }\n    /**\n     * Start the optimizer. By default it will try to reach a specific framerate\n     * but if the optimizer is set with improvementMode === true then it will run all optimization while frame rate is above the target frame rate\n     */\n    start() {\n        if (this._isRunning) {\n            return;\n        }\n        this._isRunning = true;\n        // Let's wait for the scene to be ready before running our check\n        this._scene.executeWhenReady(() => {\n            setTimeout(() => {\n                this._checkCurrentState();\n            }, this._trackerDuration);\n        });\n    }\n    _checkCurrentState() {\n        if (!this._isRunning) {\n            return;\n        }\n        const scene = this._scene;\n        const options = this._options;\n        this._currentFrameRate = Math.round(scene.getEngine().getFps());\n        if ((this._improvementMode && this._currentFrameRate <= this._targetFrameRate) || (!this._improvementMode && this._currentFrameRate >= this._targetFrameRate)) {\n            this._isRunning = false;\n            this.onSuccessObservable.notifyObservers(this);\n            return;\n        }\n        // Apply current level of optimizations\n        let allDone = true;\n        let noOptimizationApplied = true;\n        for (let index = 0; index < options.optimizations.length; index++) {\n            const optimization = options.optimizations[index];\n            if (optimization.priority === this._currentPriorityLevel) {\n                noOptimizationApplied = false;\n                allDone = allDone && optimization.apply(scene, this);\n                this.onNewOptimizationAppliedObservable.notifyObservers(optimization);\n            }\n        }\n        // If no optimization was applied, this is a failure :(\n        if (noOptimizationApplied) {\n            this._isRunning = false;\n            this.onFailureObservable.notifyObservers(this);\n            return;\n        }\n        // If all optimizations were done, move to next level\n        if (allDone) {\n            this._currentPriorityLevel++;\n        }\n        // Let's the system running for a specific amount of time before checking FPS\n        scene.executeWhenReady(() => {\n            setTimeout(() => {\n                this._checkCurrentState();\n            }, this._trackerDuration);\n        });\n    }\n    /**\n     * Release all resources\n     */\n    dispose() {\n        this.stop();\n        this.onSuccessObservable.clear();\n        this.onFailureObservable.clear();\n        this.onNewOptimizationAppliedObservable.clear();\n        if (this._sceneDisposeObserver) {\n            this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);\n        }\n    }\n    /**\n     * Helper function to create a SceneOptimizer with one single line of code\n     * @param scene defines the scene to work on\n     * @param options defines the options to use with the SceneOptimizer\n     * @param onSuccess defines a callback to call on success\n     * @param onFailure defines a callback to call on failure\n     * @returns the new SceneOptimizer object\n     */\n    static OptimizeAsync(scene, options, onSuccess, onFailure) {\n        const optimizer = new SceneOptimizer(scene, options || SceneOptimizerOptions.ModerateDegradationAllowed(), false);\n        if (onSuccess) {\n            optimizer.onSuccessObservable.add(() => {\n                onSuccess();\n            });\n        }\n        if (onFailure) {\n            optimizer.onFailureObservable.add(() => {\n                onFailure();\n            });\n        }\n        optimizer.start();\n        return optimizer;\n    }\n}\n//# sourceMappingURL=sceneOptimizer.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { serialize, serializeAsVector3, serializeAsMeshReference } from \"../Misc/decorators.js\";\nimport { Camera } from \"./camera.js\";\nimport { Quaternion, Matrix, Vector3, Vector2, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\nimport { Axis } from \"../Maths/math.axis.js\";\n/**\n * A target camera takes a mesh or position as a target and continues to look at it while it moves.\n * This is the base of the follow, arc rotate cameras and Free camera\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\n */\nexport class TargetCamera extends Camera {\n    /**\n     * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.\n     * This is the base of the follow, arc rotate cameras and Free camera\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\n     * @param name Defines the name of the camera in the scene\n     * @param position Defines the start position of the camera in the scene\n     * @param scene Defines the scene the camera belongs to\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\n     */\n    constructor(name, position, scene, setActiveOnSceneIfNoneActive = true) {\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\n        this._tmpUpVector = Vector3.Zero();\n        this._tmpTargetVector = Vector3.Zero();\n        /**\n         * Define the current direction the camera is moving to\n         */\n        this.cameraDirection = new Vector3(0, 0, 0);\n        /**\n         * Define the current rotation the camera is rotating to\n         */\n        this.cameraRotation = new Vector2(0, 0);\n        /** Gets or sets a boolean indicating that the scaling of the parent hierarchy will not be taken in account by the camera */\n        this.ignoreParentScaling = false;\n        /**\n         * When set, the up vector of the camera will be updated by the rotation of the camera\n         */\n        this.updateUpVectorFromRotation = false;\n        this._tmpQuaternion = new Quaternion();\n        /**\n         * Define the current rotation of the camera\n         */\n        this.rotation = new Vector3(0, 0, 0);\n        /**\n         * Define the current speed of the camera\n         */\n        this.speed = 2.0;\n        /**\n         * Add constraint to the camera to prevent it to move freely in all directions and\n         * around all axis.\n         */\n        this.noRotationConstraint = false;\n        /**\n         * Reverses mouselook direction to 'natural' panning as opposed to traditional direct\n         * panning\n         */\n        this.invertRotation = false;\n        /**\n         * Speed multiplier for inverse camera panning\n         */\n        this.inverseRotationSpeed = 0.2;\n        /**\n         * Define the current target of the camera as an object or a position.\n         * Please note that locking a target will disable panning.\n         */\n        this.lockedTarget = null;\n        /** @internal */\n        this._currentTarget = Vector3.Zero();\n        /** @internal */\n        this._initialFocalDistance = 1;\n        /** @internal */\n        this._viewMatrix = Matrix.Zero();\n        /** @internal */\n        this._camMatrix = Matrix.Zero();\n        /** @internal */\n        this._cameraTransformMatrix = Matrix.Zero();\n        /** @internal */\n        this._cameraRotationMatrix = Matrix.Zero();\n        /** @internal */\n        this._referencePoint = new Vector3(0, 0, 1);\n        /** @internal */\n        this._transformedReferencePoint = Vector3.Zero();\n        this._defaultUp = Vector3.Up();\n        this._cachedRotationZ = 0;\n        this._cachedQuaternionRotationZ = 0;\n    }\n    /**\n     * Gets the position in front of the camera at a given distance.\n     * @param distance The distance from the camera we want the position to be\n     * @returns the position\n     */\n    getFrontPosition(distance) {\n        this.getWorldMatrix();\n        const direction = this.getTarget().subtract(this.position);\n        direction.normalize();\n        direction.scaleInPlace(distance);\n        return this.globalPosition.add(direction);\n    }\n    /** @internal */\n    _getLockedTargetPosition() {\n        if (!this.lockedTarget) {\n            return null;\n        }\n        if (this.lockedTarget.absolutePosition) {\n            const lockedTarget = this.lockedTarget;\n            const m = lockedTarget.computeWorldMatrix();\n            // in some cases the absolute position resets externally, but doesn't update since the matrix is cached.\n            m.getTranslationToRef(lockedTarget.absolutePosition);\n        }\n        return this.lockedTarget.absolutePosition || this.lockedTarget;\n    }\n    /**\n     * Store current camera state of the camera (fov, position, rotation, etc..)\n     * @returns the camera\n     */\n    storeState() {\n        this._storedPosition = this.position.clone();\n        this._storedRotation = this.rotation.clone();\n        if (this.rotationQuaternion) {\n            this._storedRotationQuaternion = this.rotationQuaternion.clone();\n        }\n        return super.storeState();\n    }\n    /**\n     * Restored camera state. You must call storeState() first\n     * @returns whether it was successful or not\n     * @internal\n     */\n    _restoreStateValues() {\n        if (!super._restoreStateValues()) {\n            return false;\n        }\n        this.position = this._storedPosition.clone();\n        this.rotation = this._storedRotation.clone();\n        if (this.rotationQuaternion) {\n            this.rotationQuaternion = this._storedRotationQuaternion.clone();\n        }\n        this.cameraDirection.copyFromFloats(0, 0, 0);\n        this.cameraRotation.copyFromFloats(0, 0);\n        return true;\n    }\n    /** @internal */\n    _initCache() {\n        super._initCache();\n        this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    }\n    /**\n     * @internal\n     */\n    _updateCache(ignoreParentClass) {\n        if (!ignoreParentClass) {\n            super._updateCache();\n        }\n        const lockedTargetPosition = this._getLockedTargetPosition();\n        if (!lockedTargetPosition) {\n            this._cache.lockedTarget = null;\n        }\n        else {\n            if (!this._cache.lockedTarget) {\n                this._cache.lockedTarget = lockedTargetPosition.clone();\n            }\n            else {\n                this._cache.lockedTarget.copyFrom(lockedTargetPosition);\n            }\n        }\n        this._cache.rotation.copyFrom(this.rotation);\n        if (this.rotationQuaternion) {\n            this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\n        }\n    }\n    // Synchronized\n    /** @internal */\n    _isSynchronizedViewMatrix() {\n        if (!super._isSynchronizedViewMatrix()) {\n            return false;\n        }\n        const lockedTargetPosition = this._getLockedTargetPosition();\n        return ((this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) &&\n            (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation)));\n    }\n    // Methods\n    /** @internal */\n    _computeLocalCameraSpeed() {\n        const engine = this.getEngine();\n        return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100.0));\n    }\n    // Target\n    /**\n     * Defines the target the camera should look at.\n     * @param target Defines the new target as a Vector\n     */\n    setTarget(target) {\n        this.upVector.normalize();\n        this._initialFocalDistance = target.subtract(this.position).length();\n        if (this.position.z === target.z) {\n            this.position.z += Epsilon;\n        }\n        this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);\n        Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);\n        this._camMatrix.invert();\n        this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);\n        const vDir = target.subtract(this.position);\n        if (vDir.x >= 0.0) {\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2.0;\n        }\n        else {\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2.0;\n        }\n        this.rotation.z = 0;\n        if (isNaN(this.rotation.x)) {\n            this.rotation.x = 0;\n        }\n        if (isNaN(this.rotation.y)) {\n            this.rotation.y = 0;\n        }\n        if (isNaN(this.rotation.z)) {\n            this.rotation.z = 0;\n        }\n        if (this.rotationQuaternion) {\n            Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\n        }\n    }\n    /**\n     * Defines the target point of the camera.\n     * The camera looks towards it form the radius distance.\n     */\n    get target() {\n        return this.getTarget();\n    }\n    set target(value) {\n        this.setTarget(value);\n    }\n    /**\n     * Return the current target position of the camera. This value is expressed in local space.\n     * @returns the target position\n     */\n    getTarget() {\n        return this._currentTarget;\n    }\n    /** @internal */\n    _decideIfNeedsToMove() {\n        return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\n    }\n    /** @internal */\n    _updatePosition() {\n        if (this.parent) {\n            this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\n            Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\n            this.position.addInPlace(TmpVectors.Vector3[0]);\n            return;\n        }\n        this.position.addInPlace(this.cameraDirection);\n    }\n    /** @internal */\n    _checkInputs() {\n        const directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1.0;\n        const needToMove = this._decideIfNeedsToMove();\n        const needToRotate = Math.abs(this.cameraRotation.x) > 0 || Math.abs(this.cameraRotation.y) > 0;\n        // Move\n        if (needToMove) {\n            this._updatePosition();\n        }\n        // Rotate\n        if (needToRotate) {\n            //rotate, if quaternion is set and rotation was used\n            if (this.rotationQuaternion) {\n                this.rotationQuaternion.toEulerAnglesToRef(this.rotation);\n            }\n            this.rotation.x += this.cameraRotation.x * directionMultiplier;\n            this.rotation.y += this.cameraRotation.y * directionMultiplier;\n            // Apply constraints\n            if (!this.noRotationConstraint) {\n                const limit = 1.570796;\n                if (this.rotation.x > limit) {\n                    this.rotation.x = limit;\n                }\n                if (this.rotation.x < -limit) {\n                    this.rotation.x = -limit;\n                }\n            }\n            //rotate, if quaternion is set and rotation was used\n            if (this.rotationQuaternion) {\n                const len = this.rotation.lengthSquared();\n                if (len) {\n                    Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\n                }\n            }\n        }\n        // Inertia\n        if (needToMove) {\n            if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {\n                this.cameraDirection.x = 0;\n            }\n            if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {\n                this.cameraDirection.y = 0;\n            }\n            if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {\n                this.cameraDirection.z = 0;\n            }\n            this.cameraDirection.scaleInPlace(this.inertia);\n        }\n        if (needToRotate) {\n            if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {\n                this.cameraRotation.x = 0;\n            }\n            if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {\n                this.cameraRotation.y = 0;\n            }\n            this.cameraRotation.scaleInPlace(this.inertia);\n        }\n        super._checkInputs();\n    }\n    _updateCameraRotationMatrix() {\n        if (this.rotationQuaternion) {\n            this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\n        }\n        else {\n            Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\n        }\n    }\n    /**\n     * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)\n     * @returns the current camera\n     */\n    _rotateUpVectorWithCameraRotationMatrix() {\n        Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);\n        return this;\n    }\n    /** @internal */\n    _getViewMatrix() {\n        if (this.lockedTarget) {\n            this.setTarget(this._getLockedTargetPosition());\n        }\n        // Compute\n        this._updateCameraRotationMatrix();\n        // Apply the changed rotation to the upVector\n        if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {\n            this._rotateUpVectorWithCameraRotationMatrix();\n            this._cachedQuaternionRotationZ = this.rotationQuaternion.z;\n        }\n        else if (this._cachedRotationZ !== this.rotation.z) {\n            this._rotateUpVectorWithCameraRotationMatrix();\n            this._cachedRotationZ = this.rotation.z;\n        }\n        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\n        // Computing target and final matrix\n        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\n        if (this.updateUpVectorFromRotation) {\n            if (this.rotationQuaternion) {\n                Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);\n            }\n            else {\n                Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);\n                Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);\n            }\n        }\n        this._computeViewMatrix(this.position, this._currentTarget, this.upVector);\n        return this._viewMatrix;\n    }\n    _computeViewMatrix(position, target, up) {\n        if (this.ignoreParentScaling) {\n            if (this.parent) {\n                const parentWorldMatrix = this.parent.getWorldMatrix();\n                Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);\n                Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);\n                Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);\n                this._markSyncedWithParent();\n            }\n            else {\n                this._globalPosition.copyFrom(position);\n                this._tmpTargetVector.copyFrom(target);\n                this._tmpUpVector.copyFrom(up);\n            }\n            if (this.getScene().useRightHandedSystem) {\n                Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\n            }\n            else {\n                Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\n            }\n            return;\n        }\n        if (this.getScene().useRightHandedSystem) {\n            Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);\n        }\n        else {\n            Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);\n        }\n        if (this.parent) {\n            const parentWorldMatrix = this.parent.getWorldMatrix();\n            this._viewMatrix.invert();\n            this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);\n            this._viewMatrix.getTranslationToRef(this._globalPosition);\n            this._viewMatrix.invert();\n            this._markSyncedWithParent();\n        }\n        else {\n            this._globalPosition.copyFrom(position);\n        }\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    createRigCamera(name, cameraIndex) {\n        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\n            const rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\n            rigCamera.isRigCamera = true;\n            rigCamera.rigParent = this;\n            if (this.cameraRigMode === Camera.RIG_MODE_VR || this.cameraRigMode === Camera.RIG_MODE_WEBVR) {\n                if (!this.rotationQuaternion) {\n                    this.rotationQuaternion = new Quaternion();\n                }\n                rigCamera._cameraRigParams = {};\n                rigCamera.rotationQuaternion = new Quaternion();\n            }\n            rigCamera.mode = this.mode;\n            rigCamera.orthoLeft = this.orthoLeft;\n            rigCamera.orthoRight = this.orthoRight;\n            rigCamera.orthoTop = this.orthoTop;\n            rigCamera.orthoBottom = this.orthoBottom;\n            return rigCamera;\n        }\n        return null;\n    }\n    /**\n     * @internal\n     */\n    _updateRigCameras() {\n        const camLeft = this._rigCameras[0];\n        const camRight = this._rigCameras[1];\n        this.computeWorldMatrix();\n        switch (this.cameraRigMode) {\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED: {\n                //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\n                const leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;\n                const rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);\n                break;\n            }\n            case Camera.RIG_MODE_VR:\n                if (camLeft.rotationQuaternion) {\n                    camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\n                    camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\n                }\n                else {\n                    camLeft.rotation.copyFrom(this.rotation);\n                    camRight.rotation.copyFrom(this.rotation);\n                }\n                camLeft.position.copyFrom(this.position);\n                camRight.position.copyFrom(this.position);\n                break;\n        }\n        super._updateRigCameras();\n    }\n    _getRigCamPositionAndTarget(halfSpace, rigCamera) {\n        const target = this.getTarget();\n        target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);\n        TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);\n        const newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);\n        Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);\n        TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);\n        Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);\n        TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);\n        Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);\n        rigCamera.setTarget(newFocalTarget);\n    }\n    /**\n     * Gets the current object class name.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"TargetCamera\";\n    }\n}\nTargetCamera._RigCamTransformMatrix = new Matrix();\nTargetCamera._TargetTransformMatrix = new Matrix();\nTargetCamera._TargetFocalPoint = new Vector3();\n__decorate([\n    serializeAsVector3()\n], TargetCamera.prototype, \"rotation\", void 0);\n__decorate([\n    serialize()\n], TargetCamera.prototype, \"speed\", void 0);\n__decorate([\n    serializeAsMeshReference(\"lockedTargetId\")\n], TargetCamera.prototype, \"lockedTarget\", void 0);\n//# sourceMappingURL=targetCamera.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { serialize, SerializationHelper, serializeAsColor3, expandToProperty } from \"../Misc/decorators.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3, TmpColors } from \"../Maths/math.color.js\";\nimport { Node } from \"../node.js\";\nimport { UniformBuffer } from \"../Materials/uniformBuffer.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\nimport { LightConstants } from \"./lightConstants.js\";\n/**\n * Base class of all the lights in Babylon. It groups all the generic information about lights.\n * Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.\n * All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.\n */\nexport class Light extends Node {\n    /**\n     * Defines how far from the source the light is impacting in scene units.\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\n     */\n    get range() {\n        return this._range;\n    }\n    /**\n     * Defines how far from the source the light is impacting in scene units.\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\n     */\n    set range(value) {\n        this._range = value;\n        this._inverseSquaredRange = 1.0 / (this.range * this.range);\n    }\n    /**\n     * Gets the photometric scale used to interpret the intensity.\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\n     */\n    get intensityMode() {\n        return this._intensityMode;\n    }\n    /**\n     * Sets the photometric scale used to interpret the intensity.\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\n     */\n    set intensityMode(value) {\n        this._intensityMode = value;\n        this._computePhotometricScale();\n    }\n    /**\n     * Gets the light radius used by PBR Materials to simulate soft area lights.\n     */\n    get radius() {\n        return this._radius;\n    }\n    /**\n     * sets the light radius used by PBR Materials to simulate soft area lights.\n     */\n    set radius(value) {\n        this._radius = value;\n        this._computePhotometricScale();\n    }\n    /**\n     * Gets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\n     * the current shadow generator.\n     */\n    get shadowEnabled() {\n        return this._shadowEnabled;\n    }\n    /**\n     * Sets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\n     * the current shadow generator.\n     */\n    set shadowEnabled(value) {\n        if (this._shadowEnabled === value) {\n            return;\n        }\n        this._shadowEnabled = value;\n        this._markMeshesAsLightDirty();\n    }\n    /**\n     * Gets the only meshes impacted by this light.\n     */\n    get includedOnlyMeshes() {\n        return this._includedOnlyMeshes;\n    }\n    /**\n     * Sets the only meshes impacted by this light.\n     */\n    set includedOnlyMeshes(value) {\n        this._includedOnlyMeshes = value;\n        this._hookArrayForIncludedOnly(value);\n    }\n    /**\n     * Gets the meshes not impacted by this light.\n     */\n    get excludedMeshes() {\n        return this._excludedMeshes;\n    }\n    /**\n     * Sets the meshes not impacted by this light.\n     */\n    set excludedMeshes(value) {\n        this._excludedMeshes = value;\n        this._hookArrayForExcluded(value);\n    }\n    /**\n     * Gets the layer id use to find what meshes are not impacted by the light.\n     * Inactive if 0\n     */\n    get excludeWithLayerMask() {\n        return this._excludeWithLayerMask;\n    }\n    /**\n     * Sets the layer id use to find what meshes are not impacted by the light.\n     * Inactive if 0\n     */\n    set excludeWithLayerMask(value) {\n        this._excludeWithLayerMask = value;\n        this._resyncMeshes();\n    }\n    /**\n     * Gets the layer id use to find what meshes are impacted by the light.\n     * Inactive if 0\n     */\n    get includeOnlyWithLayerMask() {\n        return this._includeOnlyWithLayerMask;\n    }\n    /**\n     * Sets the layer id use to find what meshes are impacted by the light.\n     * Inactive if 0\n     */\n    set includeOnlyWithLayerMask(value) {\n        this._includeOnlyWithLayerMask = value;\n        this._resyncMeshes();\n    }\n    /**\n     * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\n     */\n    get lightmapMode() {\n        return this._lightmapMode;\n    }\n    /**\n     * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\n     */\n    set lightmapMode(value) {\n        if (this._lightmapMode === value) {\n            return;\n        }\n        this._lightmapMode = value;\n        this._markMeshesAsLightDirty();\n    }\n    /**\n     * Creates a Light object in the scene.\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n     * @param name The friendly name of the light\n     * @param scene The scene the light belongs too\n     */\n    constructor(name, scene) {\n        super(name, scene);\n        /**\n         * Diffuse gives the basic color to an object.\n         */\n        this.diffuse = new Color3(1.0, 1.0, 1.0);\n        /**\n         * Specular produces a highlight color on an object.\n         * Note: This is not affecting PBR materials.\n         */\n        this.specular = new Color3(1.0, 1.0, 1.0);\n        /**\n         * Defines the falloff type for this light. This lets overriding how punctual light are\n         * falling off base on range or angle.\n         * This can be set to any values in Light.FALLOFF_x.\n         *\n         * Note: This is only useful for PBR Materials at the moment. This could be extended if required to\n         * other types of materials.\n         */\n        this.falloffType = Light.FALLOFF_DEFAULT;\n        /**\n         * Strength of the light.\n         * Note: By default it is define in the framework own unit.\n         * Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.\n         */\n        this.intensity = 1.0;\n        this._range = Number.MAX_VALUE;\n        this._inverseSquaredRange = 0;\n        /**\n         * Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type\n         * of light.\n         */\n        this._photometricScale = 1.0;\n        this._intensityMode = Light.INTENSITYMODE_AUTOMATIC;\n        this._radius = 0.00001;\n        /**\n         * Defines the rendering priority of the lights. It can help in case of fallback or number of lights\n         * exceeding the number allowed of the materials.\n         */\n        this.renderPriority = 0;\n        this._shadowEnabled = true;\n        this._excludeWithLayerMask = 0;\n        this._includeOnlyWithLayerMask = 0;\n        this._lightmapMode = 0;\n        /**\n         * Shadow generators associated to the light.\n         * @internal Internal use only.\n         */\n        this._shadowGenerators = null;\n        /**\n         * @internal Internal use only.\n         */\n        this._excludedMeshesIds = new Array();\n        /**\n         * @internal Internal use only.\n         */\n        this._includedOnlyMeshesIds = new Array();\n        /** @internal */\n        this._isLight = true;\n        this.getScene().addLight(this);\n        this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), undefined, undefined, name);\n        this._buildUniformLayout();\n        this.includedOnlyMeshes = new Array();\n        this.excludedMeshes = new Array();\n        this._resyncMeshes();\n    }\n    /**\n     * Sets the passed Effect \"effect\" with the Light textures.\n     * @param effect The effect to update\n     * @param lightIndex The index of the light in the effect to update\n     * @returns The light\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    transferTexturesToEffect(effect, lightIndex) {\n        // Do nothing by default.\n        return this;\n    }\n    /**\n     * Binds the lights information from the scene to the effect for the given mesh.\n     * @param lightIndex Light index\n     * @param scene The scene where the light belongs to\n     * @param effect The effect we are binding the data to\n     * @param useSpecular Defines if specular is supported\n     * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\n     */\n    _bindLight(lightIndex, scene, effect, useSpecular, receiveShadows = true) {\n        var _a;\n        const iAsString = lightIndex.toString();\n        let needUpdate = false;\n        this._uniformBuffer.bindToEffect(effect, \"Light\" + iAsString);\n        if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {\n            this._renderId = scene.getRenderId();\n            this._lastUseSpecular = useSpecular;\n            const scaledIntensity = this.getScaledIntensity();\n            this.transferToEffect(effect, iAsString);\n            this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);\n            this._uniformBuffer.updateColor4(\"vLightDiffuse\", TmpColors.Color3[0], this.range, iAsString);\n            if (useSpecular) {\n                this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);\n                this._uniformBuffer.updateColor4(\"vLightSpecular\", TmpColors.Color3[1], this.radius, iAsString);\n            }\n            needUpdate = true;\n        }\n        // Textures might still need to be rebound.\n        this.transferTexturesToEffect(effect, iAsString);\n        // Shadows\n        if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {\n            const shadowGenerator = (_a = this.getShadowGenerator(scene.activeCamera)) !== null && _a !== void 0 ? _a : this.getShadowGenerator();\n            if (shadowGenerator) {\n                shadowGenerator.bindShadowLight(iAsString, effect);\n                needUpdate = true;\n            }\n        }\n        if (needUpdate) {\n            this._uniformBuffer.update();\n        }\n        else {\n            this._uniformBuffer.bindUniformBuffer();\n        }\n    }\n    /**\n     * Returns the string \"Light\".\n     * @returns the class name\n     */\n    getClassName() {\n        return \"Light\";\n    }\n    /**\n     * Converts the light information to a readable string for debug purpose.\n     * @param fullDetails Supports for multiple levels of logging within scene loading\n     * @returns the human readable light info\n     */\n    toString(fullDetails) {\n        let ret = \"Name: \" + this.name;\n        ret += \", type: \" + [\"Point\", \"Directional\", \"Spot\", \"Hemispheric\"][this.getTypeID()];\n        if (this.animations) {\n            for (let i = 0; i < this.animations.length; i++) {\n                ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\n            }\n        }\n        return ret;\n    }\n    /** @internal */\n    _syncParentEnabledState() {\n        super._syncParentEnabledState();\n        if (!this.isDisposed()) {\n            this._resyncMeshes();\n        }\n    }\n    /**\n     * Set the enabled state of this node.\n     * @param value - the new enabled state\n     */\n    setEnabled(value) {\n        super.setEnabled(value);\n        this._resyncMeshes();\n    }\n    /**\n     * Returns the Light associated shadow generator if any.\n     * @param camera Camera for which the shadow generator should be retrieved (default: null). If null, retrieves the default shadow generator\n     * @returns the associated shadow generator.\n     */\n    getShadowGenerator(camera = null) {\n        var _a;\n        if (this._shadowGenerators === null) {\n            return null;\n        }\n        return (_a = this._shadowGenerators.get(camera)) !== null && _a !== void 0 ? _a : null;\n    }\n    /**\n     * Returns all the shadow generators associated to this light\n     * @returns\n     */\n    getShadowGenerators() {\n        return this._shadowGenerators;\n    }\n    /**\n     * Returns a Vector3, the absolute light position in the World.\n     * @returns the world space position of the light\n     */\n    getAbsolutePosition() {\n        return Vector3.Zero();\n    }\n    /**\n     * Specifies if the light will affect the passed mesh.\n     * @param mesh The mesh to test against the light\n     * @returns true the mesh is affected otherwise, false.\n     */\n    canAffectMesh(mesh) {\n        if (!mesh) {\n            return true;\n        }\n        if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {\n            return false;\n        }\n        if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\n            return false;\n        }\n        if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {\n            return false;\n        }\n        if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Releases resources associated with this node.\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n     */\n    dispose(doNotRecurse, disposeMaterialAndTextures = false) {\n        if (this._shadowGenerators) {\n            const iterator = this._shadowGenerators.values();\n            for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n                const shadowGenerator = key.value;\n                shadowGenerator.dispose();\n            }\n            this._shadowGenerators = null;\n        }\n        // Animations\n        this.getScene().stopAnimation(this);\n        if (this._parentContainer) {\n            const index = this._parentContainer.lights.indexOf(this);\n            if (index > -1) {\n                this._parentContainer.lights.splice(index, 1);\n            }\n            this._parentContainer = null;\n        }\n        // Remove from meshes\n        for (const mesh of this.getScene().meshes) {\n            mesh._removeLightSource(this, true);\n        }\n        this._uniformBuffer.dispose();\n        // Remove from scene\n        this.getScene().removeLight(this);\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\n    }\n    /**\n     * Returns the light type ID (integer).\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n     */\n    getTypeID() {\n        return 0;\n    }\n    /**\n     * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.\n     * @returns the scaled intensity in intensity mode unit\n     */\n    getScaledIntensity() {\n        return this._photometricScale * this.intensity;\n    }\n    /**\n     * Returns a new Light object, named \"name\", from the current one.\n     * @param name The name of the cloned light\n     * @param newParent The parent of this light, if it has one\n     * @returns the new created light\n     */\n    clone(name, newParent = null) {\n        const constructor = Light.GetConstructorFromName(this.getTypeID(), name, this.getScene());\n        if (!constructor) {\n            return null;\n        }\n        const clonedLight = SerializationHelper.Clone(constructor, this);\n        if (name) {\n            clonedLight.name = name;\n        }\n        if (newParent) {\n            clonedLight.parent = newParent;\n        }\n        clonedLight.setEnabled(this.isEnabled());\n        this.onClonedObservable.notifyObservers(clonedLight);\n        return clonedLight;\n    }\n    /**\n     * Serializes the current light into a Serialization object.\n     * @returns the serialized object.\n     */\n    serialize() {\n        const serializationObject = SerializationHelper.Serialize(this);\n        serializationObject.uniqueId = this.uniqueId;\n        // Type\n        serializationObject.type = this.getTypeID();\n        // Parent\n        if (this.parent) {\n            this.parent._serializeAsParent(serializationObject);\n        }\n        // Inclusion / exclusions\n        if (this.excludedMeshes.length > 0) {\n            serializationObject.excludedMeshesIds = [];\n            this.excludedMeshes.forEach((mesh) => {\n                serializationObject.excludedMeshesIds.push(mesh.id);\n            });\n        }\n        if (this.includedOnlyMeshes.length > 0) {\n            serializationObject.includedOnlyMeshesIds = [];\n            this.includedOnlyMeshes.forEach((mesh) => {\n                serializationObject.includedOnlyMeshesIds.push(mesh.id);\n            });\n        }\n        // Animations\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n        serializationObject.ranges = this.serializeAnimationRanges();\n        serializationObject.isEnabled = this.isEnabled();\n        return serializationObject;\n    }\n    /**\n     * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.\n     * This new light is named \"name\" and added to the passed scene.\n     * @param type Type according to the types available in Light.LIGHTTYPEID_x\n     * @param name The friendly name of the light\n     * @param scene The scene the new light will belong to\n     * @returns the constructor function\n     */\n    static GetConstructorFromName(type, name, scene) {\n        const constructorFunc = Node.Construct(\"Light_Type_\" + type, name, scene);\n        if (constructorFunc) {\n            return constructorFunc;\n        }\n        // Default to no light for none present once.\n        return null;\n    }\n    /**\n     * Parses the passed \"parsedLight\" and returns a new instanced Light from this parsing.\n     * @param parsedLight The JSON representation of the light\n     * @param scene The scene to create the parsed light in\n     * @returns the created light after parsing\n     */\n    static Parse(parsedLight, scene) {\n        const constructor = Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);\n        if (!constructor) {\n            return null;\n        }\n        const light = SerializationHelper.Parse(constructor, parsedLight, scene);\n        // Inclusion / exclusions\n        if (parsedLight.excludedMeshesIds) {\n            light._excludedMeshesIds = parsedLight.excludedMeshesIds;\n        }\n        if (parsedLight.includedOnlyMeshesIds) {\n            light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;\n        }\n        // Parent\n        if (parsedLight.parentId !== undefined) {\n            light._waitingParentId = parsedLight.parentId;\n        }\n        if (parsedLight.parentInstanceIndex !== undefined) {\n            light._waitingParentInstanceIndex = parsedLight.parentInstanceIndex;\n        }\n        // Falloff\n        if (parsedLight.falloffType !== undefined) {\n            light.falloffType = parsedLight.falloffType;\n        }\n        // Lightmaps\n        if (parsedLight.lightmapMode !== undefined) {\n            light.lightmapMode = parsedLight.lightmapMode;\n        }\n        // Animations\n        if (parsedLight.animations) {\n            for (let animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {\n                const parsedAnimation = parsedLight.animations[animationIndex];\n                const internalClass = GetClass(\"BABYLON.Animation\");\n                if (internalClass) {\n                    light.animations.push(internalClass.Parse(parsedAnimation));\n                }\n            }\n            Node.ParseAnimationRanges(light, parsedLight, scene);\n        }\n        if (parsedLight.autoAnimate) {\n            scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1.0);\n        }\n        // Check if isEnabled is defined to be back compatible with prior serialized versions.\n        if (parsedLight.isEnabled !== undefined) {\n            light.setEnabled(parsedLight.isEnabled);\n        }\n        return light;\n    }\n    _hookArrayForExcluded(array) {\n        const oldPush = array.push;\n        array.push = (...items) => {\n            const result = oldPush.apply(array, items);\n            for (const item of items) {\n                item._resyncLightSource(this);\n            }\n            return result;\n        };\n        const oldSplice = array.splice;\n        array.splice = (index, deleteCount) => {\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\n            for (const item of deleted) {\n                item._resyncLightSource(this);\n            }\n            return deleted;\n        };\n        for (const item of array) {\n            item._resyncLightSource(this);\n        }\n    }\n    _hookArrayForIncludedOnly(array) {\n        const oldPush = array.push;\n        array.push = (...items) => {\n            const result = oldPush.apply(array, items);\n            this._resyncMeshes();\n            return result;\n        };\n        const oldSplice = array.splice;\n        array.splice = (index, deleteCount) => {\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\n            this._resyncMeshes();\n            return deleted;\n        };\n        this._resyncMeshes();\n    }\n    _resyncMeshes() {\n        for (const mesh of this.getScene().meshes) {\n            mesh._resyncLightSource(this);\n        }\n    }\n    /**\n     * Forces the meshes to update their light related information in their rendering used effects\n     * @internal Internal Use Only\n     */\n    _markMeshesAsLightDirty() {\n        for (const mesh of this.getScene().meshes) {\n            if (mesh.lightSources.indexOf(this) !== -1) {\n                mesh._markSubMeshesAsLightDirty();\n            }\n        }\n    }\n    /**\n     * Recomputes the cached photometric scale if needed.\n     */\n    _computePhotometricScale() {\n        this._photometricScale = this._getPhotometricScale();\n        this.getScene().resetCachedMaterial();\n    }\n    /**\n     * Returns the Photometric Scale according to the light type and intensity mode.\n     */\n    _getPhotometricScale() {\n        let photometricScale = 0.0;\n        const lightTypeID = this.getTypeID();\n        //get photometric mode\n        let photometricMode = this.intensityMode;\n        if (photometricMode === Light.INTENSITYMODE_AUTOMATIC) {\n            if (lightTypeID === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {\n                photometricMode = Light.INTENSITYMODE_ILLUMINANCE;\n            }\n            else {\n                photometricMode = Light.INTENSITYMODE_LUMINOUSINTENSITY;\n            }\n        }\n        //compute photometric scale\n        switch (lightTypeID) {\n            case Light.LIGHTTYPEID_POINTLIGHT:\n            case Light.LIGHTTYPEID_SPOTLIGHT:\n                switch (photometricMode) {\n                    case Light.INTENSITYMODE_LUMINOUSPOWER:\n                        photometricScale = 1.0 / (4.0 * Math.PI);\n                        break;\n                    case Light.INTENSITYMODE_LUMINOUSINTENSITY:\n                        photometricScale = 1.0;\n                        break;\n                    case Light.INTENSITYMODE_LUMINANCE:\n                        photometricScale = this.radius * this.radius;\n                        break;\n                }\n                break;\n            case Light.LIGHTTYPEID_DIRECTIONALLIGHT:\n                switch (photometricMode) {\n                    case Light.INTENSITYMODE_ILLUMINANCE:\n                        photometricScale = 1.0;\n                        break;\n                    case Light.INTENSITYMODE_LUMINANCE: {\n                        // When radius (and therefore solid angle) is non-zero a directional lights brightness can be specified via central (peak) luminance.\n                        // For a directional light the 'radius' defines the angular radius (in radians) rather than world-space radius (e.g. in metres).\n                        let apexAngleRadians = this.radius;\n                        // Impose a minimum light angular size to avoid the light becoming an infinitely small angular light source (i.e. a dirac delta function).\n                        apexAngleRadians = Math.max(apexAngleRadians, 0.001);\n                        const solidAngle = 2.0 * Math.PI * (1.0 - Math.cos(apexAngleRadians));\n                        photometricScale = solidAngle;\n                        break;\n                    }\n                }\n                break;\n            case Light.LIGHTTYPEID_HEMISPHERICLIGHT:\n                // No fall off in hemispheric light.\n                photometricScale = 1.0;\n                break;\n        }\n        return photometricScale;\n    }\n    /**\n     * Reorder the light in the scene according to their defined priority.\n     * @internal Internal Use Only\n     */\n    _reorderLightsInScene() {\n        const scene = this.getScene();\n        if (this._renderPriority != 0) {\n            scene.requireLightSorting = true;\n        }\n        this.getScene().sortLightsByPriority();\n    }\n}\n/**\n * Falloff Default: light is falling off following the material specification:\n * standard material is using standard falloff whereas pbr material can request special falloff per materials.\n */\nLight.FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;\n/**\n * Falloff Physical: light is falling off following the inverse squared distance law.\n */\nLight.FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;\n/**\n * Falloff gltf: light is falling off as described in the gltf moving to PBR document\n * to enhance interoperability with other engines.\n */\nLight.FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;\n/**\n * Falloff Standard: light is falling off like in the standard material\n * to enhance interoperability with other materials.\n */\nLight.FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;\n//lightmapMode Consts\n/**\n * If every light affecting the material is in this lightmapMode,\n * material.lightmapTexture adds or multiplies\n * (depends on material.useLightmapAsShadowmap)\n * after every other light calculations.\n */\nLight.LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;\n/**\n * material.lightmapTexture as only diffuse lighting from this light\n * adds only specular lighting from this light\n * adds dynamic shadows\n */\nLight.LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;\n/**\n * material.lightmapTexture as only lighting\n * no light calculation from this light\n * only adds dynamic shadows from this light\n */\nLight.LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;\n// Intensity Mode Consts\n/**\n * Each light type uses the default quantity according to its type:\n *      point/spot lights use luminous intensity\n *      directional lights use illuminance\n */\nLight.INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;\n/**\n * lumen (lm)\n */\nLight.INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;\n/**\n * candela (lm/sr)\n */\nLight.INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;\n/**\n * lux (lm/m^2)\n */\nLight.INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;\n/**\n * nit (cd/m^2)\n */\nLight.INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;\n// Light types ids const.\n/**\n * Light type const id of the point light.\n */\nLight.LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;\n/**\n * Light type const id of the directional light.\n */\nLight.LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;\n/**\n * Light type const id of the spot light.\n */\nLight.LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;\n/**\n * Light type const id of the hemispheric light.\n */\nLight.LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;\n__decorate([\n    serializeAsColor3()\n], Light.prototype, \"diffuse\", void 0);\n__decorate([\n    serializeAsColor3()\n], Light.prototype, \"specular\", void 0);\n__decorate([\n    serialize()\n], Light.prototype, \"falloffType\", void 0);\n__decorate([\n    serialize()\n], Light.prototype, \"intensity\", void 0);\n__decorate([\n    serialize()\n], Light.prototype, \"range\", null);\n__decorate([\n    serialize()\n], Light.prototype, \"intensityMode\", null);\n__decorate([\n    serialize()\n], Light.prototype, \"radius\", null);\n__decorate([\n    serialize()\n], Light.prototype, \"_renderPriority\", void 0);\n__decorate([\n    expandToProperty(\"_reorderLightsInScene\")\n], Light.prototype, \"renderPriority\", void 0);\n__decorate([\n    serialize(\"shadowEnabled\")\n], Light.prototype, \"_shadowEnabled\", void 0);\n__decorate([\n    serialize(\"excludeWithLayerMask\")\n], Light.prototype, \"_excludeWithLayerMask\", void 0);\n__decorate([\n    serialize(\"includeOnlyWithLayerMask\")\n], Light.prototype, \"_includeOnlyWithLayerMask\", void 0);\n__decorate([\n    serialize(\"lightmapMode\")\n], Light.prototype, \"_lightmapMode\", void 0);\n//# sourceMappingURL=light.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { serialize, serializeAsVector3 } from \"../Misc/decorators.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Light } from \"./light.js\";\nimport { Axis } from \"../Maths/math.axis.js\";\n/**\n * Base implementation IShadowLight\n * It groups all the common behaviour in order to reduce duplication and better follow the DRY pattern.\n */\nexport class ShadowLight extends Light {\n    constructor() {\n        super(...arguments);\n        this._needProjectionMatrixCompute = true;\n    }\n    _setPosition(value) {\n        this._position = value;\n    }\n    /**\n     * Sets the position the shadow will be casted from. Also use as the light position for both\n     * point and spot lights.\n     */\n    get position() {\n        return this._position;\n    }\n    /**\n     * Sets the position the shadow will be casted from. Also use as the light position for both\n     * point and spot lights.\n     */\n    set position(value) {\n        this._setPosition(value);\n    }\n    _setDirection(value) {\n        this._direction = value;\n    }\n    /**\n     * In 2d mode (needCube being false), gets the direction used to cast the shadow.\n     * Also use as the light direction on spot and directional lights.\n     */\n    get direction() {\n        return this._direction;\n    }\n    /**\n     * In 2d mode (needCube being false), sets the direction used to cast the shadow.\n     * Also use as the light direction on spot and directional lights.\n     */\n    set direction(value) {\n        this._setDirection(value);\n    }\n    /**\n     * Gets the shadow projection clipping minimum z value.\n     */\n    get shadowMinZ() {\n        return this._shadowMinZ;\n    }\n    /**\n     * Sets the shadow projection clipping minimum z value.\n     */\n    set shadowMinZ(value) {\n        this._shadowMinZ = value;\n        this.forceProjectionMatrixCompute();\n    }\n    /**\n     * Sets the shadow projection clipping maximum z value.\n     */\n    get shadowMaxZ() {\n        return this._shadowMaxZ;\n    }\n    /**\n     * Gets the shadow projection clipping maximum z value.\n     */\n    set shadowMaxZ(value) {\n        this._shadowMaxZ = value;\n        this.forceProjectionMatrixCompute();\n    }\n    /**\n     * Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light\n     * @returns true if the information has been computed, false if it does not need to (no parenting)\n     */\n    computeTransformedInformation() {\n        if (this.parent && this.parent.getWorldMatrix) {\n            if (!this.transformedPosition) {\n                this.transformedPosition = Vector3.Zero();\n            }\n            Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition);\n            // In case the direction is present.\n            if (this.direction) {\n                if (!this.transformedDirection) {\n                    this.transformedDirection = Vector3.Zero();\n                }\n                Vector3.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection);\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Return the depth scale used for the shadow map.\n     * @returns the depth scale.\n     */\n    getDepthScale() {\n        return 50.0;\n    }\n    /**\n     * Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.\n     * @param faceIndex The index of the face we are computed the direction to generate shadow\n     * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getShadowDirection(faceIndex) {\n        return this.transformedDirection ? this.transformedDirection : this.direction;\n    }\n    /**\n     * Returns the ShadowLight absolute position in the World.\n     * @returns the position vector in world space\n     */\n    getAbsolutePosition() {\n        return this.transformedPosition ? this.transformedPosition : this.position;\n    }\n    /**\n     * Sets the ShadowLight direction toward the passed target.\n     * @param target The point to target in local space\n     * @returns the updated ShadowLight direction\n     */\n    setDirectionToTarget(target) {\n        this.direction = Vector3.Normalize(target.subtract(this.position));\n        return this.direction;\n    }\n    /**\n     * Returns the light rotation in euler definition.\n     * @returns the x y z rotation in local space.\n     */\n    getRotation() {\n        this.direction.normalize();\n        const xaxis = Vector3.Cross(this.direction, Axis.Y);\n        const yaxis = Vector3.Cross(xaxis, this.direction);\n        return Vector3.RotationFromAxis(xaxis, yaxis, this.direction);\n    }\n    /**\n     * Returns whether or not the shadow generation require a cube texture or a 2d texture.\n     * @returns true if a cube texture needs to be use\n     */\n    needCube() {\n        return false;\n    }\n    /**\n     * Detects if the projection matrix requires to be recomputed this frame.\n     * @returns true if it requires to be recomputed otherwise, false.\n     */\n    needProjectionMatrixCompute() {\n        return this._needProjectionMatrixCompute;\n    }\n    /**\n     * Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.\n     */\n    forceProjectionMatrixCompute() {\n        this._needProjectionMatrixCompute = true;\n    }\n    /** @internal */\n    _initCache() {\n        super._initCache();\n        this._cache.position = Vector3.Zero();\n    }\n    /** @internal */\n    _isSynchronized() {\n        if (!this._cache.position.equals(this.position)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Computes the world matrix of the node\n     * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch\n     * @returns the world matrix\n     */\n    computeWorldMatrix(force) {\n        if (!force && this.isSynchronized()) {\n            this._currentRenderId = this.getScene().getRenderId();\n            return this._worldMatrix;\n        }\n        this._updateCache();\n        this._cache.position.copyFrom(this.position);\n        if (!this._worldMatrix) {\n            this._worldMatrix = Matrix.Identity();\n        }\n        Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix);\n        if (this.parent && this.parent.getWorldMatrix) {\n            this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix);\n            this._markSyncedWithParent();\n        }\n        // Cache the determinant\n        this._worldMatrixDeterminantIsDirty = true;\n        return this._worldMatrix;\n    }\n    /**\n     * Gets the minZ used for shadow according to both the scene and the light.\n     * @param activeCamera The camera we are returning the min for\n     * @returns the depth min z\n     */\n    getDepthMinZ(activeCamera) {\n        return this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\n    }\n    /**\n     * Gets the maxZ used for shadow according to both the scene and the light.\n     * @param activeCamera The camera we are returning the max for\n     * @returns the depth max z\n     */\n    getDepthMaxZ(activeCamera) {\n        return this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\n    }\n    /**\n     * Sets the shadow projection matrix in parameter to the generated projection matrix.\n     * @param matrix The matrix to updated with the projection information\n     * @param viewMatrix The transform matrix of the light\n     * @param renderList The list of mesh to render in the map\n     * @returns The current light\n     */\n    setShadowProjectionMatrix(matrix, viewMatrix, renderList) {\n        if (this.customProjectionMatrixBuilder) {\n            this.customProjectionMatrixBuilder(viewMatrix, renderList, matrix);\n        }\n        else {\n            this._setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList);\n        }\n        return this;\n    }\n    /** @internal */\n    _syncParentEnabledState() {\n        super._syncParentEnabledState();\n        if (!this.parent || !this.parent.getWorldMatrix) {\n            this.transformedPosition = null;\n            this.transformedDirection = null;\n        }\n    }\n}\n__decorate([\n    serializeAsVector3()\n], ShadowLight.prototype, \"position\", null);\n__decorate([\n    serializeAsVector3()\n], ShadowLight.prototype, \"direction\", null);\n__decorate([\n    serialize()\n], ShadowLight.prototype, \"shadowMinZ\", null);\n__decorate([\n    serialize()\n], ShadowLight.prototype, \"shadowMaxZ\", null);\n//# sourceMappingURL=shadowLight.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { serialize } from \"../Misc/decorators.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Node } from \"../node.js\";\nimport { Light } from \"./light.js\";\nimport { ShadowLight } from \"./shadowLight.js\";\nNode.AddNodeConstructor(\"Light_Type_1\", (name, scene) => {\n    return () => new DirectionalLight(name, Vector3.Zero(), scene);\n});\n/**\n * A directional light is defined by a direction (what a surprise!).\n * The light is emitted from everywhere in the specified direction, and has an infinite range.\n * An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n */\nexport class DirectionalLight extends ShadowLight {\n    /**\n     * Fix frustum size for the shadow generation. This is disabled if the value is 0.\n     */\n    get shadowFrustumSize() {\n        return this._shadowFrustumSize;\n    }\n    /**\n     * Specifies a fix frustum size for the shadow generation.\n     */\n    set shadowFrustumSize(value) {\n        this._shadowFrustumSize = value;\n        this.forceProjectionMatrixCompute();\n    }\n    /**\n     * Gets the shadow projection scale against the optimal computed one.\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\n     */\n    get shadowOrthoScale() {\n        return this._shadowOrthoScale;\n    }\n    /**\n     * Sets the shadow projection scale against the optimal computed one.\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\n     */\n    set shadowOrthoScale(value) {\n        this._shadowOrthoScale = value;\n        this.forceProjectionMatrixCompute();\n    }\n    /**\n     * Gets or sets the orthoLeft property used to build the light frustum\n     */\n    get orthoLeft() {\n        return this._orthoLeft;\n    }\n    set orthoLeft(left) {\n        this._orthoLeft = left;\n    }\n    /**\n     * Gets or sets the orthoRight property used to build the light frustum\n     */\n    get orthoRight() {\n        return this._orthoRight;\n    }\n    set orthoRight(right) {\n        this._orthoRight = right;\n    }\n    /**\n     * Gets or sets the orthoTop property used to build the light frustum\n     */\n    get orthoTop() {\n        return this._orthoTop;\n    }\n    set orthoTop(top) {\n        this._orthoTop = top;\n    }\n    /**\n     * Gets or sets the orthoBottom property used to build the light frustum\n     */\n    get orthoBottom() {\n        return this._orthoBottom;\n    }\n    set orthoBottom(bottom) {\n        this._orthoBottom = bottom;\n    }\n    /**\n     * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).\n     * The directional light is emitted from everywhere in the given direction.\n     * It can cast shadows.\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n     * @param name The friendly name of the light\n     * @param direction The direction of the light\n     * @param scene The scene the light belongs to\n     */\n    constructor(name, direction, scene) {\n        super(name, scene);\n        this._shadowFrustumSize = 0;\n        this._shadowOrthoScale = 0.1;\n        /**\n         * Automatically compute the projection matrix to best fit (including all the casters)\n         * on each frame.\n         */\n        this.autoUpdateExtends = true;\n        /**\n         * Automatically compute the shadowMinZ and shadowMaxZ for the projection matrix to best fit (including all the casters)\n         * on each frame. autoUpdateExtends must be set to true for this to work\n         */\n        this.autoCalcShadowZBounds = false;\n        // Cache\n        this._orthoLeft = Number.MAX_VALUE;\n        this._orthoRight = Number.MIN_VALUE;\n        this._orthoTop = Number.MIN_VALUE;\n        this._orthoBottom = Number.MAX_VALUE;\n        this.position = direction.scale(-1.0);\n        this.direction = direction;\n    }\n    /**\n     * Returns the string \"DirectionalLight\".\n     * @returns The class name\n     */\n    getClassName() {\n        return \"DirectionalLight\";\n    }\n    /**\n     * Returns the integer 1.\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n     */\n    getTypeID() {\n        return Light.LIGHTTYPEID_DIRECTIONALLIGHT;\n    }\n    /**\n     * Sets the passed matrix \"matrix\" as projection matrix for the shadows cast by the light according to the passed view matrix.\n     * Returns the DirectionalLight Shadow projection matrix.\n     * @param matrix\n     * @param viewMatrix\n     * @param renderList\n     */\n    _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {\n        if (this.shadowFrustumSize > 0) {\n            this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);\n        }\n        else {\n            this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);\n        }\n    }\n    /**\n     * Sets the passed matrix \"matrix\" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.\n     * Returns the DirectionalLight Shadow projection matrix.\n     * @param matrix\n     */\n    _setDefaultFixedFrustumShadowProjectionMatrix(matrix) {\n        const activeCamera = this.getScene().activeCamera;\n        if (!activeCamera) {\n            return;\n        }\n        Matrix.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);\n    }\n    /**\n     * Sets the passed matrix \"matrix\" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.\n     * Returns the DirectionalLight Shadow projection matrix.\n     * @param matrix\n     * @param viewMatrix\n     * @param renderList\n     */\n    _setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList) {\n        const activeCamera = this.getScene().activeCamera;\n        if (!activeCamera) {\n            return;\n        }\n        // Check extends\n        if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {\n            const tempVector3 = Vector3.Zero();\n            this._orthoLeft = Number.MAX_VALUE;\n            this._orthoRight = Number.MIN_VALUE;\n            this._orthoTop = Number.MIN_VALUE;\n            this._orthoBottom = Number.MAX_VALUE;\n            let shadowMinZ = Number.MAX_VALUE;\n            let shadowMaxZ = Number.MIN_VALUE;\n            for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {\n                const mesh = renderList[meshIndex];\n                if (!mesh) {\n                    continue;\n                }\n                const boundingInfo = mesh.getBoundingInfo();\n                const boundingBox = boundingInfo.boundingBox;\n                for (let index = 0; index < boundingBox.vectorsWorld.length; index++) {\n                    Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);\n                    if (tempVector3.x < this._orthoLeft) {\n                        this._orthoLeft = tempVector3.x;\n                    }\n                    if (tempVector3.y < this._orthoBottom) {\n                        this._orthoBottom = tempVector3.y;\n                    }\n                    if (tempVector3.x > this._orthoRight) {\n                        this._orthoRight = tempVector3.x;\n                    }\n                    if (tempVector3.y > this._orthoTop) {\n                        this._orthoTop = tempVector3.y;\n                    }\n                    if (this.autoCalcShadowZBounds) {\n                        if (tempVector3.z < shadowMinZ) {\n                            shadowMinZ = tempVector3.z;\n                        }\n                        if (tempVector3.z > shadowMaxZ) {\n                            shadowMaxZ = tempVector3.z;\n                        }\n                    }\n                }\n            }\n            if (this.autoCalcShadowZBounds) {\n                this._shadowMinZ = shadowMinZ;\n                this._shadowMaxZ = shadowMaxZ;\n            }\n        }\n        const xOffset = this._orthoRight - this._orthoLeft;\n        const yOffset = this._orthoTop - this._orthoBottom;\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\n        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\n        Matrix.OrthoOffCenterLHToRef(this._orthoLeft - xOffset * this.shadowOrthoScale, this._orthoRight + xOffset * this.shadowOrthoScale, this._orthoBottom - yOffset * this.shadowOrthoScale, this._orthoTop + yOffset * this.shadowOrthoScale, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);\n    }\n    _buildUniformLayout() {\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\n        this._uniformBuffer.create();\n    }\n    /**\n     * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.\n     * @param effect The effect to update\n     * @param lightIndex The index of the light in the effect to update\n     * @returns The directional light\n     */\n    transferToEffect(effect, lightIndex) {\n        if (this.computeTransformedInformation()) {\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);\n            return this;\n        }\n        this._uniformBuffer.updateFloat4(\"vLightData\", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);\n        return this;\n    }\n    transferToNodeMaterialEffect(effect, lightDataUniformName) {\n        if (this.computeTransformedInformation()) {\n            effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);\n            return this;\n        }\n        effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);\n        return this;\n    }\n    /**\n     * Gets the minZ used for shadow according to both the scene and the light.\n     *\n     * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\n     * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\n     * (when not using reverse depth buffer / NDC half Z range)\n     * @param activeCamera The camera we are returning the min for\n     * @returns the depth min z\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getDepthMinZ(activeCamera) {\n        const engine = this._scene.getEngine();\n        return !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n    }\n    /**\n     * Gets the maxZ used for shadow according to both the scene and the light.\n     *\n     * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\n     * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\n     * (when not using reverse depth buffer / NDC half Z range)\n     * @param activeCamera The camera we are returning the max for\n     * @returns the depth max z\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getDepthMaxZ(activeCamera) {\n        const engine = this._scene.getEngine();\n        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n    }\n    /**\n     * Prepares the list of defines specific to the light type.\n     * @param defines the list of defines\n     * @param lightIndex defines the index of the light for the effect\n     */\n    prepareLightSpecificDefines(defines, lightIndex) {\n        defines[\"DIRLIGHT\" + lightIndex] = true;\n    }\n}\n__decorate([\n    serialize()\n], DirectionalLight.prototype, \"shadowFrustumSize\", null);\n__decorate([\n    serialize()\n], DirectionalLight.prototype, \"shadowOrthoScale\", null);\n__decorate([\n    serialize()\n], DirectionalLight.prototype, \"autoUpdateExtends\", void 0);\n__decorate([\n    serialize()\n], DirectionalLight.prototype, \"autoCalcShadowZBounds\", void 0);\n__decorate([\n    serialize(\"orthoLeft\")\n], DirectionalLight.prototype, \"_orthoLeft\", void 0);\n__decorate([\n    serialize(\"orthoRight\")\n], DirectionalLight.prototype, \"_orthoRight\", void 0);\n__decorate([\n    serialize(\"orthoTop\")\n], DirectionalLight.prototype, \"_orthoTop\", void 0);\n__decorate([\n    serialize(\"orthoBottom\")\n], DirectionalLight.prototype, \"_orthoBottom\", void 0);\n//# sourceMappingURL=directionalLight.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { serializeAsColor3, serializeAsVector3 } from \"../Misc/decorators.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Node } from \"../node.js\";\nimport { Light } from \"./light.js\";\nNode.AddNodeConstructor(\"Light_Type_3\", (name, scene) => {\n    return () => new HemisphericLight(name, Vector3.Zero(), scene);\n});\n/**\n * The HemisphericLight simulates the ambient environment light,\n * so the passed direction is the light reflection direction, not the incoming direction.\n */\nexport class HemisphericLight extends Light {\n    /**\n     * Creates a HemisphericLight object in the scene according to the passed direction (Vector3).\n     * The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.\n     * The HemisphericLight can't cast shadows.\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n     * @param name The friendly name of the light\n     * @param direction The direction of the light reflection\n     * @param scene The scene the light belongs to\n     */\n    constructor(name, direction, scene) {\n        super(name, scene);\n        /**\n         * The groundColor is the light in the opposite direction to the one specified during creation.\n         * You can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.\n         */\n        this.groundColor = new Color3(0.0, 0.0, 0.0);\n        this.direction = direction || Vector3.Up();\n    }\n    _buildUniformLayout() {\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n        this._uniformBuffer.addUniform(\"vLightGround\", 3);\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\n        this._uniformBuffer.create();\n    }\n    /**\n     * Returns the string \"HemisphericLight\".\n     * @returns The class name\n     */\n    getClassName() {\n        return \"HemisphericLight\";\n    }\n    /**\n     * Sets the HemisphericLight direction towards the passed target (Vector3).\n     * Returns the updated direction.\n     * @param target The target the direction should point to\n     * @returns The computed direction\n     */\n    setDirectionToTarget(target) {\n        this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));\n        return this.direction;\n    }\n    /**\n     * Returns the shadow generator associated to the light.\n     * @returns Always null for hemispheric lights because it does not support shadows.\n     */\n    getShadowGenerator() {\n        return null;\n    }\n    /**\n     * Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).\n     * @param _effect The effect to update\n     * @param lightIndex The index of the light in the effect to update\n     * @returns The hemispheric light\n     */\n    transferToEffect(_effect, lightIndex) {\n        const normalizeDirection = Vector3.Normalize(this.direction);\n        this._uniformBuffer.updateFloat4(\"vLightData\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, 0.0, lightIndex);\n        this._uniformBuffer.updateColor3(\"vLightGround\", this.groundColor.scale(this.intensity), lightIndex);\n        return this;\n    }\n    transferToNodeMaterialEffect(effect, lightDataUniformName) {\n        const normalizeDirection = Vector3.Normalize(this.direction);\n        effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);\n        return this;\n    }\n    /**\n     * Computes the world matrix of the node\n     * @returns the world matrix\n     */\n    computeWorldMatrix() {\n        if (!this._worldMatrix) {\n            this._worldMatrix = Matrix.Identity();\n        }\n        return this._worldMatrix;\n    }\n    /**\n     * Returns the integer 3.\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n     */\n    getTypeID() {\n        return Light.LIGHTTYPEID_HEMISPHERICLIGHT;\n    }\n    /**\n     * Prepares the list of defines specific to the light type.\n     * @param defines the list of defines\n     * @param lightIndex defines the index of the light for the effect\n     */\n    prepareLightSpecificDefines(defines, lightIndex) {\n        defines[\"HEMILIGHT\" + lightIndex] = true;\n    }\n}\n__decorate([\n    serializeAsColor3()\n], HemisphericLight.prototype, \"groundColor\", void 0);\n__decorate([\n    serializeAsVector3()\n], HemisphericLight.prototype, \"direction\", void 0);\n//# sourceMappingURL=hemisphericLight.js.map","/**\n * Size containing width and height\n */\nexport class Size {\n    /**\n     * Creates a Size object from the given width and height (floats).\n     * @param width width of the new size\n     * @param height height of the new size\n     */\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n    }\n    /**\n     * Returns a string with the Size width and height\n     * @returns a string with the Size width and height\n     */\n    toString() {\n        return `{W: ${this.width}, H: ${this.height}}`;\n    }\n    /**\n     * \"Size\"\n     * @returns the string \"Size\"\n     */\n    getClassName() {\n        return \"Size\";\n    }\n    /**\n     * Returns the Size hash code.\n     * @returns a hash code for a unique width and height\n     */\n    getHashCode() {\n        let hash = this.width | 0;\n        hash = (hash * 397) ^ (this.height | 0);\n        return hash;\n    }\n    /**\n     * Updates the current size from the given one.\n     * @param src the given size\n     */\n    copyFrom(src) {\n        this.width = src.width;\n        this.height = src.height;\n    }\n    /**\n     * Updates in place the current Size from the given floats.\n     * @param width width of the new size\n     * @param height height of the new size\n     * @returns the updated Size.\n     */\n    copyFromFloats(width, height) {\n        this.width = width;\n        this.height = height;\n        return this;\n    }\n    /**\n     * Updates in place the current Size from the given floats.\n     * @param width width to set\n     * @param height height to set\n     * @returns the updated Size.\n     */\n    set(width, height) {\n        return this.copyFromFloats(width, height);\n    }\n    /**\n     * Multiplies the width and height by numbers\n     * @param w factor to multiple the width by\n     * @param h factor to multiple the height by\n     * @returns a new Size set with the multiplication result of the current Size and the given floats.\n     */\n    multiplyByFloats(w, h) {\n        return new Size(this.width * w, this.height * h);\n    }\n    /**\n     * Clones the size\n     * @returns a new Size copied from the given one.\n     */\n    clone() {\n        return new Size(this.width, this.height);\n    }\n    /**\n     * True if the current Size and the given one width and height are strictly equal.\n     * @param other the other size to compare against\n     * @returns True if the current Size and the given one width and height are strictly equal.\n     */\n    equals(other) {\n        if (!other) {\n            return false;\n        }\n        return this.width === other.width && this.height === other.height;\n    }\n    /**\n     * The surface of the Size : width * height (float).\n     */\n    get surface() {\n        return this.width * this.height;\n    }\n    /**\n     * Create a new size of zero\n     * @returns a new Size set to (0.0, 0.0)\n     */\n    static Zero() {\n        return new Size(0.0, 0.0);\n    }\n    /**\n     * Sums the width and height of two sizes\n     * @param otherSize size to add to this size\n     * @returns a new Size set as the addition result of the current Size and the given one.\n     */\n    add(otherSize) {\n        const r = new Size(this.width + otherSize.width, this.height + otherSize.height);\n        return r;\n    }\n    /**\n     * Subtracts the width and height of two\n     * @param otherSize size to subtract to this size\n     * @returns a new Size set as the subtraction result of  the given one from the current Size.\n     */\n    subtract(otherSize) {\n        const r = new Size(this.width - otherSize.width, this.height - otherSize.height);\n        return r;\n    }\n    /**\n     * Creates a new Size set at the linear interpolation \"amount\" between \"start\" and \"end\"\n     * @param start starting size to lerp between\n     * @param end end size to lerp between\n     * @param amount amount to lerp between the start and end values\n     * @returns a new Size set at the linear interpolation \"amount\" between \"start\" and \"end\"\n     */\n    static Lerp(start, end, amount) {\n        const w = start.width + (end.width - start.width) * amount;\n        const h = start.height + (end.height - start.height) * amount;\n        return new Size(w, h);\n    }\n}\n//# sourceMappingURL=math.size.js.map","\nimport { Size } from \"../../Maths/math.size.js\";\n/**\n * Base class of all the textures in babylon.\n * It groups all the common properties required to work with Thin Engine.\n */\nexport class ThinTexture {\n    /**\n     * | Value | Type               | Description |\n     * | ----- | ------------------ | ----------- |\n     * | 0     | CLAMP_ADDRESSMODE  |             |\n     * | 1     | WRAP_ADDRESSMODE   |             |\n     * | 2     | MIRROR_ADDRESSMODE |             |\n     */\n    get wrapU() {\n        return this._wrapU;\n    }\n    set wrapU(value) {\n        this._wrapU = value;\n    }\n    /**\n     * | Value | Type               | Description |\n     * | ----- | ------------------ | ----------- |\n     * | 0     | CLAMP_ADDRESSMODE  |             |\n     * | 1     | WRAP_ADDRESSMODE   |             |\n     * | 2     | MIRROR_ADDRESSMODE |             |\n     */\n    get wrapV() {\n        return this._wrapV;\n    }\n    set wrapV(value) {\n        this._wrapV = value;\n    }\n    /**\n     * How a texture is mapped.\n     * Unused in thin texture mode.\n     */\n    get coordinatesMode() {\n        return 0;\n    }\n    /**\n     * Define if the texture is a cube texture or if false a 2d texture.\n     */\n    get isCube() {\n        if (!this._texture) {\n            return false;\n        }\n        return this._texture.isCube;\n    }\n    set isCube(value) {\n        if (!this._texture) {\n            return;\n        }\n        this._texture.isCube = value;\n    }\n    /**\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\n     */\n    get is3D() {\n        if (!this._texture) {\n            return false;\n        }\n        return this._texture.is3D;\n    }\n    set is3D(value) {\n        if (!this._texture) {\n            return;\n        }\n        this._texture.is3D = value;\n    }\n    /**\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\n     */\n    get is2DArray() {\n        if (!this._texture) {\n            return false;\n        }\n        return this._texture.is2DArray;\n    }\n    set is2DArray(value) {\n        if (!this._texture) {\n            return;\n        }\n        this._texture.is2DArray = value;\n    }\n    /**\n     * Get the class name of the texture.\n     * @returns \"ThinTexture\"\n     */\n    getClassName() {\n        return \"ThinTexture\";\n    }\n    static _IsRenderTargetWrapper(texture) {\n        return (texture === null || texture === void 0 ? void 0 : texture._shareDepth) !== undefined;\n    }\n    /**\n     * Instantiates a new ThinTexture.\n     * Base class of all the textures in babylon.\n     * This can be used as an internal texture wrapper in ThinEngine to benefit from the cache\n     * @param internalTexture Define the internalTexture to wrap. You can also pass a RenderTargetWrapper, in which case the texture will be the render target's texture\n     */\n    constructor(internalTexture) {\n        this._wrapU = 1;\n        this._wrapV = 1;\n        /**\n         * | Value | Type               | Description |\n         * | ----- | ------------------ | ----------- |\n         * | 0     | CLAMP_ADDRESSMODE  |             |\n         * | 1     | WRAP_ADDRESSMODE   |             |\n         * | 2     | MIRROR_ADDRESSMODE |             |\n         */\n        this.wrapR = 1;\n        /**\n         * With compliant hardware and browser (supporting anisotropic filtering)\n         * this defines the level of anisotropic filtering in the texture.\n         * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\n         */\n        this.anisotropicFilteringLevel = 4;\n        /**\n         * Define the current state of the loading sequence when in delayed load mode.\n         */\n        this.delayLoadState = 0;\n        /** @internal */\n        this._texture = null;\n        this._engine = null;\n        this._cachedSize = Size.Zero();\n        this._cachedBaseSize = Size.Zero();\n        /** @internal */\n        this._initialSamplingMode = 2;\n        this._texture = ThinTexture._IsRenderTargetWrapper(internalTexture) ? internalTexture.texture : internalTexture;\n        if (this._texture) {\n            this._engine = this._texture.getEngine();\n        }\n    }\n    /**\n     * Get if the texture is ready to be used (downloaded, converted, mip mapped...).\n     * @returns true if fully ready\n     */\n    isReady() {\n        if (this.delayLoadState === 4) {\n            this.delayLoad();\n            return false;\n        }\n        if (this._texture) {\n            return this._texture.isReady;\n        }\n        return false;\n    }\n    /**\n     * Triggers the load sequence in delayed load mode.\n     */\n    delayLoad() { }\n    /**\n     * Get the underlying lower level texture from Babylon.\n     * @returns the internal texture\n     */\n    getInternalTexture() {\n        return this._texture;\n    }\n    /**\n     * Get the size of the texture.\n     * @returns the texture size.\n     */\n    getSize() {\n        if (this._texture) {\n            if (this._texture.width) {\n                this._cachedSize.width = this._texture.width;\n                this._cachedSize.height = this._texture.height;\n                return this._cachedSize;\n            }\n            if (this._texture._size) {\n                this._cachedSize.width = this._texture._size;\n                this._cachedSize.height = this._texture._size;\n                return this._cachedSize;\n            }\n        }\n        return this._cachedSize;\n    }\n    /**\n     * Get the base size of the texture.\n     * It can be different from the size if the texture has been resized for POT for instance\n     * @returns the base size\n     */\n    getBaseSize() {\n        if (!this.isReady() || !this._texture) {\n            this._cachedBaseSize.width = 0;\n            this._cachedBaseSize.height = 0;\n            return this._cachedBaseSize;\n        }\n        if (this._texture._size) {\n            this._cachedBaseSize.width = this._texture._size;\n            this._cachedBaseSize.height = this._texture._size;\n            return this._cachedBaseSize;\n        }\n        this._cachedBaseSize.width = this._texture.baseWidth;\n        this._cachedBaseSize.height = this._texture.baseHeight;\n        return this._cachedBaseSize;\n    }\n    /**\n     * Get the current sampling mode associated with the texture.\n     */\n    get samplingMode() {\n        if (!this._texture) {\n            return this._initialSamplingMode;\n        }\n        return this._texture.samplingMode;\n    }\n    /**\n     * Update the sampling mode of the texture.\n     * Default is Trilinear mode.\n     *\n     * | Value | Type               | Description |\n     * | ----- | ------------------ | ----------- |\n     * | 1     | NEAREST_SAMPLINGMODE or NEAREST_NEAREST_MIPLINEAR  | Nearest is: mag = nearest, min = nearest, mip = linear |\n     * | 2     | BILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPNEAREST | Bilinear is: mag = linear, min = linear, mip = nearest |\n     * | 3     | TRILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPLINEAR | Trilinear is: mag = linear, min = linear, mip = linear |\n     * | 4     | NEAREST_NEAREST_MIPNEAREST |             |\n     * | 5    | NEAREST_LINEAR_MIPNEAREST |             |\n     * | 6    | NEAREST_LINEAR_MIPLINEAR |             |\n     * | 7    | NEAREST_LINEAR |             |\n     * | 8    | NEAREST_NEAREST |             |\n     * | 9   | LINEAR_NEAREST_MIPNEAREST |             |\n     * | 10   | LINEAR_NEAREST_MIPLINEAR |             |\n     * | 11   | LINEAR_LINEAR |             |\n     * | 12   | LINEAR_NEAREST |             |\n     *\n     *    > _mag_: magnification filter (close to the viewer)\n     *    > _min_: minification filter (far from the viewer)\n     *    > _mip_: filter used between mip map levels\n     *@param samplingMode Define the new sampling mode of the texture\n     */\n    updateSamplingMode(samplingMode) {\n        if (this._texture && this._engine) {\n            this._engine.updateTextureSamplingMode(samplingMode, this._texture);\n        }\n    }\n    /**\n     * Release and destroy the underlying lower level texture aka internalTexture.\n     */\n    releaseInternalTexture() {\n        if (this._texture) {\n            this._texture.dispose();\n            this._texture = null;\n        }\n    }\n    /**\n     * Dispose the texture and release its associated resources.\n     */\n    dispose() {\n        if (this._texture) {\n            this.releaseInternalTexture();\n            this._engine = null;\n        }\n    }\n}\n//# sourceMappingURL=thinTexture.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize, SerializationHelper, serializeAsTexture } from \"../../Misc/decorators.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Matrix } from \"../../Maths/math.vector.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\n\nimport { RandomGUID } from \"../../Misc/guid.js\";\nimport \"../../Misc/fileTools.js\";\nimport { ThinTexture } from \"./thinTexture.js\";\n/**\n * Base class of all the textures in babylon.\n * It groups all the common properties the materials, post process, lights... might need\n * in order to make a correct use of the texture.\n */\nexport class BaseTexture extends ThinTexture {\n    /**\n     * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).\n     */\n    set hasAlpha(value) {\n        if (this._hasAlpha === value) {\n            return;\n        }\n        this._hasAlpha = value;\n        if (this._scene) {\n            this._scene.markAllMaterialsAsDirty(1, (mat) => {\n                return mat.hasTexture(this);\n            });\n        }\n    }\n    get hasAlpha() {\n        return this._hasAlpha;\n    }\n    /**\n     * Defines if the alpha value should be determined via the rgb values.\n     * If true the luminance of the pixel might be used to find the corresponding alpha value.\n     */\n    set getAlphaFromRGB(value) {\n        if (this._getAlphaFromRGB === value) {\n            return;\n        }\n        this._getAlphaFromRGB = value;\n        if (this._scene) {\n            this._scene.markAllMaterialsAsDirty(1, (mat) => {\n                return mat.hasTexture(this);\n            });\n        }\n    }\n    get getAlphaFromRGB() {\n        return this._getAlphaFromRGB;\n    }\n    /**\n     * Define the UV channel to use starting from 0 and defaulting to 0.\n     * This is part of the texture as textures usually maps to one uv set.\n     */\n    set coordinatesIndex(value) {\n        if (this._coordinatesIndex === value) {\n            return;\n        }\n        this._coordinatesIndex = value;\n        if (this._scene) {\n            this._scene.markAllMaterialsAsDirty(1, (mat) => {\n                return mat.hasTexture(this);\n            });\n        }\n    }\n    get coordinatesIndex() {\n        return this._coordinatesIndex;\n    }\n    /**\n     * How a texture is mapped.\n     *\n     * | Value | Type                                | Description |\n     * | ----- | ----------------------------------- | ----------- |\n     * | 0     | EXPLICIT_MODE                       |             |\n     * | 1     | SPHERICAL_MODE                      |             |\n     * | 2     | PLANAR_MODE                         |             |\n     * | 3     | CUBIC_MODE                          |             |\n     * | 4     | PROJECTION_MODE                     |             |\n     * | 5     | SKYBOX_MODE                         |             |\n     * | 6     | INVCUBIC_MODE                       |             |\n     * | 7     | EQUIRECTANGULAR_MODE                |             |\n     * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |\n     * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |\n     */\n    set coordinatesMode(value) {\n        if (this._coordinatesMode === value) {\n            return;\n        }\n        this._coordinatesMode = value;\n        if (this._scene) {\n            this._scene.markAllMaterialsAsDirty(1, (mat) => {\n                return mat.hasTexture(this);\n            });\n        }\n    }\n    get coordinatesMode() {\n        return this._coordinatesMode;\n    }\n    /**\n     * | Value | Type               | Description |\n     * | ----- | ------------------ | ----------- |\n     * | 0     | CLAMP_ADDRESSMODE  |             |\n     * | 1     | WRAP_ADDRESSMODE   |             |\n     * | 2     | MIRROR_ADDRESSMODE |             |\n     */\n    get wrapU() {\n        return this._wrapU;\n    }\n    set wrapU(value) {\n        this._wrapU = value;\n    }\n    /**\n     * | Value | Type               | Description |\n     * | ----- | ------------------ | ----------- |\n     * | 0     | CLAMP_ADDRESSMODE  |             |\n     * | 1     | WRAP_ADDRESSMODE   |             |\n     * | 2     | MIRROR_ADDRESSMODE |             |\n     */\n    get wrapV() {\n        return this._wrapV;\n    }\n    set wrapV(value) {\n        this._wrapV = value;\n    }\n    /**\n     * Define if the texture is a cube texture or if false a 2d texture.\n     */\n    get isCube() {\n        if (!this._texture) {\n            return this._isCube;\n        }\n        return this._texture.isCube;\n    }\n    set isCube(value) {\n        if (!this._texture) {\n            this._isCube = value;\n        }\n        else {\n            this._texture.isCube = value;\n        }\n    }\n    /**\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\n     */\n    get is3D() {\n        if (!this._texture) {\n            return false;\n        }\n        return this._texture.is3D;\n    }\n    set is3D(value) {\n        if (!this._texture) {\n            return;\n        }\n        this._texture.is3D = value;\n    }\n    /**\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\n     */\n    get is2DArray() {\n        if (!this._texture) {\n            return false;\n        }\n        return this._texture.is2DArray;\n    }\n    set is2DArray(value) {\n        if (!this._texture) {\n            return;\n        }\n        this._texture.is2DArray = value;\n    }\n    /**\n     * Define if the texture contains data in gamma space (most of the png/jpg aside bump).\n     * HDR texture are usually stored in linear space.\n     * This only impacts the PBR and Background materials\n     */\n    get gammaSpace() {\n        if (!this._texture) {\n            return this._gammaSpace;\n        }\n        else {\n            if (this._texture._gammaSpace === null) {\n                this._texture._gammaSpace = this._gammaSpace;\n            }\n        }\n        return this._texture._gammaSpace && !this._texture._useSRGBBuffer;\n    }\n    set gammaSpace(gamma) {\n        if (!this._texture) {\n            if (this._gammaSpace === gamma) {\n                return;\n            }\n            this._gammaSpace = gamma;\n        }\n        else {\n            if (this._texture._gammaSpace === gamma) {\n                return;\n            }\n            this._texture._gammaSpace = gamma;\n        }\n        this._markAllSubMeshesAsTexturesDirty();\n    }\n    /**\n     * Gets or sets whether or not the texture contains RGBD data.\n     */\n    get isRGBD() {\n        return this._texture != null && this._texture._isRGBD;\n    }\n    set isRGBD(value) {\n        if (this._texture) {\n            this._texture._isRGBD = value;\n        }\n    }\n    /**\n     * Are mip maps generated for this texture or not.\n     */\n    get noMipmap() {\n        return false;\n    }\n    /**\n     * With prefiltered texture, defined the offset used during the prefiltering steps.\n     */\n    get lodGenerationOffset() {\n        if (this._texture) {\n            return this._texture._lodGenerationOffset;\n        }\n        return 0.0;\n    }\n    set lodGenerationOffset(value) {\n        if (this._texture) {\n            this._texture._lodGenerationOffset = value;\n        }\n    }\n    /**\n     * With prefiltered texture, defined the scale used during the prefiltering steps.\n     */\n    get lodGenerationScale() {\n        if (this._texture) {\n            return this._texture._lodGenerationScale;\n        }\n        return 0.0;\n    }\n    set lodGenerationScale(value) {\n        if (this._texture) {\n            this._texture._lodGenerationScale = value;\n        }\n    }\n    /**\n     * With prefiltered texture, defined if the specular generation is based on a linear ramp.\n     * By default we are using a log2 of the linear roughness helping to keep a better resolution for\n     * average roughness values.\n     */\n    get linearSpecularLOD() {\n        if (this._texture) {\n            return this._texture._linearSpecularLOD;\n        }\n        return false;\n    }\n    set linearSpecularLOD(value) {\n        if (this._texture) {\n            this._texture._linearSpecularLOD = value;\n        }\n    }\n    /**\n     * In case a better definition than spherical harmonics is required for the diffuse part of the environment.\n     * You can set the irradiance texture to rely on a texture instead of the spherical approach.\n     * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).\n     */\n    get irradianceTexture() {\n        if (this._texture) {\n            return this._texture._irradianceTexture;\n        }\n        return null;\n    }\n    set irradianceTexture(value) {\n        if (this._texture) {\n            this._texture._irradianceTexture = value;\n        }\n    }\n    /**\n     * Define the unique id of the texture in the scene.\n     */\n    get uid() {\n        if (!this._uid) {\n            this._uid = RandomGUID();\n        }\n        return this._uid;\n    }\n    /**\n     * Return a string representation of the texture.\n     * @returns the texture as a string\n     */\n    toString() {\n        return this.name;\n    }\n    /**\n     * Get the class name of the texture.\n     * @returns \"BaseTexture\"\n     */\n    getClassName() {\n        return \"BaseTexture\";\n    }\n    /**\n     * Callback triggered when the texture has been disposed.\n     * Kept for back compatibility, you can use the onDisposeObservable instead.\n     */\n    set onDispose(callback) {\n        if (this._onDisposeObserver) {\n            this.onDisposeObservable.remove(this._onDisposeObserver);\n        }\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    }\n    /**\n     * Define if the texture is preventing a material to render or not.\n     * If not and the texture is not ready, the engine will use a default black texture instead.\n     */\n    get isBlocking() {\n        return true;\n    }\n    /**\n     * Was there any loading error?\n     */\n    get loadingError() {\n        return this._loadingError;\n    }\n    /**\n     * If a loading error occurred this object will be populated with information about the error.\n     */\n    get errorObject() {\n        return this._errorObject;\n    }\n    /**\n     * Instantiates a new BaseTexture.\n     * Base class of all the textures in babylon.\n     * It groups all the common properties the materials, post process, lights... might need\n     * in order to make a correct use of the texture.\n     * @param sceneOrEngine Define the scene or engine the texture belongs to\n     * @param internalTexture Define the internal texture associated with the texture\n     */\n    constructor(sceneOrEngine, internalTexture = null) {\n        super(null);\n        /**\n         * Gets or sets an object used to store user defined information.\n         */\n        this.metadata = null;\n        /**\n         * For internal use only. Please do not use.\n         */\n        this.reservedDataStore = null;\n        this._hasAlpha = false;\n        this._getAlphaFromRGB = false;\n        /**\n         * Intensity or strength of the texture.\n         * It is commonly used by materials to fine tune the intensity of the texture\n         */\n        this.level = 1;\n        this._coordinatesIndex = 0;\n        /**\n         * Gets or sets a boolean indicating that the texture should try to reduce shader code if there is no UV manipulation.\n         * (ie. when texture.getTextureMatrix().isIdentityAs3x2() returns true)\n         */\n        this.optimizeUVAllocation = true;\n        this._coordinatesMode = 0;\n        /**\n         * | Value | Type               | Description |\n         * | ----- | ------------------ | ----------- |\n         * | 0     | CLAMP_ADDRESSMODE  |             |\n         * | 1     | WRAP_ADDRESSMODE   |             |\n         * | 2     | MIRROR_ADDRESSMODE |             |\n         */\n        this.wrapR = 1;\n        /**\n         * With compliant hardware and browser (supporting anisotropic filtering)\n         * this defines the level of anisotropic filtering in the texture.\n         * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\n         */\n        this.anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;\n        /** @internal */\n        this._isCube = false;\n        this._gammaSpace = true;\n        /**\n         * Is Z inverted in the texture (useful in a cube texture).\n         */\n        this.invertZ = false;\n        /**\n         * @internal\n         */\n        this.lodLevelInAlpha = false;\n        /**\n         * Define if the texture is a render target.\n         */\n        this.isRenderTarget = false;\n        /** @internal */\n        this._prefiltered = false;\n        /** @internal */\n        this._forceSerialize = false;\n        /**\n         * Define the list of animation attached to the texture.\n         */\n        this.animations = new Array();\n        /**\n         * An event triggered when the texture is disposed.\n         */\n        this.onDisposeObservable = new Observable();\n        this._onDisposeObserver = null;\n        this._scene = null;\n        /** @internal */\n        this._uid = null;\n        /** @internal */\n        this._parentContainer = null;\n        this._loadingError = false;\n        if (sceneOrEngine) {\n            if (BaseTexture._IsScene(sceneOrEngine)) {\n                this._scene = sceneOrEngine;\n            }\n            else {\n                this._engine = sceneOrEngine;\n            }\n        }\n        else {\n            this._scene = EngineStore.LastCreatedScene;\n        }\n        if (this._scene) {\n            this.uniqueId = this._scene.getUniqueId();\n            this._scene.addTexture(this);\n            this._engine = this._scene.getEngine();\n        }\n        this._texture = internalTexture;\n        this._uid = null;\n    }\n    /**\n     * Get the scene the texture belongs to.\n     * @returns the scene or null if undefined\n     */\n    getScene() {\n        return this._scene;\n    }\n    /** @internal */\n    _getEngine() {\n        return this._engine;\n    }\n    /**\n     * Checks if the texture has the same transform matrix than another texture\n     * @param texture texture to check against\n     * @returns true if the transforms are the same, else false\n     */\n    checkTransformsAreIdentical(texture) {\n        return texture !== null;\n    }\n    /**\n     * Get the texture transform matrix used to offset tile the texture for instance.\n     * @returns the transformation matrix\n     */\n    getTextureMatrix() {\n        return Matrix.IdentityReadOnly;\n    }\n    /**\n     * Get the texture reflection matrix used to rotate/transform the reflection.\n     * @returns the reflection matrix\n     */\n    getReflectionTextureMatrix() {\n        return Matrix.IdentityReadOnly;\n    }\n    /**\n     * Get if the texture is ready to be consumed (either it is ready or it is not blocking)\n     * @returns true if ready, not blocking or if there was an error loading the texture\n     */\n    isReadyOrNotBlocking() {\n        return !this.isBlocking || this.isReady() || this.loadingError;\n    }\n    /**\n     * Scales the texture if is `canRescale()`\n     * @param ratio the resize factor we want to use to rescale\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    scale(ratio) { }\n    /**\n     * Get if the texture can rescale.\n     */\n    get canRescale() {\n        return false;\n    }\n    /**\n     * @internal\n     */\n    _getFromCache(url, noMipmap, sampling, invertY, useSRGBBuffer, isCube) {\n        const engine = this._getEngine();\n        if (!engine) {\n            return null;\n        }\n        const correctedUseSRGBBuffer = engine._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);\n        const texturesCache = engine.getLoadedTexturesCache();\n        for (let index = 0; index < texturesCache.length; index++) {\n            const texturesCacheEntry = texturesCache[index];\n            if (useSRGBBuffer === undefined || correctedUseSRGBBuffer === texturesCacheEntry._useSRGBBuffer) {\n                if (invertY === undefined || invertY === texturesCacheEntry.invertY) {\n                    if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\n                        if (!sampling || sampling === texturesCacheEntry.samplingMode) {\n                            if (isCube === undefined || isCube === texturesCacheEntry.isCube) {\n                                texturesCacheEntry.incrementReferences();\n                                return texturesCacheEntry;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    /** @internal */\n    _rebuild() { }\n    /**\n     * Clones the texture.\n     * @returns the cloned texture\n     */\n    clone() {\n        return null;\n    }\n    /**\n     * Get the texture underlying type (INT, FLOAT...)\n     */\n    get textureType() {\n        if (!this._texture) {\n            return 0;\n        }\n        return this._texture.type !== undefined ? this._texture.type : 0;\n    }\n    /**\n     * Get the texture underlying format (RGB, RGBA...)\n     */\n    get textureFormat() {\n        if (!this._texture) {\n            return 5;\n        }\n        return this._texture.format !== undefined ? this._texture.format : 5;\n    }\n    /**\n     * Indicates that textures need to be re-calculated for all materials\n     */\n    _markAllSubMeshesAsTexturesDirty() {\n        const scene = this.getScene();\n        if (!scene) {\n            return;\n        }\n        scene.markAllMaterialsAsDirty(1);\n    }\n    /**\n     * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.\n     * This will returns an RGBA array buffer containing either in values (0-255) or\n     * float values (0-1) depending of the underlying buffer type.\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\n     * @param buffer defines a user defined buffer to fill with data (can be null)\n     * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\n     * @param noDataConversion false to convert the data to Uint8Array (if texture type is UNSIGNED_BYTE) or to Float32Array (if texture type is anything but UNSIGNED_BYTE). If true, the type of the generated buffer (if buffer==null) will depend on the type of the texture\n     * @param x defines the region x coordinates to start reading from (default to 0)\n     * @param y defines the region y coordinates to start reading from (default to 0)\n     * @param width defines the region width to read from (default to the texture size at level)\n     * @param height defines the region width to read from (default to the texture size at level)\n     * @returns The Array buffer promise containing the pixels data.\n     */\n    readPixels(faceIndex = 0, level = 0, buffer = null, flushRenderer = true, noDataConversion = false, x = 0, y = 0, width = Number.MAX_VALUE, height = Number.MAX_VALUE) {\n        if (!this._texture) {\n            return null;\n        }\n        const engine = this._getEngine();\n        if (!engine) {\n            return null;\n        }\n        const size = this.getSize();\n        let maxWidth = size.width;\n        let maxHeight = size.height;\n        if (level !== 0) {\n            maxWidth = maxWidth / Math.pow(2, level);\n            maxHeight = maxHeight / Math.pow(2, level);\n            maxWidth = Math.round(maxWidth);\n            maxHeight = Math.round(maxHeight);\n        }\n        width = Math.min(maxWidth, width);\n        height = Math.min(maxHeight, height);\n        try {\n            if (this._texture.isCube) {\n                return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y);\n            }\n            return engine._readTexturePixels(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion, x, y);\n        }\n        catch (e) {\n            return null;\n        }\n    }\n    /**\n     * @internal\n     */\n    _readPixelsSync(faceIndex = 0, level = 0, buffer = null, flushRenderer = true, noDataConversion = false) {\n        if (!this._texture) {\n            return null;\n        }\n        const size = this.getSize();\n        let width = size.width;\n        let height = size.height;\n        const engine = this._getEngine();\n        if (!engine) {\n            return null;\n        }\n        if (level != 0) {\n            width = width / Math.pow(2, level);\n            height = height / Math.pow(2, level);\n            width = Math.round(width);\n            height = Math.round(height);\n        }\n        try {\n            if (this._texture.isCube) {\n                return engine._readTexturePixelsSync(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);\n            }\n            return engine._readTexturePixelsSync(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);\n        }\n        catch (e) {\n            return null;\n        }\n    }\n    /** @internal */\n    get _lodTextureHigh() {\n        if (this._texture) {\n            return this._texture._lodTextureHigh;\n        }\n        return null;\n    }\n    /** @internal */\n    get _lodTextureMid() {\n        if (this._texture) {\n            return this._texture._lodTextureMid;\n        }\n        return null;\n    }\n    /** @internal */\n    get _lodTextureLow() {\n        if (this._texture) {\n            return this._texture._lodTextureLow;\n        }\n        return null;\n    }\n    /**\n     * Dispose the texture and release its associated resources.\n     */\n    dispose() {\n        if (this._scene) {\n            // Animations\n            if (this._scene.stopAnimation) {\n                this._scene.stopAnimation(this);\n            }\n            // Remove from scene\n            this._scene.removePendingData(this);\n            const index = this._scene.textures.indexOf(this);\n            if (index >= 0) {\n                this._scene.textures.splice(index, 1);\n            }\n            this._scene.onTextureRemovedObservable.notifyObservers(this);\n            this._scene = null;\n            if (this._parentContainer) {\n                const index = this._parentContainer.textures.indexOf(this);\n                if (index > -1) {\n                    this._parentContainer.textures.splice(index, 1);\n                }\n                this._parentContainer = null;\n            }\n        }\n        // Callback\n        this.onDisposeObservable.notifyObservers(this);\n        this.onDisposeObservable.clear();\n        this.metadata = null;\n        super.dispose();\n    }\n    /**\n     * Serialize the texture into a JSON representation that can be parsed later on.\n     * @param allowEmptyName True to force serialization even if name is empty. Default: false\n     * @returns the JSON representation of the texture\n     */\n    serialize(allowEmptyName = false) {\n        if (!this.name && !allowEmptyName) {\n            return null;\n        }\n        const serializationObject = SerializationHelper.Serialize(this);\n        // Animations\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n        return serializationObject;\n    }\n    /**\n     * Helper function to be called back once a list of texture contains only ready textures.\n     * @param textures Define the list of textures to wait for\n     * @param callback Define the callback triggered once the entire list will be ready\n     */\n    static WhenAllReady(textures, callback) {\n        let numRemaining = textures.length;\n        if (numRemaining === 0) {\n            callback();\n            return;\n        }\n        for (let i = 0; i < textures.length; i++) {\n            const texture = textures[i];\n            if (texture.isReady()) {\n                if (--numRemaining === 0) {\n                    callback();\n                }\n            }\n            else {\n                const onLoadObservable = texture.onLoadObservable;\n                if (onLoadObservable) {\n                    onLoadObservable.addOnce(() => {\n                        if (--numRemaining === 0) {\n                            callback();\n                        }\n                    });\n                }\n                else {\n                    if (--numRemaining === 0) {\n                        callback();\n                    }\n                }\n            }\n        }\n    }\n    static _IsScene(sceneOrEngine) {\n        return sceneOrEngine.getClassName() === \"Scene\";\n    }\n}\n/**\n * Default anisotropic filtering level for the application.\n * It is set to 4 as a good tradeoff between perf and quality.\n */\nBaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"uniqueId\", void 0);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"name\", void 0);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"metadata\", void 0);\n__decorate([\n    serialize(\"hasAlpha\")\n], BaseTexture.prototype, \"_hasAlpha\", void 0);\n__decorate([\n    serialize(\"getAlphaFromRGB\")\n], BaseTexture.prototype, \"_getAlphaFromRGB\", void 0);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"level\", void 0);\n__decorate([\n    serialize(\"coordinatesIndex\")\n], BaseTexture.prototype, \"_coordinatesIndex\", void 0);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"optimizeUVAllocation\", void 0);\n__decorate([\n    serialize(\"coordinatesMode\")\n], BaseTexture.prototype, \"_coordinatesMode\", void 0);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"wrapU\", null);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"wrapV\", null);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"wrapR\", void 0);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"anisotropicFilteringLevel\", void 0);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"isCube\", null);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"is3D\", null);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"is2DArray\", null);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"gammaSpace\", null);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"invertZ\", void 0);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"lodLevelInAlpha\", void 0);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"lodGenerationOffset\", null);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"lodGenerationScale\", null);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"linearSpecularLOD\", null);\n__decorate([\n    serializeAsTexture()\n], BaseTexture.prototype, \"irradianceTexture\", null);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"isRenderTarget\", void 0);\n//# sourceMappingURL=baseTexture.js.map","/**\n * Transform some pixel data to a base64 string\n * @param pixels defines the pixel data to transform to base64\n * @param size defines the width and height of the (texture) data\n * @param invertY true if the data must be inverted for the Y coordinate during the conversion\n * @returns The base64 encoded string or null\n */\nexport function GenerateBase64StringFromPixelData(pixels, size, invertY = false) {\n    const width = size.width;\n    const height = size.height;\n    if (pixels instanceof Float32Array) {\n        let len = pixels.byteLength / pixels.BYTES_PER_ELEMENT;\n        const npixels = new Uint8Array(len);\n        while (--len >= 0) {\n            let val = pixels[len];\n            if (val < 0) {\n                val = 0;\n            }\n            else if (val > 1) {\n                val = 1;\n            }\n            npixels[len] = val * 255;\n        }\n        pixels = npixels;\n    }\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) {\n        return null;\n    }\n    const imageData = ctx.createImageData(width, height);\n    const castData = imageData.data;\n    castData.set(pixels);\n    ctx.putImageData(imageData, 0, 0);\n    if (invertY) {\n        const canvas2 = document.createElement(\"canvas\");\n        canvas2.width = width;\n        canvas2.height = height;\n        const ctx2 = canvas2.getContext(\"2d\");\n        if (!ctx2) {\n            return null;\n        }\n        ctx2.translate(0, height);\n        ctx2.scale(1, -1);\n        ctx2.drawImage(canvas, 0, 0);\n        return canvas2.toDataURL(\"image/png\");\n    }\n    return canvas.toDataURL(\"image/png\");\n}\n/**\n * Reads the pixels stored in the webgl texture and returns them as a base64 string\n * @param texture defines the texture to read pixels from\n * @param faceIndex defines the face of the texture to read (in case of cube texture)\n * @param level defines the LOD level of the texture to read (in case of Mip Maps)\n * @returns The base64 encoded string or null\n */\nexport function GenerateBase64StringFromTexture(texture, faceIndex = 0, level = 0) {\n    const internalTexture = texture.getInternalTexture();\n    if (!internalTexture) {\n        return null;\n    }\n    const pixels = texture._readPixelsSync(faceIndex, level);\n    if (!pixels) {\n        return null;\n    }\n    return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);\n}\n/**\n * Reads the pixels stored in the webgl texture and returns them as a base64 string\n * @param texture defines the texture to read pixels from\n * @param faceIndex defines the face of the texture to read (in case of cube texture)\n * @param level defines the LOD level of the texture to read (in case of Mip Maps)\n * @returns The base64 encoded string or null wrapped in a promise\n */\nexport async function GenerateBase64StringFromTextureAsync(texture, faceIndex = 0, level = 0) {\n    const internalTexture = texture.getInternalTexture();\n    if (!internalTexture) {\n        return null;\n    }\n    const pixels = await texture.readPixels(faceIndex, level);\n    if (!pixels) {\n        return null;\n    }\n    return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);\n}\n/**\n * Class used to host copy specific utilities\n * (Back-compat)\n */\nexport const CopyTools = {\n    /**\n     * Transform some pixel data to a base64 string\n     * @param pixels defines the pixel data to transform to base64\n     * @param size defines the width and height of the (texture) data\n     * @param invertY true if the data must be inverted for the Y coordinate during the conversion\n     * @returns The base64 encoded string or null\n     */\n    GenerateBase64StringFromPixelData,\n    /**\n     * Reads the pixels stored in the webgl texture and returns them as a base64 string\n     * @param texture defines the texture to read pixels from\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\n     * @returns The base64 encoded string or null\n     */\n    GenerateBase64StringFromTexture,\n    /**\n     * Reads the pixels stored in the webgl texture and returns them as a base64 string\n     * @param texture defines the texture to read pixels from\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\n     * @returns The base64 encoded string or null wrapped in a promise\n     */\n    GenerateBase64StringFromTextureAsync,\n};\n//# sourceMappingURL=copyTools.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize, SerializationHelper } from \"../../Misc/decorators.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Matrix, TmpVectors, Vector3 } from \"../../Maths/math.vector.js\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture.js\";\n\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore.js\";\nimport { _WarnImport } from \"../../Misc/devTools.js\";\nimport { TimingTools } from \"../../Misc/timingTools.js\";\nimport { InstantiationTools } from \"../../Misc/instantiationTools.js\";\nimport { Plane } from \"../../Maths/math.plane.js\";\nimport { EncodeArrayBufferToBase64 } from \"../../Misc/stringTools.js\";\nimport { GenerateBase64StringFromTexture, GenerateBase64StringFromTextureAsync } from \"../../Misc/copyTools.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#texture\n */\nexport class Texture extends BaseTexture {\n    /**\n     * Are mip maps generated for this texture or not.\n     */\n    get noMipmap() {\n        return this._noMipmap;\n    }\n    /** Returns the texture mime type if it was defined by a loader (undefined else) */\n    get mimeType() {\n        return this._mimeType;\n    }\n    /**\n     * Is the texture preventing material to render while loading.\n     * If false, a default texture will be used instead of the loading one during the preparation step.\n     */\n    set isBlocking(value) {\n        this._isBlocking = value;\n    }\n    get isBlocking() {\n        return this._isBlocking;\n    }\n    /**\n     * Gets a boolean indicating if the texture needs to be inverted on the y axis during loading\n     */\n    get invertY() {\n        return this._invertY;\n    }\n    /**\n     * Instantiates a new texture.\n     * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#texture\n     * @param url defines the url of the picture to load as a texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading\n     * @param samplingMode defines the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)\n     * @param onLoad defines a callback triggered when the texture has been loaded\n     * @param onError defines a callback triggered when an error occurred during the loading session\n     * @param buffer defines the buffer to load the texture from in case the texture is loaded from a buffer representation\n     * @param deleteBuffer defines if the buffer we are loading the texture from should be deleted after load\n     * @param format defines the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\n     * @param mimeType defines an optional mime type information\n     * @param loaderOptions options to be passed to the loader\n     * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n     * @param forcedExtension defines the extension to use to pick the right loader\n     */\n    constructor(url, sceneOrEngine, noMipmapOrOptions, invertY, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, onLoad = null, onError = null, buffer = null, deleteBuffer = false, format, mimeType, loaderOptions, creationFlags, forcedExtension) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        super(sceneOrEngine);\n        /**\n         * Define the url of the texture.\n         */\n        this.url = null;\n        /**\n         * Define an offset on the texture to offset the u coordinates of the UVs\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#offsetting\n         */\n        this.uOffset = 0;\n        /**\n         * Define an offset on the texture to offset the v coordinates of the UVs\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#offsetting\n         */\n        this.vOffset = 0;\n        /**\n         * Define an offset on the texture to scale the u coordinates of the UVs\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#tiling\n         */\n        this.uScale = 1.0;\n        /**\n         * Define an offset on the texture to scale the v coordinates of the UVs\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#tiling\n         */\n        this.vScale = 1.0;\n        /**\n         * Define an offset on the texture to rotate around the u coordinates of the UVs\n         * The angle is defined in radians.\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials\n         */\n        this.uAng = 0;\n        /**\n         * Define an offset on the texture to rotate around the v coordinates of the UVs\n         * The angle is defined in radians.\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials\n         */\n        this.vAng = 0;\n        /**\n         * Define an offset on the texture to rotate around the w coordinates of the UVs (in case of 3d texture)\n         * The angle is defined in radians.\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials\n         */\n        this.wAng = 0;\n        /**\n         * Defines the center of rotation (U)\n         */\n        this.uRotationCenter = 0.5;\n        /**\n         * Defines the center of rotation (V)\n         */\n        this.vRotationCenter = 0.5;\n        /**\n         * Defines the center of rotation (W)\n         */\n        this.wRotationCenter = 0.5;\n        /**\n         * Sets this property to true to avoid deformations when rotating the texture with non-uniform scaling\n         */\n        this.homogeneousRotationInUVTransform = false;\n        /**\n         * List of inspectable custom properties (used by the Inspector)\n         * @see https://doc.babylonjs.com/toolsAndResources/inspector#extensibility\n         */\n        this.inspectableCustomProperties = null;\n        /** @internal */\n        this._noMipmap = false;\n        /** @internal */\n        this._invertY = false;\n        this._rowGenerationMatrix = null;\n        this._cachedTextureMatrix = null;\n        this._projectionModeMatrix = null;\n        this._t0 = null;\n        this._t1 = null;\n        this._t2 = null;\n        this._cachedUOffset = -1;\n        this._cachedVOffset = -1;\n        this._cachedUScale = 0;\n        this._cachedVScale = 0;\n        this._cachedUAng = -1;\n        this._cachedVAng = -1;\n        this._cachedWAng = -1;\n        this._cachedReflectionProjectionMatrixId = -1;\n        this._cachedURotationCenter = -1;\n        this._cachedVRotationCenter = -1;\n        this._cachedWRotationCenter = -1;\n        this._cachedHomogeneousRotationInUVTransform = false;\n        this._cachedReflectionTextureMatrix = null;\n        this._cachedReflectionUOffset = -1;\n        this._cachedReflectionVOffset = -1;\n        this._cachedReflectionUScale = 0;\n        this._cachedReflectionVScale = 0;\n        this._cachedReflectionCoordinatesMode = -1;\n        /** @internal */\n        this._buffer = null;\n        this._deleteBuffer = false;\n        this._format = null;\n        this._delayedOnLoad = null;\n        this._delayedOnError = null;\n        /**\n         * Observable triggered once the texture has been loaded.\n         */\n        this.onLoadObservable = new Observable();\n        this._isBlocking = true;\n        this.name = url || \"\";\n        this.url = url;\n        let noMipmap;\n        let useSRGBBuffer = false;\n        let internalTexture = null;\n        if (typeof noMipmapOrOptions === \"object\" && noMipmapOrOptions !== null) {\n            noMipmap = (_a = noMipmapOrOptions.noMipmap) !== null && _a !== void 0 ? _a : false;\n            invertY = (_b = noMipmapOrOptions.invertY) !== null && _b !== void 0 ? _b : (CompatibilityOptions.UseOpenGLOrientationForUV ? false : true);\n            samplingMode = (_c = noMipmapOrOptions.samplingMode) !== null && _c !== void 0 ? _c : Texture.TRILINEAR_SAMPLINGMODE;\n            onLoad = (_d = noMipmapOrOptions.onLoad) !== null && _d !== void 0 ? _d : null;\n            onError = (_e = noMipmapOrOptions.onError) !== null && _e !== void 0 ? _e : null;\n            buffer = (_f = noMipmapOrOptions.buffer) !== null && _f !== void 0 ? _f : null;\n            deleteBuffer = (_g = noMipmapOrOptions.deleteBuffer) !== null && _g !== void 0 ? _g : false;\n            format = noMipmapOrOptions.format;\n            mimeType = noMipmapOrOptions.mimeType;\n            loaderOptions = noMipmapOrOptions.loaderOptions;\n            creationFlags = noMipmapOrOptions.creationFlags;\n            useSRGBBuffer = (_h = noMipmapOrOptions.useSRGBBuffer) !== null && _h !== void 0 ? _h : false;\n            internalTexture = (_j = noMipmapOrOptions.internalTexture) !== null && _j !== void 0 ? _j : null;\n        }\n        else {\n            noMipmap = !!noMipmapOrOptions;\n        }\n        this._noMipmap = noMipmap;\n        this._invertY = invertY === undefined ? (CompatibilityOptions.UseOpenGLOrientationForUV ? false : true) : invertY;\n        this._initialSamplingMode = samplingMode;\n        this._buffer = buffer;\n        this._deleteBuffer = deleteBuffer;\n        this._mimeType = mimeType;\n        this._loaderOptions = loaderOptions;\n        this._creationFlags = creationFlags;\n        this._useSRGBBuffer = useSRGBBuffer;\n        this._forcedExtension = forcedExtension;\n        if (format) {\n            this._format = format;\n        }\n        const scene = this.getScene();\n        const engine = this._getEngine();\n        if (!engine) {\n            return;\n        }\n        engine.onBeforeTextureInitObservable.notifyObservers(this);\n        const load = () => {\n            if (this._texture) {\n                if (this._texture._invertVScale) {\n                    this.vScale *= -1;\n                    this.vOffset += 1;\n                }\n                // Update texture to match internal texture's wrapping\n                if (this._texture._cachedWrapU !== null) {\n                    this.wrapU = this._texture._cachedWrapU;\n                    this._texture._cachedWrapU = null;\n                }\n                if (this._texture._cachedWrapV !== null) {\n                    this.wrapV = this._texture._cachedWrapV;\n                    this._texture._cachedWrapV = null;\n                }\n                if (this._texture._cachedWrapR !== null) {\n                    this.wrapR = this._texture._cachedWrapR;\n                    this._texture._cachedWrapR = null;\n                }\n            }\n            if (this.onLoadObservable.hasObservers()) {\n                this.onLoadObservable.notifyObservers(this);\n            }\n            if (onLoad) {\n                onLoad();\n            }\n            if (!this.isBlocking && scene) {\n                scene.resetCachedMaterial();\n            }\n        };\n        const errorHandler = (message, exception) => {\n            this._loadingError = true;\n            this._errorObject = { message, exception };\n            if (onError) {\n                onError(message, exception);\n            }\n            Texture.OnTextureLoadErrorObservable.notifyObservers(this);\n        };\n        if (!this.url && !internalTexture) {\n            this._delayedOnLoad = load;\n            this._delayedOnError = errorHandler;\n            return;\n        }\n        this._texture = internalTexture !== null && internalTexture !== void 0 ? internalTexture : this._getFromCache(this.url, noMipmap, samplingMode, this._invertY, useSRGBBuffer);\n        if (!this._texture) {\n            if (!scene || !scene.useDelayedTextureLoading) {\n                try {\n                    this._texture = engine.createTexture(this.url, noMipmap, this._invertY, scene, samplingMode, load, errorHandler, this._buffer, undefined, this._format, this._forcedExtension, mimeType, loaderOptions, creationFlags, useSRGBBuffer);\n                }\n                catch (e) {\n                    errorHandler(\"error loading\", e);\n                    throw e;\n                }\n                if (deleteBuffer) {\n                    this._buffer = null;\n                }\n            }\n            else {\n                this.delayLoadState = 4;\n                this._delayedOnLoad = load;\n                this._delayedOnError = errorHandler;\n            }\n        }\n        else {\n            if (this._texture.isReady) {\n                TimingTools.SetImmediate(() => load());\n            }\n            else {\n                const loadObserver = this._texture.onLoadedObservable.add(load);\n                this._texture.onErrorObservable.add((e) => {\n                    var _a;\n                    errorHandler(e.message, e.exception);\n                    (_a = this._texture) === null || _a === void 0 ? void 0 : _a.onLoadedObservable.remove(loadObserver);\n                });\n            }\n        }\n    }\n    /**\n     * Update the url (and optional buffer) of this texture if url was null during construction.\n     * @param url the url of the texture\n     * @param buffer the buffer of the texture (defaults to null)\n     * @param onLoad callback called when the texture is loaded  (defaults to null)\n     * @param forcedExtension defines the extension to use to pick the right loader\n     */\n    updateURL(url, buffer = null, onLoad, forcedExtension) {\n        if (this.url) {\n            this.releaseInternalTexture();\n            this.getScene().markAllMaterialsAsDirty(1);\n        }\n        if (!this.name || this.name.startsWith(\"data:\")) {\n            this.name = url;\n        }\n        this.url = url;\n        this._buffer = buffer;\n        this._forcedExtension = forcedExtension;\n        this.delayLoadState = 4;\n        if (onLoad) {\n            this._delayedOnLoad = onLoad;\n        }\n        this.delayLoad();\n    }\n    /**\n     * Finish the loading sequence of a texture flagged as delayed load.\n     * @internal\n     */\n    delayLoad() {\n        if (this.delayLoadState !== 4) {\n            return;\n        }\n        const scene = this.getScene();\n        if (!scene) {\n            return;\n        }\n        this.delayLoadState = 1;\n        this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY, this._useSRGBBuffer);\n        if (!this._texture) {\n            this._texture = scene\n                .getEngine()\n                .createTexture(this.url, this._noMipmap, this._invertY, scene, this.samplingMode, this._delayedOnLoad, this._delayedOnError, this._buffer, null, this._format, this._forcedExtension, this._mimeType, this._loaderOptions, this._creationFlags, this._useSRGBBuffer);\n            if (this._deleteBuffer) {\n                this._buffer = null;\n            }\n        }\n        else {\n            if (this._delayedOnLoad) {\n                if (this._texture.isReady) {\n                    TimingTools.SetImmediate(this._delayedOnLoad);\n                }\n                else {\n                    this._texture.onLoadedObservable.add(this._delayedOnLoad);\n                }\n            }\n        }\n        this._delayedOnLoad = null;\n        this._delayedOnError = null;\n    }\n    _prepareRowForTextureGeneration(x, y, z, t) {\n        x *= this._cachedUScale;\n        y *= this._cachedVScale;\n        x -= this.uRotationCenter * this._cachedUScale;\n        y -= this.vRotationCenter * this._cachedVScale;\n        z -= this.wRotationCenter;\n        Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, this._rowGenerationMatrix, t);\n        t.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset;\n        t.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset;\n        t.z += this.wRotationCenter;\n    }\n    /**\n     * Checks if the texture has the same transform matrix than another texture\n     * @param texture texture to check against\n     * @returns true if the transforms are the same, else false\n     */\n    checkTransformsAreIdentical(texture) {\n        return (texture !== null &&\n            this.uOffset === texture.uOffset &&\n            this.vOffset === texture.vOffset &&\n            this.uScale === texture.uScale &&\n            this.vScale === texture.vScale &&\n            this.uAng === texture.uAng &&\n            this.vAng === texture.vAng &&\n            this.wAng === texture.wAng);\n    }\n    /**\n     * Get the current texture matrix which includes the requested offsetting, tiling and rotation components.\n     * @param uBase\n     * @returns the transform matrix of the texture.\n     */\n    getTextureMatrix(uBase = 1) {\n        if (this.uOffset === this._cachedUOffset &&\n            this.vOffset === this._cachedVOffset &&\n            this.uScale * uBase === this._cachedUScale &&\n            this.vScale === this._cachedVScale &&\n            this.uAng === this._cachedUAng &&\n            this.vAng === this._cachedVAng &&\n            this.wAng === this._cachedWAng &&\n            this.uRotationCenter === this._cachedURotationCenter &&\n            this.vRotationCenter === this._cachedVRotationCenter &&\n            this.wRotationCenter === this._cachedWRotationCenter &&\n            this.homogeneousRotationInUVTransform === this._cachedHomogeneousRotationInUVTransform) {\n            return this._cachedTextureMatrix;\n        }\n        this._cachedUOffset = this.uOffset;\n        this._cachedVOffset = this.vOffset;\n        this._cachedUScale = this.uScale * uBase;\n        this._cachedVScale = this.vScale;\n        this._cachedUAng = this.uAng;\n        this._cachedVAng = this.vAng;\n        this._cachedWAng = this.wAng;\n        this._cachedURotationCenter = this.uRotationCenter;\n        this._cachedVRotationCenter = this.vRotationCenter;\n        this._cachedWRotationCenter = this.wRotationCenter;\n        this._cachedHomogeneousRotationInUVTransform = this.homogeneousRotationInUVTransform;\n        if (!this._cachedTextureMatrix || !this._rowGenerationMatrix) {\n            this._cachedTextureMatrix = Matrix.Zero();\n            this._rowGenerationMatrix = new Matrix();\n            this._t0 = Vector3.Zero();\n            this._t1 = Vector3.Zero();\n            this._t2 = Vector3.Zero();\n        }\n        Matrix.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix);\n        if (this.homogeneousRotationInUVTransform) {\n            Matrix.TranslationToRef(-this._cachedURotationCenter, -this._cachedVRotationCenter, -this._cachedWRotationCenter, TmpVectors.Matrix[0]);\n            Matrix.TranslationToRef(this._cachedURotationCenter, this._cachedVRotationCenter, this._cachedWRotationCenter, TmpVectors.Matrix[1]);\n            Matrix.ScalingToRef(this._cachedUScale, this._cachedVScale, 0, TmpVectors.Matrix[2]);\n            Matrix.TranslationToRef(this._cachedUOffset, this._cachedVOffset, 0, TmpVectors.Matrix[3]);\n            TmpVectors.Matrix[0].multiplyToRef(this._rowGenerationMatrix, this._cachedTextureMatrix);\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[1], this._cachedTextureMatrix);\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[2], this._cachedTextureMatrix);\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[3], this._cachedTextureMatrix);\n            // copy the translation row to the 3rd row of the matrix so that we don't need to update the shaders (which expects the translation to be on the 3rd row)\n            this._cachedTextureMatrix.setRowFromFloats(2, this._cachedTextureMatrix.m[12], this._cachedTextureMatrix.m[13], this._cachedTextureMatrix.m[14], 1);\n        }\n        else {\n            this._prepareRowForTextureGeneration(0, 0, 0, this._t0);\n            this._prepareRowForTextureGeneration(1.0, 0, 0, this._t1);\n            this._prepareRowForTextureGeneration(0, 1.0, 0, this._t2);\n            this._t1.subtractInPlace(this._t0);\n            this._t2.subtractInPlace(this._t0);\n            Matrix.FromValuesToRef(this._t1.x, this._t1.y, this._t1.z, 0.0, this._t2.x, this._t2.y, this._t2.z, 0.0, this._t0.x, this._t0.y, this._t0.z, 0.0, 0.0, 0.0, 0.0, 1.0, this._cachedTextureMatrix);\n        }\n        const scene = this.getScene();\n        if (!scene) {\n            return this._cachedTextureMatrix;\n        }\n        if (this.optimizeUVAllocation) {\n            // We flag the materials that are using this texture as \"texture dirty\" because depending on the fact that the matrix is the identity or not, some defines\n            // will get different values (see MaterialHelper.PrepareDefinesForMergedUV), meaning we should regenerate the effect accordingly\n            scene.markAllMaterialsAsDirty(1, (mat) => {\n                return mat.hasTexture(this);\n            });\n        }\n        return this._cachedTextureMatrix;\n    }\n    /**\n     * Get the current matrix used to apply reflection. This is useful to rotate an environment texture for instance.\n     * @returns The reflection texture transform\n     */\n    getReflectionTextureMatrix() {\n        const scene = this.getScene();\n        if (!scene) {\n            return this._cachedReflectionTextureMatrix;\n        }\n        if (this.uOffset === this._cachedReflectionUOffset &&\n            this.vOffset === this._cachedReflectionVOffset &&\n            this.uScale === this._cachedReflectionUScale &&\n            this.vScale === this._cachedReflectionVScale &&\n            this.coordinatesMode === this._cachedReflectionCoordinatesMode) {\n            if (this.coordinatesMode === Texture.PROJECTION_MODE) {\n                if (this._cachedReflectionProjectionMatrixId === scene.getProjectionMatrix().updateFlag) {\n                    return this._cachedReflectionTextureMatrix;\n                }\n            }\n            else {\n                return this._cachedReflectionTextureMatrix;\n            }\n        }\n        if (!this._cachedReflectionTextureMatrix) {\n            this._cachedReflectionTextureMatrix = Matrix.Zero();\n        }\n        if (!this._projectionModeMatrix) {\n            this._projectionModeMatrix = Matrix.Zero();\n        }\n        const flagMaterialsAsTextureDirty = this._cachedReflectionCoordinatesMode !== this.coordinatesMode;\n        this._cachedReflectionUOffset = this.uOffset;\n        this._cachedReflectionVOffset = this.vOffset;\n        this._cachedReflectionUScale = this.uScale;\n        this._cachedReflectionVScale = this.vScale;\n        this._cachedReflectionCoordinatesMode = this.coordinatesMode;\n        switch (this.coordinatesMode) {\n            case Texture.PLANAR_MODE: {\n                Matrix.IdentityToRef(this._cachedReflectionTextureMatrix);\n                this._cachedReflectionTextureMatrix[0] = this.uScale;\n                this._cachedReflectionTextureMatrix[5] = this.vScale;\n                this._cachedReflectionTextureMatrix[12] = this.uOffset;\n                this._cachedReflectionTextureMatrix[13] = this.vOffset;\n                break;\n            }\n            case Texture.PROJECTION_MODE: {\n                Matrix.FromValuesToRef(0.5, 0.0, 0.0, 0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 1.0, 1.0, this._projectionModeMatrix);\n                const projectionMatrix = scene.getProjectionMatrix();\n                this._cachedReflectionProjectionMatrixId = projectionMatrix.updateFlag;\n                projectionMatrix.multiplyToRef(this._projectionModeMatrix, this._cachedReflectionTextureMatrix);\n                break;\n            }\n            default:\n                Matrix.IdentityToRef(this._cachedReflectionTextureMatrix);\n                break;\n        }\n        if (flagMaterialsAsTextureDirty) {\n            // We flag the materials that are using this texture as \"texture dirty\" if the coordinatesMode has changed.\n            // Indeed, this property is used to set the value of some defines used to generate the effect (in material.isReadyForSubMesh), so we must make sure this code will be re-executed and the effect recreated if necessary\n            scene.markAllMaterialsAsDirty(1, (mat) => {\n                return mat.getActiveTextures().indexOf(this) !== -1;\n            });\n        }\n        return this._cachedReflectionTextureMatrix;\n    }\n    /**\n     * Clones the texture.\n     * @returns the cloned texture\n     */\n    clone() {\n        const options = {\n            noMipmap: this._noMipmap,\n            invertY: this._invertY,\n            samplingMode: this.samplingMode,\n            onLoad: undefined,\n            onError: undefined,\n            buffer: this._texture ? this._texture._buffer : undefined,\n            deleteBuffer: this._deleteBuffer,\n            format: this.textureFormat,\n            mimeType: this.mimeType,\n            loaderOptions: this._loaderOptions,\n            creationFlags: this._creationFlags,\n            useSRGBBuffer: this._useSRGBBuffer,\n        };\n        return SerializationHelper.Clone(() => {\n            return new Texture(this._texture ? this._texture.url : null, this.getScene(), options);\n        }, this);\n    }\n    /**\n     * Serialize the texture to a JSON representation we can easily use in the respective Parse function.\n     * @returns The JSON representation of the texture\n     */\n    serialize() {\n        var _a, _b;\n        const savedName = this.name;\n        if (!Texture.SerializeBuffers) {\n            if (this.name.startsWith(\"data:\")) {\n                this.name = \"\";\n            }\n        }\n        if (this.name.startsWith(\"data:\") && this.url === this.name) {\n            this.url = \"\";\n        }\n        const serializationObject = super.serialize(Texture._SerializeInternalTextureUniqueId);\n        if (!serializationObject) {\n            return null;\n        }\n        if (Texture.SerializeBuffers || Texture.ForceSerializeBuffers) {\n            if (typeof this._buffer === \"string\" && this._buffer.substr(0, 5) === \"data:\") {\n                serializationObject.base64String = this._buffer;\n                serializationObject.name = serializationObject.name.replace(\"data:\", \"\");\n            }\n            else if (this.url && this.url.startsWith(\"data:\") && this._buffer instanceof Uint8Array) {\n                serializationObject.base64String = \"data:image/png;base64,\" + EncodeArrayBufferToBase64(this._buffer);\n            }\n            else if (Texture.ForceSerializeBuffers || (this.url && this.url.startsWith(\"blob:\")) || this._forceSerialize) {\n                serializationObject.base64String =\n                    !this._engine || this._engine._features.supportSyncTextureRead ? GenerateBase64StringFromTexture(this) : GenerateBase64StringFromTextureAsync(this);\n            }\n        }\n        serializationObject.invertY = this._invertY;\n        serializationObject.samplingMode = this.samplingMode;\n        serializationObject._creationFlags = this._creationFlags;\n        serializationObject._useSRGBBuffer = this._useSRGBBuffer;\n        if (Texture._SerializeInternalTextureUniqueId) {\n            serializationObject.internalTextureUniqueId = (_b = (_a = this._texture) === null || _a === void 0 ? void 0 : _a.uniqueId) !== null && _b !== void 0 ? _b : undefined;\n        }\n        this.name = savedName;\n        return serializationObject;\n    }\n    /**\n     * Get the current class name of the texture useful for serialization or dynamic coding.\n     * @returns \"Texture\"\n     */\n    getClassName() {\n        return \"Texture\";\n    }\n    /**\n     * Dispose the texture and release its associated resources.\n     */\n    dispose() {\n        super.dispose();\n        this.onLoadObservable.clear();\n        this._delayedOnLoad = null;\n        this._delayedOnError = null;\n        this._buffer = null;\n    }\n    /**\n     * Parse the JSON representation of a texture in order to recreate the texture in the given scene.\n     * @param parsedTexture Define the JSON representation of the texture\n     * @param scene Define the scene the parsed texture should be instantiated in\n     * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies\n     * @returns The parsed texture if successful\n     */\n    static Parse(parsedTexture, scene, rootUrl) {\n        if (parsedTexture.customType) {\n            const customTexture = InstantiationTools.Instantiate(parsedTexture.customType);\n            // Update Sampling Mode\n            const parsedCustomTexture = customTexture.Parse(parsedTexture, scene, rootUrl);\n            if (parsedTexture.samplingMode && parsedCustomTexture.updateSamplingMode && parsedCustomTexture._samplingMode) {\n                if (parsedCustomTexture._samplingMode !== parsedTexture.samplingMode) {\n                    parsedCustomTexture.updateSamplingMode(parsedTexture.samplingMode);\n                }\n            }\n            return parsedCustomTexture;\n        }\n        if (parsedTexture.isCube && !parsedTexture.isRenderTarget) {\n            return Texture._CubeTextureParser(parsedTexture, scene, rootUrl);\n        }\n        const hasInternalTextureUniqueId = parsedTexture.internalTextureUniqueId !== undefined;\n        if (!parsedTexture.name && !parsedTexture.isRenderTarget && !hasInternalTextureUniqueId) {\n            return null;\n        }\n        let internalTexture;\n        if (hasInternalTextureUniqueId) {\n            const cache = scene.getEngine().getLoadedTexturesCache();\n            for (const texture of cache) {\n                if (texture.uniqueId === parsedTexture.internalTextureUniqueId) {\n                    internalTexture = texture;\n                    break;\n                }\n            }\n        }\n        const onLoaded = (texture) => {\n            var _a;\n            // Clear cache\n            if (texture && texture._texture) {\n                texture._texture._cachedWrapU = null;\n                texture._texture._cachedWrapV = null;\n                texture._texture._cachedWrapR = null;\n            }\n            // Update Sampling Mode\n            if (parsedTexture.samplingMode) {\n                const sampling = parsedTexture.samplingMode;\n                if (texture && texture.samplingMode !== sampling) {\n                    texture.updateSamplingMode(sampling);\n                }\n            }\n            // Animations\n            if (texture && parsedTexture.animations) {\n                for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\n                    const parsedAnimation = parsedTexture.animations[animationIndex];\n                    const internalClass = GetClass(\"BABYLON.Animation\");\n                    if (internalClass) {\n                        texture.animations.push(internalClass.Parse(parsedAnimation));\n                    }\n                }\n            }\n            if (hasInternalTextureUniqueId && !internalTexture) {\n                (_a = texture === null || texture === void 0 ? void 0 : texture._texture) === null || _a === void 0 ? void 0 : _a._setUniqueId(parsedTexture.internalTextureUniqueId);\n            }\n        };\n        const texture = SerializationHelper.Parse(() => {\n            var _a, _b, _c;\n            let generateMipMaps = true;\n            if (parsedTexture.noMipmap) {\n                generateMipMaps = false;\n            }\n            if (parsedTexture.mirrorPlane) {\n                const mirrorTexture = Texture._CreateMirror(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps);\n                mirrorTexture._waitingRenderList = parsedTexture.renderList;\n                mirrorTexture.mirrorPlane = Plane.FromArray(parsedTexture.mirrorPlane);\n                onLoaded(mirrorTexture);\n                return mirrorTexture;\n            }\n            else if (parsedTexture.isRenderTarget) {\n                let renderTargetTexture = null;\n                if (parsedTexture.isCube) {\n                    // Search for an existing reflection probe (which contains a cube render target texture)\n                    if (scene.reflectionProbes) {\n                        for (let index = 0; index < scene.reflectionProbes.length; index++) {\n                            const probe = scene.reflectionProbes[index];\n                            if (probe.name === parsedTexture.name) {\n                                return probe.cubeTexture;\n                            }\n                        }\n                    }\n                }\n                else {\n                    renderTargetTexture = Texture._CreateRenderTargetTexture(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps, (_a = parsedTexture._creationFlags) !== null && _a !== void 0 ? _a : 0);\n                    renderTargetTexture._waitingRenderList = parsedTexture.renderList;\n                }\n                onLoaded(renderTargetTexture);\n                return renderTargetTexture;\n            }\n            else {\n                let texture;\n                if (parsedTexture.base64String && !internalTexture) {\n                    // name and url are the same to ensure caching happens from the actual base64 string\n                    texture = Texture.CreateFromBase64String(parsedTexture.base64String, parsedTexture.base64String, scene, !generateMipMaps, parsedTexture.invertY, parsedTexture.samplingMode, () => {\n                        onLoaded(texture);\n                    }, (_b = parsedTexture._creationFlags) !== null && _b !== void 0 ? _b : 0, (_c = parsedTexture._useSRGBBuffer) !== null && _c !== void 0 ? _c : false);\n                    // prettier name to fit with the loaded data\n                    texture.name = parsedTexture.name;\n                }\n                else {\n                    let url;\n                    if (parsedTexture.name && parsedTexture.name.indexOf(\"://\") > 0) {\n                        url = parsedTexture.name;\n                    }\n                    else {\n                        url = rootUrl + parsedTexture.name;\n                    }\n                    if (parsedTexture.url && (parsedTexture.url.startsWith(\"data:\") || Texture.UseSerializedUrlIfAny)) {\n                        url = parsedTexture.url;\n                    }\n                    const options = {\n                        noMipmap: !generateMipMaps,\n                        invertY: parsedTexture.invertY,\n                        samplingMode: parsedTexture.samplingMode,\n                        onLoad: () => {\n                            onLoaded(texture);\n                        },\n                        internalTexture,\n                    };\n                    texture = new Texture(url, scene, options);\n                }\n                return texture;\n            }\n        }, parsedTexture, scene);\n        return texture;\n    }\n    /**\n     * Creates a texture from its base 64 representation.\n     * @param data Define the base64 payload without the data: prefix\n     * @param name Define the name of the texture in the scene useful fo caching purpose for instance\n     * @param scene Define the scene the texture should belong to\n     * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture\n     * @param invertY define if the texture needs to be inverted on the y axis during loading\n     * @param samplingMode define the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)\n     * @param onLoad define a callback triggered when the texture has been loaded\n     * @param onError define a callback triggered when an error occurred during the loading session\n     * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\n     * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n     * @returns the created texture\n     */\n    static CreateFromBase64String(data, name, scene, noMipmapOrOptions, invertY, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, onLoad = null, onError = null, format = 5, creationFlags) {\n        return new Texture(\"data:\" + name, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, data, false, format, undefined, undefined, creationFlags);\n    }\n    /**\n     * Creates a texture from its data: representation. (data: will be added in case only the payload has been passed in)\n     * @param name Define the name of the texture in the scene useful fo caching purpose for instance\n     * @param buffer define the buffer to load the texture from in case the texture is loaded from a buffer representation\n     * @param scene Define the scene the texture should belong to\n     * @param deleteBuffer define if the buffer we are loading the texture from should be deleted after load\n     * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture\n     * @param invertY define if the texture needs to be inverted on the y axis during loading\n     * @param samplingMode define the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)\n     * @param onLoad define a callback triggered when the texture has been loaded\n     * @param onError define a callback triggered when an error occurred during the loading session\n     * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\n     * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n     * @returns the created texture\n     */\n    static LoadFromDataString(name, buffer, scene, deleteBuffer = false, noMipmapOrOptions, invertY = true, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, onLoad = null, onError = null, format = 5, creationFlags) {\n        if (name.substr(0, 5) !== \"data:\") {\n            name = \"data:\" + name;\n        }\n        return new Texture(name, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format, undefined, undefined, creationFlags);\n    }\n}\n/**\n * Gets or sets a general boolean used to indicate that textures containing direct data (buffers) must be saved as part of the serialization process\n */\nTexture.SerializeBuffers = true;\n/**\n * Gets or sets a general boolean used to indicate that texture buffers must be saved as part of the serialization process.\n * If no buffer exists, one will be created as base64 string from the internal webgl data.\n */\nTexture.ForceSerializeBuffers = false;\n/**\n * This observable will notify when any texture had a loading error\n */\nTexture.OnTextureLoadErrorObservable = new Observable();\n/** @internal */\nTexture._SerializeInternalTextureUniqueId = false;\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nTexture._CubeTextureParser = (jsonTexture, scene, rootUrl) => {\n    throw _WarnImport(\"CubeTexture\");\n};\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nTexture._CreateMirror = (name, renderTargetSize, scene, generateMipMaps) => {\n    throw _WarnImport(\"MirrorTexture\");\n};\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nTexture._CreateRenderTargetTexture = (name, renderTargetSize, scene, generateMipMaps, creationFlags) => {\n    throw _WarnImport(\"RenderTargetTexture\");\n};\n/** nearest is mag = nearest and min = nearest and no mip */\nTexture.NEAREST_SAMPLINGMODE = 1;\n/** nearest is mag = nearest and min = nearest and mip = linear */\nTexture.NEAREST_NEAREST_MIPLINEAR = 8; // nearest is mag = nearest and min = nearest and mip = linear\n/** Bilinear is mag = linear and min = linear and no mip */\nTexture.BILINEAR_SAMPLINGMODE = 2;\n/** Bilinear is mag = linear and min = linear and mip = nearest */\nTexture.LINEAR_LINEAR_MIPNEAREST = 11; // Bilinear is mag = linear and min = linear and mip = nearest\n/** Trilinear is mag = linear and min = linear and mip = linear */\nTexture.TRILINEAR_SAMPLINGMODE = 3;\n/** Trilinear is mag = linear and min = linear and mip = linear */\nTexture.LINEAR_LINEAR_MIPLINEAR = 3; // Trilinear is mag = linear and min = linear and mip = linear\n/** mag = nearest and min = nearest and mip = nearest */\nTexture.NEAREST_NEAREST_MIPNEAREST = 4;\n/** mag = nearest and min = linear and mip = nearest */\nTexture.NEAREST_LINEAR_MIPNEAREST = 5;\n/** mag = nearest and min = linear and mip = linear */\nTexture.NEAREST_LINEAR_MIPLINEAR = 6;\n/** mag = nearest and min = linear and mip = none */\nTexture.NEAREST_LINEAR = 7;\n/** mag = nearest and min = nearest and mip = none */\nTexture.NEAREST_NEAREST = 1;\n/** mag = linear and min = nearest and mip = nearest */\nTexture.LINEAR_NEAREST_MIPNEAREST = 9;\n/** mag = linear and min = nearest and mip = linear */\nTexture.LINEAR_NEAREST_MIPLINEAR = 10;\n/** mag = linear and min = linear and mip = none */\nTexture.LINEAR_LINEAR = 2;\n/** mag = linear and min = nearest and mip = none */\nTexture.LINEAR_NEAREST = 12;\n/** Explicit coordinates mode */\nTexture.EXPLICIT_MODE = 0;\n/** Spherical coordinates mode */\nTexture.SPHERICAL_MODE = 1;\n/** Planar coordinates mode */\nTexture.PLANAR_MODE = 2;\n/** Cubic coordinates mode */\nTexture.CUBIC_MODE = 3;\n/** Projection coordinates mode */\nTexture.PROJECTION_MODE = 4;\n/** Inverse Cubic coordinates mode */\nTexture.SKYBOX_MODE = 5;\n/** Inverse Cubic coordinates mode */\nTexture.INVCUBIC_MODE = 6;\n/** Equirectangular coordinates mode */\nTexture.EQUIRECTANGULAR_MODE = 7;\n/** Equirectangular Fixed coordinates mode */\nTexture.FIXED_EQUIRECTANGULAR_MODE = 8;\n/** Equirectangular Fixed Mirrored coordinates mode */\nTexture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;\n/** Texture is not repeating outside of 0..1 UVs */\nTexture.CLAMP_ADDRESSMODE = 0;\n/** Texture is repeating outside of 0..1 UVs */\nTexture.WRAP_ADDRESSMODE = 1;\n/** Texture is repeating and mirrored */\nTexture.MIRROR_ADDRESSMODE = 2;\n/**\n * Gets or sets a boolean which defines if the texture url must be build from the serialized URL instead of just using the name and loading them side by side with the scene file\n */\nTexture.UseSerializedUrlIfAny = false;\n__decorate([\n    serialize()\n], Texture.prototype, \"url\", void 0);\n__decorate([\n    serialize()\n], Texture.prototype, \"uOffset\", void 0);\n__decorate([\n    serialize()\n], Texture.prototype, \"vOffset\", void 0);\n__decorate([\n    serialize()\n], Texture.prototype, \"uScale\", void 0);\n__decorate([\n    serialize()\n], Texture.prototype, \"vScale\", void 0);\n__decorate([\n    serialize()\n], Texture.prototype, \"uAng\", void 0);\n__decorate([\n    serialize()\n], Texture.prototype, \"vAng\", void 0);\n__decorate([\n    serialize()\n], Texture.prototype, \"wAng\", void 0);\n__decorate([\n    serialize()\n], Texture.prototype, \"uRotationCenter\", void 0);\n__decorate([\n    serialize()\n], Texture.prototype, \"vRotationCenter\", void 0);\n__decorate([\n    serialize()\n], Texture.prototype, \"wRotationCenter\", void 0);\n__decorate([\n    serialize()\n], Texture.prototype, \"homogeneousRotationInUVTransform\", void 0);\n__decorate([\n    serialize()\n], Texture.prototype, \"isBlocking\", null);\n// References the dependencies.\nRegisterClass(\"BABYLON.Texture\", Texture);\nSerializationHelper._TextureParser = Texture.Parse;\n//# sourceMappingURL=texture.js.map","import { InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\n\n/**\n * Wrapper around a render target (either single or multi textures)\n */\nexport class RenderTargetWrapper {\n    /**\n     * Gets the depth/stencil texture (if created by a createDepthStencilTexture() call)\n     */\n    get depthStencilTexture() {\n        return this._depthStencilTexture;\n    }\n    /**\n     * Indicates if the depth/stencil texture has a stencil aspect\n     */\n    get depthStencilTextureWithStencil() {\n        return this._depthStencilTextureWithStencil;\n    }\n    /**\n     * Defines if the render target wrapper is for a cube texture or if false a 2d texture\n     */\n    get isCube() {\n        return this._isCube;\n    }\n    /**\n     * Defines if the render target wrapper is for a single or multi target render wrapper\n     */\n    get isMulti() {\n        return this._isMulti;\n    }\n    /**\n     * Defines if the render target wrapper is for a single or an array of textures\n     */\n    get is2DArray() {\n        return this.layers > 0;\n    }\n    /**\n     * Gets the size of the render target wrapper (used for cubes, as width=height in this case)\n     */\n    get size() {\n        return this.width;\n    }\n    /**\n     * Gets the width of the render target wrapper\n     */\n    get width() {\n        return this._size.width || this._size;\n    }\n    /**\n     * Gets the height of the render target wrapper\n     */\n    get height() {\n        return this._size.height || this._size;\n    }\n    /**\n     * Gets the number of layers of the render target wrapper (only used if is2DArray is true and wrapper is not a multi render target)\n     */\n    get layers() {\n        return this._size.layers || 0;\n    }\n    /**\n     * Gets the render texture. If this is a multi render target, gets the first texture\n     */\n    get texture() {\n        var _a, _b;\n        return (_b = (_a = this._textures) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\n    }\n    /**\n     * Gets the list of render textures. If we are not in a multi render target, the list will be null (use the texture getter instead)\n     */\n    get textures() {\n        return this._textures;\n    }\n    /**\n     * Gets the face indices that correspond to the list of render textures. If we are not in a multi render target, the list will be null\n     */\n    get faceIndices() {\n        return this._faceIndices;\n    }\n    /**\n     * Gets the layer indices that correspond to the list of render textures. If we are not in a multi render target, the list will be null\n     */\n    get layerIndices() {\n        return this._layerIndices;\n    }\n    /**\n     * Gets the sample count of the render target\n     */\n    get samples() {\n        return this._samples;\n    }\n    /**\n     * Sets the sample count of the render target\n     * @param value sample count\n     * @param initializeBuffers If set to true, the engine will make an initializing call to drawBuffers (only used when isMulti=true).\n     * @param force true to force calling the update sample count engine function even if the current sample count is equal to value\n     * @returns the sample count that has been set\n     */\n    setSamples(value, initializeBuffers = true, force = false) {\n        if (this.samples === value && !force) {\n            return value;\n        }\n        const result = this._isMulti\n            ? this._engine.updateMultipleRenderTargetTextureSampleCount(this, value, initializeBuffers)\n            : this._engine.updateRenderTargetTextureSampleCount(this, value);\n        this._samples = value;\n        return result;\n    }\n    /**\n     * Initializes the render target wrapper\n     * @param isMulti true if the wrapper is a multi render target\n     * @param isCube true if the wrapper should render to a cube texture\n     * @param size size of the render target (width/height/layers)\n     * @param engine engine used to create the render target\n     */\n    constructor(isMulti, isCube, size, engine) {\n        this._textures = null;\n        this._faceIndices = null;\n        this._layerIndices = null;\n        /** @internal */\n        this._samples = 1;\n        /** @internal */\n        this._attachments = null;\n        /** @internal */\n        this._generateStencilBuffer = false;\n        /** @internal */\n        this._generateDepthBuffer = false;\n        /** @internal */\n        this._depthStencilTextureWithStencil = false;\n        this._isMulti = isMulti;\n        this._isCube = isCube;\n        this._size = size;\n        this._engine = engine;\n        this._depthStencilTexture = null;\n    }\n    /**\n     * Sets the render target texture(s)\n     * @param textures texture(s) to set\n     */\n    setTextures(textures) {\n        if (Array.isArray(textures)) {\n            this._textures = textures;\n        }\n        else if (textures) {\n            this._textures = [textures];\n        }\n        else {\n            this._textures = null;\n        }\n    }\n    /**\n     * Set a texture in the textures array\n     * @param texture The texture to set\n     * @param index The index in the textures array to set\n     * @param disposePrevious If this function should dispose the previous texture\n     */\n    setTexture(texture, index = 0, disposePrevious = true) {\n        if (!this._textures) {\n            this._textures = [];\n        }\n        if (this._textures[index] && disposePrevious) {\n            this._textures[index].dispose();\n        }\n        this._textures[index] = texture;\n    }\n    /**\n     * Sets the layer and face indices of every render target texture bound to each color attachment\n     * @param layers The layers of each texture to be set\n     * @param faces The faces of each texture to be set\n     */\n    setLayerAndFaceIndices(layers, faces) {\n        this._layerIndices = layers;\n        this._faceIndices = faces;\n    }\n    /**\n     * Sets the layer and face indices of a texture in the textures array that should be bound to each color attachment\n     * @param index The index of the texture in the textures array to modify\n     * @param layer The layer of the texture to be set\n     * @param face The face of the texture to be set\n     */\n    setLayerAndFaceIndex(index = 0, layer, face) {\n        if (!this._layerIndices) {\n            this._layerIndices = [];\n        }\n        if (!this._faceIndices) {\n            this._faceIndices = [];\n        }\n        if (layer !== undefined && layer >= 0) {\n            this._layerIndices[index] = layer;\n        }\n        if (face !== undefined && face >= 0) {\n            this._faceIndices[index] = face;\n        }\n    }\n    /**\n     * Creates the depth/stencil texture\n     * @param comparisonFunction Comparison function to use for the texture\n     * @param bilinearFiltering true if bilinear filtering should be used when sampling the texture\n     * @param generateStencil true if the stencil aspect should also be created\n     * @param samples sample count to use when creating the texture\n     * @param format format of the depth texture\n     * @param label defines the label to use for the texture (for debugging purpose only)\n     * @returns the depth/stencil created texture\n     */\n    createDepthStencilTexture(comparisonFunction = 0, bilinearFiltering = true, generateStencil = false, samples = 1, format = 14, label) {\n        var _a;\n        (_a = this._depthStencilTexture) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._depthStencilTextureWithStencil = generateStencil;\n        this._depthStencilTexture = this._engine.createDepthStencilTexture(this._size, {\n            bilinearFiltering,\n            comparisonFunction,\n            generateStencil,\n            isCube: this._isCube,\n            samples,\n            depthTextureFormat: format,\n            label,\n        }, this);\n        return this._depthStencilTexture;\n    }\n    /**\n     * Shares the depth buffer of this render target with another render target.\n     * @internal\n     * @param renderTarget Destination renderTarget\n     */\n    _shareDepth(renderTarget) {\n        if (this._depthStencilTexture) {\n            if (renderTarget._depthStencilTexture) {\n                renderTarget._depthStencilTexture.dispose();\n            }\n            renderTarget._depthStencilTexture = this._depthStencilTexture;\n            this._depthStencilTexture.incrementReferences();\n        }\n    }\n    /**\n     * @internal\n     */\n    _swapAndDie(target) {\n        if (this.texture) {\n            this.texture._swapAndDie(target);\n        }\n        this._textures = null;\n        this.dispose(true);\n    }\n    _cloneRenderTargetWrapper() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        let rtw = null;\n        if (this._isMulti) {\n            const textureArray = this.textures;\n            if (textureArray && textureArray.length > 0) {\n                let generateDepthTexture = false;\n                let textureCount = textureArray.length;\n                const lastTextureSource = textureArray[textureArray.length - 1]._source;\n                if (lastTextureSource === InternalTextureSource.Depth || lastTextureSource === InternalTextureSource.DepthStencil) {\n                    generateDepthTexture = true;\n                    textureCount--;\n                }\n                const samplingModes = [];\n                const types = [];\n                const formats = [];\n                const targetTypes = [];\n                const faceIndex = [];\n                const layerIndex = [];\n                const layerCounts = [];\n                const internalTexture2Index = {};\n                for (let i = 0; i < textureCount; ++i) {\n                    const texture = textureArray[i];\n                    samplingModes.push(texture.samplingMode);\n                    types.push(texture.type);\n                    formats.push(texture.format);\n                    const index = internalTexture2Index[texture.uniqueId];\n                    if (index !== undefined) {\n                        targetTypes.push(-1);\n                        layerCounts.push(0);\n                    }\n                    else {\n                        internalTexture2Index[texture.uniqueId] = i;\n                        if (texture.is2DArray) {\n                            targetTypes.push(35866);\n                            layerCounts.push(texture.depth);\n                        }\n                        else if (texture.isCube) {\n                            targetTypes.push(34067);\n                            layerCounts.push(0);\n                        } /*else if (texture.isCubeArray) {\n                            targetTypes.push(3735928559);\n                            layerCounts.push(texture.depth);\n                        }*/\n                        else if (texture.is3D) {\n                            targetTypes.push(32879);\n                            layerCounts.push(texture.depth);\n                        }\n                        else {\n                            targetTypes.push(3553);\n                            layerCounts.push(0);\n                        }\n                    }\n                    if (this._faceIndices) {\n                        faceIndex.push((_a = this._faceIndices[i]) !== null && _a !== void 0 ? _a : 0);\n                    }\n                    if (this._layerIndices) {\n                        layerIndex.push((_b = this._layerIndices[i]) !== null && _b !== void 0 ? _b : 0);\n                    }\n                }\n                const optionsMRT = {\n                    samplingModes,\n                    generateMipMaps: textureArray[0].generateMipMaps,\n                    generateDepthBuffer: this._generateDepthBuffer,\n                    generateStencilBuffer: this._generateStencilBuffer,\n                    generateDepthTexture,\n                    types,\n                    formats,\n                    textureCount,\n                    targetTypes,\n                    faceIndex,\n                    layerIndex,\n                    layerCounts,\n                };\n                const size = {\n                    width: this.width,\n                    height: this.height,\n                };\n                rtw = this._engine.createMultipleRenderTarget(size, optionsMRT);\n                for (let i = 0; i < textureCount; ++i) {\n                    if (targetTypes[i] !== -1) {\n                        continue;\n                    }\n                    const index = internalTexture2Index[textureArray[i].uniqueId];\n                    rtw.setTexture(rtw.textures[index], i);\n                }\n            }\n        }\n        else {\n            const options = {};\n            options.generateDepthBuffer = this._generateDepthBuffer;\n            options.generateMipMaps = (_d = (_c = this.texture) === null || _c === void 0 ? void 0 : _c.generateMipMaps) !== null && _d !== void 0 ? _d : false;\n            options.generateStencilBuffer = this._generateStencilBuffer;\n            options.samplingMode = (_e = this.texture) === null || _e === void 0 ? void 0 : _e.samplingMode;\n            options.type = (_f = this.texture) === null || _f === void 0 ? void 0 : _f.type;\n            options.format = (_g = this.texture) === null || _g === void 0 ? void 0 : _g.format;\n            if (this.isCube) {\n                rtw = this._engine.createRenderTargetCubeTexture(this.width, options);\n            }\n            else {\n                const size = {\n                    width: this.width,\n                    height: this.height,\n                    layers: this.is2DArray ? (_h = this.texture) === null || _h === void 0 ? void 0 : _h.depth : undefined,\n                };\n                rtw = this._engine.createRenderTargetTexture(size, options);\n            }\n            rtw.texture.isReady = true;\n        }\n        return rtw;\n    }\n    _swapRenderTargetWrapper(target) {\n        if (this._textures && target._textures) {\n            for (let i = 0; i < this._textures.length; ++i) {\n                this._textures[i]._swapAndDie(target._textures[i], false);\n                target._textures[i].isReady = true;\n            }\n        }\n        if (this._depthStencilTexture && target._depthStencilTexture) {\n            this._depthStencilTexture._swapAndDie(target._depthStencilTexture);\n            target._depthStencilTexture.isReady = true;\n        }\n        this._textures = null;\n        this._depthStencilTexture = null;\n    }\n    /** @internal */\n    _rebuild() {\n        const rtw = this._cloneRenderTargetWrapper();\n        if (!rtw) {\n            return;\n        }\n        if (this._depthStencilTexture) {\n            const samplingMode = this._depthStencilTexture.samplingMode;\n            const bilinear = samplingMode === 2 ||\n                samplingMode === 3 ||\n                samplingMode === 11;\n            rtw.createDepthStencilTexture(this._depthStencilTexture._comparisonFunction, bilinear, this._depthStencilTextureWithStencil, this._depthStencilTexture.samples);\n        }\n        if (this.samples > 1) {\n            rtw.setSamples(this.samples);\n        }\n        rtw._swapRenderTargetWrapper(this);\n        rtw.dispose();\n    }\n    /**\n     * Releases the internal render textures\n     */\n    releaseTextures() {\n        var _a, _b;\n        if (this._textures) {\n            for (let i = 0; (_b = i < ((_a = this._textures) === null || _a === void 0 ? void 0 : _a.length)) !== null && _b !== void 0 ? _b : 0; ++i) {\n                this._textures[i].dispose();\n            }\n        }\n        this._textures = null;\n    }\n    /**\n     * Disposes the whole render target wrapper\n     * @param disposeOnlyFramebuffers true if only the frame buffers should be released (used for the WebGL engine). If false, all the textures will also be released\n     */\n    dispose(disposeOnlyFramebuffers = false) {\n        var _a;\n        if (!disposeOnlyFramebuffers) {\n            (_a = this._depthStencilTexture) === null || _a === void 0 ? void 0 : _a.dispose();\n            this._depthStencilTexture = null;\n            this.releaseTextures();\n        }\n        this._engine._releaseRenderTargetWrapper(this);\n    }\n}\n//# sourceMappingURL=renderTargetWrapper.js.map","import { RenderTargetWrapper } from \"../renderTargetWrapper.js\";\n/** @internal */\nexport class WebGLRenderTargetWrapper extends RenderTargetWrapper {\n    constructor(isMulti, isCube, size, engine, context) {\n        super(isMulti, isCube, size, engine);\n        this._framebuffer = null;\n        this._depthStencilBuffer = null;\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        this._MSAAFramebuffer = null;\n        // Multiview\n        this._colorTextureArray = null;\n        this._depthStencilTextureArray = null;\n        this._context = context;\n    }\n    _cloneRenderTargetWrapper() {\n        let rtw = null;\n        if (this._colorTextureArray && this._depthStencilTextureArray) {\n            rtw = this._engine.createMultiviewRenderTargetTexture(this.width, this.height);\n            rtw.texture.isReady = true;\n        }\n        else {\n            rtw = super._cloneRenderTargetWrapper();\n        }\n        return rtw;\n    }\n    _swapRenderTargetWrapper(target) {\n        super._swapRenderTargetWrapper(target);\n        target._framebuffer = this._framebuffer;\n        target._depthStencilBuffer = this._depthStencilBuffer;\n        target._MSAAFramebuffer = this._MSAAFramebuffer;\n        target._colorTextureArray = this._colorTextureArray;\n        target._depthStencilTextureArray = this._depthStencilTextureArray;\n        this._framebuffer = this._depthStencilBuffer = this._MSAAFramebuffer = this._colorTextureArray = this._depthStencilTextureArray = null;\n    }\n    /**\n     * Shares the depth buffer of this render target with another render target.\n     * @internal\n     * @param renderTarget Destination renderTarget\n     */\n    _shareDepth(renderTarget) {\n        super._shareDepth(renderTarget);\n        const gl = this._context;\n        const depthbuffer = this._depthStencilBuffer;\n        const framebuffer = renderTarget._MSAAFramebuffer || renderTarget._framebuffer;\n        if (renderTarget._depthStencilBuffer) {\n            gl.deleteRenderbuffer(renderTarget._depthStencilBuffer);\n        }\n        renderTarget._depthStencilBuffer = this._depthStencilBuffer;\n        this._engine._bindUnboundFramebuffer(framebuffer);\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthbuffer);\n        this._engine._bindUnboundFramebuffer(null);\n    }\n    /**\n     * Binds a texture to this render target on a specific attachment\n     * @param texture The texture to bind to the framebuffer\n     * @param attachmentIndex Index of the attachment\n     * @param faceIndexOrLayer The face or layer of the texture to render to in case of cube texture or array texture\n     * @param lodLevel defines the lod level to bind to the frame buffer\n     */\n    _bindTextureRenderTarget(texture, attachmentIndex = 0, faceIndexOrLayer, lodLevel = 0) {\n        var _a, _b, _c, _d;\n        if (!texture._hardwareTexture) {\n            return;\n        }\n        const framebuffer = this._framebuffer;\n        const currentFB = this._engine._currentFramebuffer;\n        this._engine._bindUnboundFramebuffer(framebuffer);\n        if (this._engine.webGLVersion > 1) {\n            const gl = this._context;\n            const attachment = gl[\"COLOR_ATTACHMENT\" + attachmentIndex];\n            if (texture.is2DArray || texture.is3D) {\n                faceIndexOrLayer = (_b = faceIndexOrLayer !== null && faceIndexOrLayer !== void 0 ? faceIndexOrLayer : (_a = this.layerIndices) === null || _a === void 0 ? void 0 : _a[attachmentIndex]) !== null && _b !== void 0 ? _b : 0;\n                gl.framebufferTextureLayer(gl.FRAMEBUFFER, attachment, texture._hardwareTexture.underlyingResource, lodLevel, faceIndexOrLayer);\n            }\n            else if (texture.isCube) {\n                // if face index is not specified, try to query it from faceIndices\n                // default is face 0\n                faceIndexOrLayer = (_d = faceIndexOrLayer !== null && faceIndexOrLayer !== void 0 ? faceIndexOrLayer : (_c = this.faceIndices) === null || _c === void 0 ? void 0 : _c[attachmentIndex]) !== null && _d !== void 0 ? _d : 0;\n                gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndexOrLayer, texture._hardwareTexture.underlyingResource, lodLevel);\n            }\n            else {\n                gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture._hardwareTexture.underlyingResource, lodLevel);\n            }\n        }\n        else {\n            // Default behavior (WebGL)\n            const gl = this._context;\n            const attachment = gl[\"COLOR_ATTACHMENT\" + attachmentIndex + \"_WEBGL\"];\n            const target = faceIndexOrLayer !== undefined ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndexOrLayer : gl.TEXTURE_2D;\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, target, texture._hardwareTexture.underlyingResource, lodLevel);\n        }\n        this._engine._bindUnboundFramebuffer(currentFB);\n    }\n    /**\n     * Set a texture in the textures array\n     * @param texture the texture to set\n     * @param index the index in the textures array to set\n     * @param disposePrevious If this function should dispose the previous texture\n     */\n    setTexture(texture, index = 0, disposePrevious = true) {\n        super.setTexture(texture, index, disposePrevious);\n        this._bindTextureRenderTarget(texture, index);\n    }\n    /**\n     * Sets the layer and face indices of every render target texture\n     * @param layers The layer of the texture to be set (make negative to not modify)\n     * @param faces The face of the texture to be set (make negative to not modify)\n     */\n    setLayerAndFaceIndices(layers, faces) {\n        var _a, _b;\n        super.setLayerAndFaceIndices(layers, faces);\n        if (!this.textures || !this.layerIndices || !this.faceIndices) {\n            return;\n        }\n        // the length of this._attachments is the right one as it does not count the depth texture, in case we generated it\n        const textureCount = (_b = (_a = this._attachments) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : this.textures.length;\n        for (let index = 0; index < textureCount; index++) {\n            const texture = this.textures[index];\n            if (!texture) {\n                // The target type was probably -1 at creation time and setTexture has not been called yet for this index\n                continue;\n            }\n            if (texture.is2DArray || texture.is3D) {\n                this._bindTextureRenderTarget(texture, index, this.layerIndices[index]);\n            }\n            else if (texture.isCube) {\n                this._bindTextureRenderTarget(texture, index, this.faceIndices[index]);\n            }\n            else {\n                this._bindTextureRenderTarget(texture, index);\n            }\n        }\n    }\n    /**\n     * Set the face and layer indices of a texture in the textures array\n     * @param index The index of the texture in the textures array to modify\n     * @param layer The layer of the texture to be set\n     * @param face The face of the texture to be set\n     */\n    setLayerAndFaceIndex(index = 0, layer, face) {\n        super.setLayerAndFaceIndex(index, layer, face);\n        if (!this.textures || !this.layerIndices || !this.faceIndices) {\n            return;\n        }\n        const texture = this.textures[index];\n        if (texture.is2DArray || texture.is3D) {\n            this._bindTextureRenderTarget(this.textures[index], index, this.layerIndices[index]);\n        }\n        else if (texture.isCube) {\n            this._bindTextureRenderTarget(this.textures[index], index, this.faceIndices[index]);\n        }\n    }\n    dispose(disposeOnlyFramebuffers = false) {\n        const gl = this._context;\n        if (!disposeOnlyFramebuffers) {\n            if (this._colorTextureArray) {\n                this._context.deleteTexture(this._colorTextureArray);\n                this._colorTextureArray = null;\n            }\n            if (this._depthStencilTextureArray) {\n                this._context.deleteTexture(this._depthStencilTextureArray);\n                this._depthStencilTextureArray = null;\n            }\n        }\n        if (this._framebuffer) {\n            gl.deleteFramebuffer(this._framebuffer);\n            this._framebuffer = null;\n        }\n        if (this._depthStencilBuffer) {\n            gl.deleteRenderbuffer(this._depthStencilBuffer);\n            this._depthStencilBuffer = null;\n        }\n        if (this._MSAAFramebuffer) {\n            gl.deleteFramebuffer(this._MSAAFramebuffer);\n            this._MSAAFramebuffer = null;\n        }\n        super.dispose(disposeOnlyFramebuffers);\n    }\n}\n//# sourceMappingURL=webGLRenderTargetWrapper.js.map","import { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { ThinEngine } from \"../thinEngine.js\";\nimport { WebGLRenderTargetWrapper } from \"../WebGL/webGLRenderTargetWrapper.js\";\n\nThinEngine.prototype._createHardwareRenderTargetWrapper = function (isMulti, isCube, size) {\n    const rtWrapper = new WebGLRenderTargetWrapper(isMulti, isCube, size, this, this._gl);\n    this._renderTargetWrapperCache.push(rtWrapper);\n    return rtWrapper;\n};\nThinEngine.prototype.createRenderTargetTexture = function (size, options) {\n    var _a, _b;\n    const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size);\n    let generateDepthBuffer = true;\n    let generateStencilBuffer = false;\n    let noColorAttachment = false;\n    let colorAttachment = undefined;\n    let samples = 1;\n    if (options !== undefined && typeof options === \"object\") {\n        generateDepthBuffer = (_a = options.generateDepthBuffer) !== null && _a !== void 0 ? _a : true;\n        generateStencilBuffer = !!options.generateStencilBuffer;\n        noColorAttachment = !!options.noColorAttachment;\n        colorAttachment = options.colorAttachment;\n        samples = (_b = options.samples) !== null && _b !== void 0 ? _b : 1;\n    }\n    const texture = colorAttachment || (noColorAttachment ? null : this._createInternalTexture(size, options, true, InternalTextureSource.RenderTarget));\n    const width = size.width || size;\n    const height = size.height || size;\n    const currentFrameBuffer = this._currentFramebuffer;\n    const gl = this._gl;\n    // Create the framebuffer\n    const framebuffer = gl.createFramebuffer();\n    this._bindUnboundFramebuffer(framebuffer);\n    rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(generateStencilBuffer, generateDepthBuffer, width, height);\n    // No need to rebind on every frame\n    if (texture && !texture.is2DArray) {\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture._hardwareTexture.underlyingResource, 0);\n    }\n    this._bindUnboundFramebuffer(currentFrameBuffer);\n    rtWrapper._framebuffer = framebuffer;\n    rtWrapper._generateDepthBuffer = generateDepthBuffer;\n    rtWrapper._generateStencilBuffer = generateStencilBuffer;\n    rtWrapper.setTextures(texture);\n    this.updateRenderTargetTextureSampleCount(rtWrapper, samples);\n    return rtWrapper;\n};\nThinEngine.prototype.createDepthStencilTexture = function (size, options, rtWrapper) {\n    if (options.isCube) {\n        const width = size.width || size;\n        return this._createDepthStencilCubeTexture(width, options, rtWrapper);\n    }\n    else {\n        return this._createDepthStencilTexture(size, options, rtWrapper);\n    }\n};\nThinEngine.prototype._createDepthStencilTexture = function (size, options, rtWrapper) {\n    const gl = this._gl;\n    const layers = size.layers || 0;\n    const target = layers !== 0 ? gl.TEXTURE_2D_ARRAY : gl.TEXTURE_2D;\n    const internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);\n    if (!this._caps.depthTextureExtension) {\n        Logger.Error(\"Depth texture is not supported by your browser or hardware.\");\n        return internalTexture;\n    }\n    const internalOptions = {\n        bilinearFiltering: false,\n        comparisonFunction: 0,\n        generateStencil: false,\n        ...options,\n    };\n    this._bindTextureDirectly(target, internalTexture, true);\n    this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.comparisonFunction === 0 ? false : internalOptions.bilinearFiltering, internalOptions.comparisonFunction, internalOptions.samples);\n    if (internalOptions.depthTextureFormat !== undefined) {\n        if (internalOptions.depthTextureFormat !== 15 &&\n            internalOptions.depthTextureFormat !== 16 &&\n            internalOptions.depthTextureFormat !== 17 &&\n            internalOptions.depthTextureFormat !== 13 &&\n            internalOptions.depthTextureFormat !== 14 &&\n            internalOptions.depthTextureFormat !== 18) {\n            Logger.Error(\"Depth texture format is not supported.\");\n            return internalTexture;\n        }\n        internalTexture.format = internalOptions.depthTextureFormat;\n    }\n    else {\n        internalTexture.format = internalOptions.generateStencil ? 13 : 16;\n    }\n    const hasStencil = internalTexture.format === 17 ||\n        internalTexture.format === 13 ||\n        internalTexture.format === 18;\n    rtWrapper._depthStencilTexture = internalTexture;\n    rtWrapper._depthStencilTextureWithStencil = hasStencil;\n    let type = gl.UNSIGNED_INT;\n    if (internalTexture.format === 15) {\n        type = gl.UNSIGNED_SHORT;\n    }\n    else if (internalTexture.format === 17 || internalTexture.format === 13) {\n        type = gl.UNSIGNED_INT_24_8;\n    }\n    else if (internalTexture.format === 14) {\n        type = gl.FLOAT;\n    }\n    else if (internalTexture.format === 18) {\n        type = gl.FLOAT_32_UNSIGNED_INT_24_8_REV;\n    }\n    const format = hasStencil ? gl.DEPTH_STENCIL : gl.DEPTH_COMPONENT;\n    let internalFormat = format;\n    if (this.webGLVersion > 1) {\n        if (internalTexture.format === 15) {\n            internalFormat = gl.DEPTH_COMPONENT16;\n        }\n        else if (internalTexture.format === 16) {\n            internalFormat = gl.DEPTH_COMPONENT24;\n        }\n        else if (internalTexture.format === 17 || internalTexture.format === 13) {\n            internalFormat = gl.DEPTH24_STENCIL8;\n        }\n        else if (internalTexture.format === 14) {\n            internalFormat = gl.DEPTH_COMPONENT32F;\n        }\n        else if (internalTexture.format === 18) {\n            internalFormat = gl.DEPTH32F_STENCIL8;\n        }\n    }\n    if (internalTexture.is2DArray) {\n        gl.texImage3D(target, 0, internalFormat, internalTexture.width, internalTexture.height, layers, 0, format, type, null);\n    }\n    else {\n        gl.texImage2D(target, 0, internalFormat, internalTexture.width, internalTexture.height, 0, format, type, null);\n    }\n    this._bindTextureDirectly(target, null);\n    this._internalTexturesCache.push(internalTexture);\n    // Dispose previous depth/stencil render buffers and clear the corresponding attachment.\n    // Next time this framebuffer is bound, the new depth/stencil texture will be attached.\n    const glRtWrapper = rtWrapper;\n    if (glRtWrapper._depthStencilBuffer) {\n        const currentFrameBuffer = this._currentFramebuffer;\n        this._bindUnboundFramebuffer(glRtWrapper._framebuffer);\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, null);\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, null);\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, null);\n        this._bindUnboundFramebuffer(currentFrameBuffer);\n        gl.deleteRenderbuffer(glRtWrapper._depthStencilBuffer);\n        glRtWrapper._depthStencilBuffer = null;\n    }\n    return internalTexture;\n};\nThinEngine.prototype.updateRenderTargetTextureSampleCount = function (rtWrapper, samples) {\n    if (this.webGLVersion < 2 || !rtWrapper || !rtWrapper.texture) {\n        return 1;\n    }\n    if (rtWrapper.samples === samples) {\n        return samples;\n    }\n    const gl = this._gl;\n    samples = Math.min(samples, this.getCaps().maxMSAASamples);\n    // Dispose previous render buffers\n    if (rtWrapper._depthStencilBuffer) {\n        gl.deleteRenderbuffer(rtWrapper._depthStencilBuffer);\n        rtWrapper._depthStencilBuffer = null;\n    }\n    if (rtWrapper._MSAAFramebuffer) {\n        gl.deleteFramebuffer(rtWrapper._MSAAFramebuffer);\n        rtWrapper._MSAAFramebuffer = null;\n    }\n    const hardwareTexture = rtWrapper.texture._hardwareTexture;\n    hardwareTexture.releaseMSAARenderBuffers();\n    if (samples > 1 && typeof gl.renderbufferStorageMultisample === \"function\") {\n        const framebuffer = gl.createFramebuffer();\n        if (!framebuffer) {\n            throw new Error(\"Unable to create multi sampled framebuffer\");\n        }\n        rtWrapper._MSAAFramebuffer = framebuffer;\n        this._bindUnboundFramebuffer(rtWrapper._MSAAFramebuffer);\n        const colorRenderbuffer = this._createRenderBuffer(rtWrapper.texture.width, rtWrapper.texture.height, samples, -1 /* not used */, this._getRGBAMultiSampleBufferFormat(rtWrapper.texture.type), gl.COLOR_ATTACHMENT0, false);\n        if (!colorRenderbuffer) {\n            throw new Error(\"Unable to create multi sampled framebuffer\");\n        }\n        hardwareTexture.addMSAARenderBuffer(colorRenderbuffer);\n    }\n    else {\n        this._bindUnboundFramebuffer(rtWrapper._framebuffer);\n    }\n    rtWrapper.texture.samples = samples;\n    rtWrapper._samples = samples;\n    rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(rtWrapper._generateStencilBuffer, rtWrapper._generateDepthBuffer, rtWrapper.texture.width, rtWrapper.texture.height, samples);\n    this._bindUnboundFramebuffer(null);\n    return samples;\n};\n//# sourceMappingURL=engine.renderTarget.js.map","import { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { Logger } from \"../../Misc/logger.js\";\n\nimport { ThinEngine } from \"../thinEngine.js\";\nThinEngine.prototype.createRenderTargetCubeTexture = function (size, options) {\n    const rtWrapper = this._createHardwareRenderTargetWrapper(false, true, size);\n    const fullOptions = {\n        generateMipMaps: true,\n        generateDepthBuffer: true,\n        generateStencilBuffer: false,\n        type: 0,\n        samplingMode: 3,\n        format: 5,\n        ...options,\n    };\n    fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && fullOptions.generateStencilBuffer;\n    if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {\n        // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\n        fullOptions.samplingMode = 1;\n    }\n    else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n        // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\n        fullOptions.samplingMode = 1;\n    }\n    const gl = this._gl;\n    const texture = new InternalTexture(this, InternalTextureSource.RenderTarget);\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n    const filters = this._getSamplingParameters(fullOptions.samplingMode, fullOptions.generateMipMaps);\n    if (fullOptions.type === 1 && !this._caps.textureFloat) {\n        fullOptions.type = 0;\n        Logger.Warn(\"Float textures are not supported. Cube render target forced to TEXTURETYPE_UNESIGNED_BYTE type\");\n    }\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    for (let face = 0; face < 6; face++) {\n        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, this._getRGBABufferInternalSizedFormat(fullOptions.type, fullOptions.format), size, size, 0, this._getInternalFormat(fullOptions.format), this._getWebGLTextureType(fullOptions.type), null);\n    }\n    // Create the framebuffer\n    const framebuffer = gl.createFramebuffer();\n    this._bindUnboundFramebuffer(framebuffer);\n    rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(fullOptions.generateStencilBuffer, fullOptions.generateDepthBuffer, size, size);\n    // MipMaps\n    if (fullOptions.generateMipMaps) {\n        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n    }\n    // Unbind\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n    this._bindUnboundFramebuffer(null);\n    rtWrapper._framebuffer = framebuffer;\n    rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;\n    rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer;\n    texture.width = size;\n    texture.height = size;\n    texture.isReady = true;\n    texture.isCube = true;\n    texture.samples = 1;\n    texture.generateMipMaps = fullOptions.generateMipMaps;\n    texture.samplingMode = fullOptions.samplingMode;\n    texture.type = fullOptions.type;\n    texture.format = fullOptions.format;\n    this._internalTexturesCache.push(texture);\n    rtWrapper.setTextures(texture);\n    return rtWrapper;\n};\n//# sourceMappingURL=engine.renderTargetCube.js.map","import { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Viewport } from \"../Maths/math.viewport.js\";\n\nimport { Observable } from \"../Misc/observable.js\";\nimport { Effect } from \"./effect.js\";\nimport { DrawWrapper } from \"./drawWrapper.js\";\n// Prevents ES6 Crash if not imported.\nimport \"../Shaders/postprocess.vertex.js\";\n// Fullscreen quad buffers by default.\nconst defaultOptions = {\n    positions: [1, 1, -1, 1, -1, -1, 1, -1],\n    indices: [0, 1, 2, 0, 2, 3],\n};\n/**\n * Helper class to render one or more effects.\n * You can access the previous rendering in your shader by declaring a sampler named textureSampler\n */\nexport class EffectRenderer {\n    /**\n     * Creates an effect renderer\n     * @param engine the engine to use for rendering\n     * @param options defines the options of the effect renderer\n     */\n    constructor(engine, options = defaultOptions) {\n        var _a, _b;\n        this._fullscreenViewport = new Viewport(0, 0, 1, 1);\n        const positions = (_a = options.positions) !== null && _a !== void 0 ? _a : defaultOptions.positions;\n        const indices = (_b = options.indices) !== null && _b !== void 0 ? _b : defaultOptions.indices;\n        this.engine = engine;\n        this._vertexBuffers = {\n            [VertexBuffer.PositionKind]: new VertexBuffer(engine, positions, VertexBuffer.PositionKind, false, false, 2),\n        };\n        this._indexBuffer = engine.createIndexBuffer(indices);\n        this._onContextRestoredObserver = engine.onContextRestoredObservable.add(() => {\n            this._indexBuffer = engine.createIndexBuffer(indices);\n            for (const key in this._vertexBuffers) {\n                const vertexBuffer = this._vertexBuffers[key];\n                vertexBuffer._rebuild();\n            }\n        });\n    }\n    /**\n     * Sets the current viewport in normalized coordinates 0-1\n     * @param viewport Defines the viewport to set (defaults to 0 0 1 1)\n     */\n    setViewport(viewport = this._fullscreenViewport) {\n        this.engine.setViewport(viewport);\n    }\n    /**\n     * Binds the embedded attributes buffer to the effect.\n     * @param effect Defines the effect to bind the attributes for\n     */\n    bindBuffers(effect) {\n        this.engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\n    }\n    /**\n     * Sets the current effect wrapper to use during draw.\n     * The effect needs to be ready before calling this api.\n     * This also sets the default full screen position attribute.\n     * @param effectWrapper Defines the effect to draw with\n     */\n    applyEffectWrapper(effectWrapper) {\n        this.engine.setState(true);\n        this.engine.depthCullingState.depthTest = false;\n        this.engine.stencilState.stencilTest = false;\n        this.engine.enableEffect(effectWrapper._drawWrapper);\n        this.bindBuffers(effectWrapper.effect);\n        effectWrapper.onApplyObservable.notifyObservers({});\n    }\n    /**\n     * Restores engine states\n     */\n    restoreStates() {\n        this.engine.depthCullingState.depthTest = true;\n        this.engine.stencilState.stencilTest = true;\n    }\n    /**\n     * Draws a full screen quad.\n     */\n    draw() {\n        this.engine.drawElementsType(0, 0, 6);\n    }\n    _isRenderTargetTexture(texture) {\n        return texture.renderTarget !== undefined;\n    }\n    /**\n     * renders one or more effects to a specified texture\n     * @param effectWrapper the effect to renderer\n     * @param outputTexture texture to draw to, if null it will render to the screen.\n     */\n    render(effectWrapper, outputTexture = null) {\n        // Ensure effect is ready\n        if (!effectWrapper.effect.isReady()) {\n            return;\n        }\n        // Reset state\n        this.setViewport();\n        const out = outputTexture === null ? null : this._isRenderTargetTexture(outputTexture) ? outputTexture.renderTarget : outputTexture;\n        if (out) {\n            this.engine.bindFramebuffer(out);\n        }\n        this.applyEffectWrapper(effectWrapper);\n        this.draw();\n        if (out) {\n            this.engine.unBindFramebuffer(out);\n        }\n        this.restoreStates();\n    }\n    /**\n     * Disposes of the effect renderer\n     */\n    dispose() {\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n        if (vertexBuffer) {\n            vertexBuffer.dispose();\n            delete this._vertexBuffers[VertexBuffer.PositionKind];\n        }\n        if (this._indexBuffer) {\n            this.engine._releaseBuffer(this._indexBuffer);\n        }\n        if (this._onContextRestoredObserver) {\n            this.engine.onContextRestoredObservable.remove(this._onContextRestoredObserver);\n            this._onContextRestoredObserver = null;\n        }\n    }\n}\n/**\n * Wraps an effect to be used for rendering\n */\nexport class EffectWrapper {\n    /**\n     * The underlying effect\n     */\n    get effect() {\n        return this._drawWrapper.effect;\n    }\n    set effect(effect) {\n        this._drawWrapper.effect = effect;\n    }\n    /**\n     * Creates an effect to be renderer\n     * @param creationOptions options to create the effect\n     */\n    constructor(creationOptions) {\n        /**\n         * Event that is fired right before the effect is drawn (should be used to update uniforms)\n         */\n        this.onApplyObservable = new Observable();\n        let effectCreationOptions;\n        const uniformNames = creationOptions.uniformNames || [];\n        if (creationOptions.vertexShader) {\n            effectCreationOptions = {\n                fragmentSource: creationOptions.fragmentShader,\n                vertexSource: creationOptions.vertexShader,\n                spectorName: creationOptions.name || \"effectWrapper\",\n            };\n        }\n        else {\n            // Default scale to use in post process vertex shader.\n            uniformNames.push(\"scale\");\n            effectCreationOptions = {\n                fragmentSource: creationOptions.fragmentShader,\n                vertex: \"postprocess\",\n                spectorName: creationOptions.name || \"effectWrapper\",\n            };\n            // Sets the default scale to identity for the post process vertex shader.\n            this.onApplyObservable.add(() => {\n                this.effect.setFloat2(\"scale\", 1, 1);\n            });\n        }\n        const defines = creationOptions.defines ? creationOptions.defines.join(\"\\n\") : \"\";\n        this._drawWrapper = new DrawWrapper(creationOptions.engine);\n        if (creationOptions.useShaderStore) {\n            effectCreationOptions.fragment = effectCreationOptions.fragmentSource;\n            if (!effectCreationOptions.vertex) {\n                effectCreationOptions.vertex = effectCreationOptions.vertexSource;\n            }\n            delete effectCreationOptions.fragmentSource;\n            delete effectCreationOptions.vertexSource;\n            this.effect = creationOptions.engine.createEffect(effectCreationOptions, creationOptions.attributeNames || [\"position\"], uniformNames, creationOptions.samplerNames, defines, undefined, creationOptions.onCompiled, undefined, undefined, creationOptions.shaderLanguage);\n        }\n        else {\n            this.effect = new Effect(effectCreationOptions, creationOptions.attributeNames || [\"position\"], uniformNames, creationOptions.samplerNames, creationOptions.engine, defines, undefined, creationOptions.onCompiled, undefined, undefined, undefined, creationOptions.shaderLanguage);\n            this._onContextRestoredObserver = creationOptions.engine.onContextRestoredObservable.add(() => {\n                this.effect._pipelineContext = null; // because _prepareEffect will try to dispose this pipeline before recreating it and that would lead to webgl errors\n                this.effect._wasPreviouslyReady = false;\n                this.effect._prepareEffect();\n            });\n        }\n    }\n    /**\n     * Disposes of the effect wrapper\n     */\n    dispose() {\n        if (this._onContextRestoredObserver) {\n            this.effect.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);\n            this._onContextRestoredObserver = null;\n        }\n        this.effect.dispose();\n    }\n}\n//# sourceMappingURL=effectRenderer.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"postprocessVertexShader\";\nconst shader = `attribute vec2 position;\runiform vec2 scale;\rvarying vec2 vUV;\rconst vec2 madd=vec2(0.5,0.5);\r#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\nvUV=(position*madd+madd)*scale;\rgl_Position=vec4(position,0.0,1.0);\r#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const postprocessVertexShader = { name, shader };\n//# sourceMappingURL=postprocess.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"passPixelShader\";\nconst shader = `varying vec2 vUV;\runiform sampler2D textureSampler;\r#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \r{\rgl_FragColor=texture2D(textureSampler,vUV);\r}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const passPixelShader = { name, shader };\n//# sourceMappingURL=pass.fragment.js.map","import { ThinEngine } from \"../Engines/thinEngine.js\";\n\nimport { EffectRenderer, EffectWrapper } from \"../Materials/effectRenderer.js\";\nimport { Tools } from \"./tools.js\";\nimport { passPixelShader } from \"../Shaders/pass.fragment.js\";\n/**\n * Class containing a set of static utilities functions to dump data from a canvas\n */\nexport class DumpTools {\n    static _CreateDumpRenderer() {\n        if (!DumpTools._DumpToolsEngine) {\n            const canvas = document.createElement(\"canvas\");\n            const engine = new ThinEngine(canvas, false, {\n                preserveDrawingBuffer: true,\n                depth: false,\n                stencil: false,\n                alpha: true,\n                premultipliedAlpha: false,\n                antialias: false,\n                failIfMajorPerformanceCaveat: false,\n            });\n            engine.getCaps().parallelShaderCompile = undefined;\n            const renderer = new EffectRenderer(engine);\n            const wrapper = new EffectWrapper({\n                engine,\n                name: passPixelShader.name,\n                fragmentShader: passPixelShader.shader,\n                samplerNames: [\"textureSampler\"],\n            });\n            DumpTools._DumpToolsEngine = {\n                canvas,\n                engine,\n                renderer,\n                wrapper,\n            };\n        }\n        return DumpTools._DumpToolsEngine;\n    }\n    /**\n     * Dumps the current bound framebuffer\n     * @param width defines the rendering width\n     * @param height defines the rendering height\n     * @param engine defines the hosting engine\n     * @param successCallback defines the callback triggered once the data are available\n     * @param mimeType defines the mime type of the result\n     * @param fileName defines the filename to download. If present, the result will automatically be downloaded\n     * @returns a void promise\n     */\n    static async DumpFramebuffer(width, height, engine, successCallback, mimeType = \"image/png\", fileName) {\n        // Read the contents of the framebuffer\n        const bufferView = await engine.readPixels(0, 0, width, height);\n        const data = new Uint8Array(bufferView.buffer);\n        DumpTools.DumpData(width, height, data, successCallback, mimeType, fileName, true);\n    }\n    /**\n     * Dumps an array buffer\n     * @param width defines the rendering width\n     * @param height defines the rendering height\n     * @param data the data array\n     * @param mimeType defines the mime type of the result\n     * @param fileName defines the filename to download. If present, the result will automatically be downloaded\n     * @param invertY true to invert the picture in the Y dimension\n     * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\n     * @param quality defines the quality of the result\n     * @returns a promise that resolve to the final data\n     */\n    static DumpDataAsync(width, height, data, mimeType = \"image/png\", fileName, invertY = false, toArrayBuffer = false, quality) {\n        return new Promise((resolve) => {\n            DumpTools.DumpData(width, height, data, (result) => resolve(result), mimeType, fileName, invertY, toArrayBuffer, quality);\n        });\n    }\n    /**\n     * Dumps an array buffer\n     * @param width defines the rendering width\n     * @param height defines the rendering height\n     * @param data the data array\n     * @param successCallback defines the callback triggered once the data are available\n     * @param mimeType defines the mime type of the result\n     * @param fileName defines the filename to download. If present, the result will automatically be downloaded\n     * @param invertY true to invert the picture in the Y dimension\n     * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\n     * @param quality defines the quality of the result\n     */\n    static DumpData(width, height, data, successCallback, mimeType = \"image/png\", fileName, invertY = false, toArrayBuffer = false, quality) {\n        const renderer = DumpTools._CreateDumpRenderer();\n        renderer.engine.setSize(width, height, true);\n        // Convert if data are float32\n        if (data instanceof Float32Array) {\n            const data2 = new Uint8Array(data.length);\n            let n = data.length;\n            while (n--) {\n                const v = data[n];\n                data2[n] = v < 0 ? 0 : v > 1 ? 1 : Math.round(v * 255);\n            }\n            data = data2;\n        }\n        // Create the image\n        const texture = renderer.engine.createRawTexture(data, width, height, 5, false, !invertY, 1);\n        renderer.renderer.setViewport();\n        renderer.renderer.applyEffectWrapper(renderer.wrapper);\n        renderer.wrapper.effect._bindTexture(\"textureSampler\", texture);\n        renderer.renderer.draw();\n        if (toArrayBuffer) {\n            Tools.ToBlob(renderer.canvas, (blob) => {\n                const fileReader = new FileReader();\n                fileReader.onload = (event) => {\n                    const arrayBuffer = event.target.result;\n                    if (successCallback) {\n                        successCallback(arrayBuffer);\n                    }\n                };\n                fileReader.readAsArrayBuffer(blob);\n            }, mimeType, quality);\n        }\n        else {\n            Tools.EncodeScreenshotCanvasData(renderer.canvas, successCallback, mimeType, fileName, quality);\n        }\n        texture.dispose();\n    }\n    /**\n     * Dispose the dump tools associated resources\n     */\n    static Dispose() {\n        if (DumpTools._DumpToolsEngine) {\n            DumpTools._DumpToolsEngine.wrapper.dispose();\n            DumpTools._DumpToolsEngine.renderer.dispose();\n            DumpTools._DumpToolsEngine.engine.dispose();\n        }\n        DumpTools._DumpToolsEngine = null;\n    }\n}\n/**\n * This will be executed automatically for UMD and es5.\n * If esm dev wants the side effects to execute they will have to run it manually\n * Once we build native modules those need to be exported.\n * @internal\n */\nconst initSideEffects = () => {\n    // References the dependencies.\n    Tools.DumpData = DumpTools.DumpData;\n    Tools.DumpDataAsync = DumpTools.DumpDataAsync;\n    Tools.DumpFramebuffer = DumpTools.DumpFramebuffer;\n};\ninitSideEffects();\n//# sourceMappingURL=dumpTools.js.map","import { Observable } from \"../../Misc/observable.js\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport { PostProcessManager } from \"../../PostProcesses/postProcessManager.js\";\nimport { RenderingManager } from \"../../Rendering/renderingManager.js\";\n\nimport \"../../Engines/Extensions/engine.renderTarget.js\";\nimport \"../../Engines/Extensions/engine.renderTargetCube.js\";\nimport { Engine } from \"../../Engines/engine.js\";\nimport { _ObserveArray } from \"../../Misc/arrayTools.js\";\nimport { DumpTools } from \"../../Misc/dumpTools.js\";\n/**\n * This Helps creating a texture that will be created from a camera in your scene.\n * It is basically a dynamic texture that could be used to create special effects for instance.\n * Actually, It is the base of lot of effects in the framework like post process, shadows, effect layers and rendering pipelines...\n */\nexport class RenderTargetTexture extends Texture {\n    /**\n     * Use this list to define the list of mesh you want to render.\n     */\n    get renderList() {\n        return this._renderList;\n    }\n    set renderList(value) {\n        if (this._unObserveRenderList) {\n            this._unObserveRenderList();\n            this._unObserveRenderList = null;\n        }\n        if (value) {\n            this._unObserveRenderList = _ObserveArray(value, this._renderListHasChanged);\n        }\n        this._renderList = value;\n    }\n    /**\n     * Post-processes for this render target\n     */\n    get postProcesses() {\n        return this._postProcesses;\n    }\n    get _prePassEnabled() {\n        return !!this._prePassRenderTarget && this._prePassRenderTarget.enabled;\n    }\n    /**\n     * Set a after unbind callback in the texture.\n     * This has been kept for backward compatibility and use of onAfterUnbindObservable is recommended.\n     */\n    set onAfterUnbind(callback) {\n        if (this._onAfterUnbindObserver) {\n            this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);\n        }\n        this._onAfterUnbindObserver = this.onAfterUnbindObservable.add(callback);\n    }\n    /**\n     * Set a before render callback in the texture.\n     * This has been kept for backward compatibility and use of onBeforeRenderObservable is recommended.\n     */\n    set onBeforeRender(callback) {\n        if (this._onBeforeRenderObserver) {\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n        }\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n    }\n    /**\n     * Set a after render callback in the texture.\n     * This has been kept for backward compatibility and use of onAfterRenderObservable is recommended.\n     */\n    set onAfterRender(callback) {\n        if (this._onAfterRenderObserver) {\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n        }\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n    }\n    /**\n     * Set a clear callback in the texture.\n     * This has been kept for backward compatibility and use of onClearObservable is recommended.\n     */\n    set onClear(callback) {\n        if (this._onClearObserver) {\n            this.onClearObservable.remove(this._onClearObserver);\n        }\n        this._onClearObserver = this.onClearObservable.add(callback);\n    }\n    /**\n     * Gets the render pass ids used by the render target texture. For a single render target the array length will be 1, for a cube texture it will be 6 and for\n     * a 2D texture array it will return an array of ids the size of the 2D texture array\n     */\n    get renderPassIds() {\n        return this._renderPassIds;\n    }\n    /**\n     * Gets the current value of the refreshId counter\n     */\n    get currentRefreshId() {\n        return this._currentRefreshId;\n    }\n    /**\n     * Sets a specific material to be used to render a mesh/a list of meshes in this render target texture\n     * @param mesh mesh or array of meshes\n     * @param material material or array of materials to use for this render pass. If undefined is passed, no specific material will be used but the regular material instead (mesh.material). It's possible to provide an array of materials to use a different material for each rendering in the case of a cube texture (6 rendering) and a 2D texture array (as many rendering as the length of the array)\n     */\n    setMaterialForRendering(mesh, material) {\n        let meshes;\n        if (!Array.isArray(mesh)) {\n            meshes = [mesh];\n        }\n        else {\n            meshes = mesh;\n        }\n        for (let j = 0; j < meshes.length; ++j) {\n            for (let i = 0; i < this._renderPassIds.length; ++i) {\n                meshes[j].setMaterialForRenderPass(this._renderPassIds[i], material !== undefined ? (Array.isArray(material) ? material[i] : material) : undefined);\n            }\n        }\n    }\n    /**\n     * Define if the texture has multiple draw buffers or if false a single draw buffer.\n     */\n    get isMulti() {\n        var _a, _b;\n        return (_b = (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.isMulti) !== null && _b !== void 0 ? _b : false;\n    }\n    /**\n     * Gets render target creation options that were used.\n     */\n    get renderTargetOptions() {\n        return this._renderTargetOptions;\n    }\n    /**\n     * Gets the render target wrapper associated with this render target\n     */\n    get renderTarget() {\n        return this._renderTarget;\n    }\n    _onRatioRescale() {\n        if (this._sizeRatio) {\n            this.resize(this._initialSizeParameter);\n        }\n    }\n    /**\n     * Gets or sets the size of the bounding box associated with the texture (when in cube mode)\n     * When defined, the cubemap will switch to local mode\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\n     * @example https://www.babylonjs-playground.com/#RNASML\n     */\n    set boundingBoxSize(value) {\n        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\n            return;\n        }\n        this._boundingBoxSize = value;\n        const scene = this.getScene();\n        if (scene) {\n            scene.markAllMaterialsAsDirty(1);\n        }\n    }\n    get boundingBoxSize() {\n        return this._boundingBoxSize;\n    }\n    /**\n     * In case the RTT has been created with a depth texture, get the associated\n     * depth texture.\n     * Otherwise, return null.\n     */\n    get depthStencilTexture() {\n        var _a, _b;\n        return (_b = (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a._depthStencilTexture) !== null && _b !== void 0 ? _b : null;\n    }\n    /** @internal */\n    constructor(name, size, scene, generateMipMaps = false, doNotChangeAspectRatio = true, type = 0, isCube = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, generateDepthBuffer = true, generateStencilBuffer = false, isMulti = false, format = 5, delayAllocation = false, samples, creationFlags, noColorAttachment = false, useSRGBBuffer = false) {\n        var _a, _b, _c, _d, _e, _f;\n        let colorAttachment = undefined;\n        if (typeof generateMipMaps === \"object\") {\n            const options = generateMipMaps;\n            generateMipMaps = !!options.generateMipMaps;\n            doNotChangeAspectRatio = (_a = options.doNotChangeAspectRatio) !== null && _a !== void 0 ? _a : true;\n            type = (_b = options.type) !== null && _b !== void 0 ? _b : 0;\n            isCube = !!options.isCube;\n            samplingMode = (_c = options.samplingMode) !== null && _c !== void 0 ? _c : Texture.TRILINEAR_SAMPLINGMODE;\n            generateDepthBuffer = (_d = options.generateDepthBuffer) !== null && _d !== void 0 ? _d : true;\n            generateStencilBuffer = !!options.generateStencilBuffer;\n            isMulti = !!options.isMulti;\n            format = (_e = options.format) !== null && _e !== void 0 ? _e : 5;\n            delayAllocation = !!options.delayAllocation;\n            samples = options.samples;\n            creationFlags = options.creationFlags;\n            noColorAttachment = !!options.noColorAttachment;\n            useSRGBBuffer = !!options.useSRGBBuffer;\n            colorAttachment = options.colorAttachment;\n        }\n        super(null, scene, !generateMipMaps, undefined, samplingMode, undefined, undefined, undefined, undefined, format);\n        this._unObserveRenderList = null;\n        this._renderListHasChanged = (_functionName, previousLength) => {\n            var _a;\n            const newLength = this._renderList ? this._renderList.length : 0;\n            if ((previousLength === 0 && newLength > 0) || newLength === 0) {\n                (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.meshes.forEach((mesh) => {\n                    mesh._markSubMeshesAsLightDirty();\n                });\n            }\n        };\n        /**\n         * Define if particles should be rendered in your texture.\n         */\n        this.renderParticles = true;\n        /**\n         * Define if sprites should be rendered in your texture.\n         */\n        this.renderSprites = false;\n        /**\n         * Force checking the layerMask property even if a custom list of meshes is provided (ie. if renderList is not undefined)\n         */\n        this.forceLayerMaskCheck = false;\n        /**\n         * Define if the camera viewport should be respected while rendering the texture or if the render should be done to the entire texture.\n         */\n        this.ignoreCameraViewport = false;\n        /**\n         * An event triggered when the texture is unbind.\n         */\n        this.onBeforeBindObservable = new Observable();\n        /**\n         * An event triggered when the texture is unbind.\n         */\n        this.onAfterUnbindObservable = new Observable();\n        /**\n         * An event triggered before rendering the texture\n         */\n        this.onBeforeRenderObservable = new Observable();\n        /**\n         * An event triggered after rendering the texture\n         */\n        this.onAfterRenderObservable = new Observable();\n        /**\n         * An event triggered after the texture clear\n         */\n        this.onClearObservable = new Observable();\n        /**\n         * An event triggered when the texture is resized.\n         */\n        this.onResizeObservable = new Observable();\n        /** @internal */\n        this._cleared = false;\n        /**\n         * Skip the initial clear of the rtt at the beginning of the frame render loop\n         */\n        this.skipInitialClear = false;\n        this._currentRefreshId = -1;\n        this._refreshRate = 1;\n        this._samples = 1;\n        this._canRescale = true;\n        this._renderTarget = null;\n        /**\n         * Gets or sets the center of the bounding box associated with the texture (when in cube mode)\n         * It must define where the camera used to render the texture is set\n         */\n        this.boundingBoxPosition = Vector3.Zero();\n        scene = this.getScene();\n        if (!scene) {\n            return;\n        }\n        const engine = this.getScene().getEngine();\n        this._coordinatesMode = Texture.PROJECTION_MODE;\n        this.renderList = new Array();\n        this.name = name;\n        this.isRenderTarget = true;\n        this._initialSizeParameter = size;\n        this._renderPassIds = [];\n        this._isCubeData = isCube;\n        this._processSizeParameter(size);\n        this.renderPassId = this._renderPassIds[0];\n        this._resizeObserver = engine.onResizeObservable.add(() => { });\n        this._generateMipMaps = generateMipMaps ? true : false;\n        this._doNotChangeAspectRatio = doNotChangeAspectRatio;\n        // Rendering groups\n        this._renderingManager = new RenderingManager(scene);\n        this._renderingManager._useSceneAutoClearSetup = true;\n        if (isMulti) {\n            return;\n        }\n        this._renderTargetOptions = {\n            generateMipMaps: generateMipMaps,\n            type: type,\n            format: (_f = this._format) !== null && _f !== void 0 ? _f : undefined,\n            samplingMode: this.samplingMode,\n            generateDepthBuffer: generateDepthBuffer,\n            generateStencilBuffer: generateStencilBuffer,\n            samples,\n            creationFlags,\n            noColorAttachment: noColorAttachment,\n            useSRGBBuffer,\n            colorAttachment: colorAttachment,\n            label: this.name,\n        };\n        if (this.samplingMode === Texture.NEAREST_SAMPLINGMODE) {\n            this.wrapU = Texture.CLAMP_ADDRESSMODE;\n            this.wrapV = Texture.CLAMP_ADDRESSMODE;\n        }\n        if (!delayAllocation) {\n            if (isCube) {\n                this._renderTarget = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);\n                this.coordinatesMode = Texture.INVCUBIC_MODE;\n                this._textureMatrix = Matrix.Identity();\n            }\n            else {\n                this._renderTarget = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);\n            }\n            this._texture = this._renderTarget.texture;\n            if (samples !== undefined) {\n                this.samples = samples;\n            }\n        }\n    }\n    /**\n     * Creates a depth stencil texture.\n     * This is only available in WebGL 2 or with the depth texture extension available.\n     * @param comparisonFunction Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode (default: 0)\n     * @param bilinearFiltering Specifies whether or not bilinear filtering is enable on the texture (default: true)\n     * @param generateStencil Specifies whether or not a stencil should be allocated in the texture (default: false)\n     * @param samples sample count of the depth/stencil texture (default: 1)\n     * @param format format of the depth texture (default: 14)\n     */\n    createDepthStencilTexture(comparisonFunction = 0, bilinearFiltering = true, generateStencil = false, samples = 1, format = 14) {\n        var _a;\n        (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.createDepthStencilTexture(comparisonFunction, bilinearFiltering, generateStencil, samples, format);\n    }\n    _releaseRenderPassId() {\n        if (this._scene) {\n            const engine = this._scene.getEngine();\n            for (let i = 0; i < this._renderPassIds.length; ++i) {\n                engine.releaseRenderPassId(this._renderPassIds[i]);\n            }\n        }\n        this._renderPassIds = [];\n    }\n    _createRenderPassId() {\n        this._releaseRenderPassId();\n        const engine = this._scene.getEngine(); // scene can't be null in a RenderTargetTexture, see constructor\n        const numPasses = this._isCubeData ? 6 : this.getRenderLayers() || 1;\n        for (let i = 0; i < numPasses; ++i) {\n            this._renderPassIds[i] = engine.createRenderPassId(`RenderTargetTexture - ${this.name}#${i}`);\n        }\n    }\n    _processSizeParameter(size) {\n        if (size.ratio) {\n            this._sizeRatio = size.ratio;\n            const engine = this._getEngine();\n            this._size = {\n                width: this._bestReflectionRenderTargetDimension(engine.getRenderWidth(), this._sizeRatio),\n                height: this._bestReflectionRenderTargetDimension(engine.getRenderHeight(), this._sizeRatio),\n            };\n        }\n        else {\n            this._size = size;\n        }\n        this._createRenderPassId();\n    }\n    /**\n     * Define the number of samples to use in case of MSAA.\n     * It defaults to one meaning no MSAA has been enabled.\n     */\n    get samples() {\n        var _a, _b;\n        return (_b = (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.samples) !== null && _b !== void 0 ? _b : this._samples;\n    }\n    set samples(value) {\n        if (this._renderTarget) {\n            this._samples = this._renderTarget.setSamples(value);\n        }\n    }\n    /**\n     * Resets the refresh counter of the texture and start bak from scratch.\n     * Could be useful to regenerate the texture if it is setup to render only once.\n     */\n    resetRefreshCounter() {\n        this._currentRefreshId = -1;\n    }\n    /**\n     * Define the refresh rate of the texture or the rendering frequency.\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\n     */\n    get refreshRate() {\n        return this._refreshRate;\n    }\n    set refreshRate(value) {\n        this._refreshRate = value;\n        this.resetRefreshCounter();\n    }\n    /**\n     * Adds a post process to the render target rendering passes.\n     * @param postProcess define the post process to add\n     */\n    addPostProcess(postProcess) {\n        if (!this._postProcessManager) {\n            const scene = this.getScene();\n            if (!scene) {\n                return;\n            }\n            this._postProcessManager = new PostProcessManager(scene);\n            this._postProcesses = new Array();\n        }\n        this._postProcesses.push(postProcess);\n        this._postProcesses[0].autoClear = false;\n    }\n    /**\n     * Clear all the post processes attached to the render target\n     * @param dispose define if the cleared post processes should also be disposed (false by default)\n     */\n    clearPostProcesses(dispose = false) {\n        if (!this._postProcesses) {\n            return;\n        }\n        if (dispose) {\n            for (const postProcess of this._postProcesses) {\n                postProcess.dispose();\n            }\n        }\n        this._postProcesses = [];\n    }\n    /**\n     * Remove one of the post process from the list of attached post processes to the texture\n     * @param postProcess define the post process to remove from the list\n     */\n    removePostProcess(postProcess) {\n        if (!this._postProcesses) {\n            return;\n        }\n        const index = this._postProcesses.indexOf(postProcess);\n        if (index === -1) {\n            return;\n        }\n        this._postProcesses.splice(index, 1);\n        if (this._postProcesses.length > 0) {\n            this._postProcesses[0].autoClear = false;\n        }\n    }\n    /** @internal */\n    _shouldRender() {\n        if (this._currentRefreshId === -1) {\n            // At least render once\n            this._currentRefreshId = 1;\n            return true;\n        }\n        if (this.refreshRate === this._currentRefreshId) {\n            this._currentRefreshId = 1;\n            return true;\n        }\n        this._currentRefreshId++;\n        return false;\n    }\n    /**\n     * Gets the actual render size of the texture.\n     * @returns the width of the render size\n     */\n    getRenderSize() {\n        return this.getRenderWidth();\n    }\n    /**\n     * Gets the actual render width of the texture.\n     * @returns the width of the render size\n     */\n    getRenderWidth() {\n        if (this._size.width) {\n            return this._size.width;\n        }\n        return this._size;\n    }\n    /**\n     * Gets the actual render height of the texture.\n     * @returns the height of the render size\n     */\n    getRenderHeight() {\n        if (this._size.width) {\n            return this._size.height;\n        }\n        return this._size;\n    }\n    /**\n     * Gets the actual number of layers of the texture.\n     * @returns the number of layers\n     */\n    getRenderLayers() {\n        const layers = this._size.layers;\n        if (layers) {\n            return layers;\n        }\n        return 0;\n    }\n    /**\n     * Don't allow this render target texture to rescale. Mainly used to prevent rescaling by the scene optimizer.\n     */\n    disableRescaling() {\n        this._canRescale = false;\n    }\n    /**\n     * Get if the texture can be rescaled or not.\n     */\n    get canRescale() {\n        return this._canRescale;\n    }\n    /**\n     * Resize the texture using a ratio.\n     * @param ratio the ratio to apply to the texture size in order to compute the new target size\n     */\n    scale(ratio) {\n        const newSize = Math.max(1, this.getRenderSize() * ratio);\n        this.resize(newSize);\n    }\n    /**\n     * Get the texture reflection matrix used to rotate/transform the reflection.\n     * @returns the reflection matrix\n     */\n    getReflectionTextureMatrix() {\n        if (this.isCube) {\n            return this._textureMatrix;\n        }\n        return super.getReflectionTextureMatrix();\n    }\n    /**\n     * Resize the texture to a new desired size.\n     * Be careful as it will recreate all the data in the new texture.\n     * @param size Define the new size. It can be:\n     *   - a number for squared texture,\n     *   - an object containing { width: number, height: number }\n     *   - or an object containing a ratio { ratio: number }\n     */\n    resize(size) {\n        var _a;\n        const wasCube = this.isCube;\n        (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._renderTarget = null;\n        const scene = this.getScene();\n        if (!scene) {\n            return;\n        }\n        this._processSizeParameter(size);\n        if (wasCube) {\n            this._renderTarget = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);\n        }\n        else {\n            this._renderTarget = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);\n        }\n        this._texture = this._renderTarget.texture;\n        if (this._renderTargetOptions.samples !== undefined) {\n            this.samples = this._renderTargetOptions.samples;\n        }\n        if (this.onResizeObservable.hasObservers()) {\n            this.onResizeObservable.notifyObservers(this);\n        }\n    }\n    /**\n     * Renders all the objects from the render list into the texture.\n     * @param useCameraPostProcess Define if camera post processes should be used during the rendering\n     * @param dumpForDebug Define if the rendering result should be dumped (copied) for debugging purpose\n     */\n    render(useCameraPostProcess = false, dumpForDebug = false) {\n        this._render(useCameraPostProcess, dumpForDebug);\n    }\n    /**\n     * This function will check if the render target texture can be rendered (textures are loaded, shaders are compiled)\n     * @returns true if all required resources are ready\n     */\n    isReadyForRendering() {\n        return this._render(false, false, true);\n    }\n    _render(useCameraPostProcess = false, dumpForDebug = false, checkReadiness = false) {\n        var _a;\n        const scene = this.getScene();\n        if (!scene) {\n            return checkReadiness;\n        }\n        const engine = scene.getEngine();\n        if (this.useCameraPostProcesses !== undefined) {\n            useCameraPostProcess = this.useCameraPostProcesses;\n        }\n        if (this._waitingRenderList) {\n            this.renderList = [];\n            for (let index = 0; index < this._waitingRenderList.length; index++) {\n                const id = this._waitingRenderList[index];\n                const mesh = scene.getMeshById(id);\n                if (mesh) {\n                    this.renderList.push(mesh);\n                }\n            }\n            this._waitingRenderList = undefined;\n        }\n        // Is predicate defined?\n        if (this.renderListPredicate) {\n            if (this.renderList) {\n                this.renderList.length = 0; // Clear previous renderList\n            }\n            else {\n                this.renderList = [];\n            }\n            const scene = this.getScene();\n            if (!scene) {\n                return checkReadiness;\n            }\n            const sceneMeshes = scene.meshes;\n            for (let index = 0; index < sceneMeshes.length; index++) {\n                const mesh = sceneMeshes[index];\n                if (this.renderListPredicate(mesh)) {\n                    this.renderList.push(mesh);\n                }\n            }\n        }\n        const currentRenderPassId = engine.currentRenderPassId;\n        this.onBeforeBindObservable.notifyObservers(this);\n        // Set custom projection.\n        // Needs to be before binding to prevent changing the aspect ratio.\n        const camera = (_a = this.activeCamera) !== null && _a !== void 0 ? _a : scene.activeCamera;\n        const sceneCamera = scene.activeCamera;\n        if (camera) {\n            if (camera !== scene.activeCamera) {\n                scene.setTransformMatrix(camera.getViewMatrix(), camera.getProjectionMatrix(true));\n                scene.activeCamera = camera;\n            }\n            engine.setViewport(camera.viewport, this.getRenderWidth(), this.getRenderHeight());\n        }\n        this._defaultRenderListPrepared = false;\n        let returnValue = checkReadiness;\n        if (!checkReadiness) {\n            if (this.is2DArray && !this.isMulti) {\n                for (let layer = 0; layer < this.getRenderLayers(); layer++) {\n                    this._renderToTarget(0, useCameraPostProcess, dumpForDebug, layer, camera);\n                    scene.incrementRenderId();\n                    scene.resetCachedMaterial();\n                }\n            }\n            else if (this.isCube && !this.isMulti) {\n                for (let face = 0; face < 6; face++) {\n                    this._renderToTarget(face, useCameraPostProcess, dumpForDebug, undefined, camera);\n                    scene.incrementRenderId();\n                    scene.resetCachedMaterial();\n                }\n            }\n            else {\n                this._renderToTarget(0, useCameraPostProcess, dumpForDebug, undefined, camera);\n            }\n        }\n        else {\n            if (!scene.getViewMatrix()) {\n                // We probably didn't execute scene.render() yet, so make sure we have a view/projection matrix setup for the scene\n                scene.updateTransformMatrix();\n            }\n            const numLayers = this.is2DArray ? this.getRenderLayers() : this.isCube ? 6 : 1;\n            for (let layer = 0; layer < numLayers && returnValue; layer++) {\n                let currentRenderList = null;\n                const defaultRenderList = this.renderList ? this.renderList : scene.getActiveMeshes().data;\n                const defaultRenderListLength = this.renderList ? this.renderList.length : scene.getActiveMeshes().length;\n                engine.currentRenderPassId = this._renderPassIds[layer];\n                this.onBeforeRenderObservable.notifyObservers(layer);\n                if (this.getCustomRenderList) {\n                    currentRenderList = this.getCustomRenderList(layer, defaultRenderList, defaultRenderListLength);\n                }\n                if (!currentRenderList) {\n                    currentRenderList = defaultRenderList;\n                }\n                if (!this._doNotChangeAspectRatio) {\n                    scene.updateTransformMatrix(true);\n                }\n                for (let i = 0; i < currentRenderList.length && returnValue; ++i) {\n                    const mesh = currentRenderList[i];\n                    if (!mesh.isEnabled() || mesh.isBlocked || !mesh.isVisible || !mesh.subMeshes) {\n                        continue;\n                    }\n                    if (this.customIsReadyFunction) {\n                        if (!this.customIsReadyFunction(mesh, this.refreshRate, checkReadiness)) {\n                            returnValue = false;\n                            continue;\n                        }\n                    }\n                    else if (!mesh.isReady(true)) {\n                        returnValue = false;\n                        continue;\n                    }\n                }\n                this.onAfterRenderObservable.notifyObservers(layer);\n                if (this.is2DArray || this.isCube) {\n                    scene.incrementRenderId();\n                    scene.resetCachedMaterial();\n                }\n            }\n        }\n        this.onAfterUnbindObservable.notifyObservers(this);\n        engine.currentRenderPassId = currentRenderPassId;\n        if (sceneCamera) {\n            scene.activeCamera = sceneCamera;\n            // Do not avoid setting uniforms when multiple scenes are active as another camera may have overwrite these\n            if (scene.getEngine().scenes.length > 1 || (this.activeCamera && this.activeCamera !== scene.activeCamera)) {\n                scene.setTransformMatrix(scene.activeCamera.getViewMatrix(), scene.activeCamera.getProjectionMatrix(true));\n            }\n            engine.setViewport(scene.activeCamera.viewport);\n        }\n        scene.resetCachedMaterial();\n        return returnValue;\n    }\n    _bestReflectionRenderTargetDimension(renderDimension, scale) {\n        const minimum = 128;\n        const x = renderDimension * scale;\n        const curved = Engine.NearestPOT(x + (minimum * minimum) / (minimum + x));\n        // Ensure we don't exceed the render dimension (while staying POT)\n        return Math.min(Engine.FloorPOT(renderDimension), curved);\n    }\n    _prepareRenderingManager(currentRenderList, currentRenderListLength, camera, checkLayerMask) {\n        const scene = this.getScene();\n        if (!scene) {\n            return;\n        }\n        this._renderingManager.reset();\n        const sceneRenderId = scene.getRenderId();\n        for (let meshIndex = 0; meshIndex < currentRenderListLength; meshIndex++) {\n            const mesh = currentRenderList[meshIndex];\n            if (mesh && !mesh.isBlocked) {\n                if (this.customIsReadyFunction) {\n                    if (!this.customIsReadyFunction(mesh, this.refreshRate, false)) {\n                        this.resetRefreshCounter();\n                        continue;\n                    }\n                }\n                else if (!mesh.isReady(this.refreshRate === 0)) {\n                    this.resetRefreshCounter();\n                    continue;\n                }\n                if (!mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate && scene.activeCamera) {\n                    mesh._internalAbstractMeshDataInfo._currentLOD = scene.customLODSelector\n                        ? scene.customLODSelector(mesh, this.activeCamera || scene.activeCamera)\n                        : mesh.getLOD(this.activeCamera || scene.activeCamera);\n                    mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;\n                }\n                if (!mesh._internalAbstractMeshDataInfo._currentLOD) {\n                    continue;\n                }\n                let meshToRender = mesh._internalAbstractMeshDataInfo._currentLOD;\n                meshToRender._preActivateForIntermediateRendering(sceneRenderId);\n                let isMasked;\n                if (checkLayerMask && camera) {\n                    isMasked = (mesh.layerMask & camera.layerMask) === 0;\n                }\n                else {\n                    isMasked = false;\n                }\n                if (mesh.isEnabled() && mesh.isVisible && mesh.subMeshes && !isMasked) {\n                    if (meshToRender !== mesh) {\n                        meshToRender._activate(sceneRenderId, true);\n                    }\n                    if (mesh._activate(sceneRenderId, true) && mesh.subMeshes.length) {\n                        if (!mesh.isAnInstance) {\n                            meshToRender._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = false;\n                        }\n                        else {\n                            if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {\n                                meshToRender = mesh;\n                            }\n                        }\n                        meshToRender._internalAbstractMeshDataInfo._isActiveIntermediate = true;\n                        for (let subIndex = 0; subIndex < meshToRender.subMeshes.length; subIndex++) {\n                            const subMesh = meshToRender.subMeshes[subIndex];\n                            this._renderingManager.dispatch(subMesh, meshToRender);\n                        }\n                    }\n                }\n            }\n        }\n        for (let particleIndex = 0; particleIndex < scene.particleSystems.length; particleIndex++) {\n            const particleSystem = scene.particleSystems[particleIndex];\n            const emitter = particleSystem.emitter;\n            if (!particleSystem.isStarted() || !emitter || (emitter.position && !emitter.isEnabled())) {\n                continue;\n            }\n            this._renderingManager.dispatchParticles(particleSystem);\n        }\n    }\n    /**\n     * @internal\n     * @param faceIndex face index to bind to if this is a cubetexture\n     * @param layer defines the index of the texture to bind in the array\n     */\n    _bindFrameBuffer(faceIndex = 0, layer = 0) {\n        const scene = this.getScene();\n        if (!scene) {\n            return;\n        }\n        const engine = scene.getEngine();\n        if (this._renderTarget) {\n            engine.bindFramebuffer(this._renderTarget, this.isCube ? faceIndex : undefined, undefined, undefined, this.ignoreCameraViewport, 0, layer);\n        }\n    }\n    _unbindFrameBuffer(engine, faceIndex) {\n        if (!this._renderTarget) {\n            return;\n        }\n        engine.unBindFramebuffer(this._renderTarget, this.isCube, () => {\n            this.onAfterRenderObservable.notifyObservers(faceIndex);\n        });\n    }\n    /**\n     * @internal\n     */\n    _prepareFrame(scene, faceIndex, layer, useCameraPostProcess) {\n        if (this._postProcessManager) {\n            if (!this._prePassEnabled) {\n                this._postProcessManager._prepareFrame(this._texture, this._postProcesses);\n            }\n        }\n        else if (!useCameraPostProcess || !scene.postProcessManager._prepareFrame(this._texture)) {\n            this._bindFrameBuffer(faceIndex, layer);\n        }\n    }\n    _renderToTarget(faceIndex, useCameraPostProcess, dumpForDebug, layer = 0, camera = null) {\n        var _a, _b, _c, _d, _e, _f;\n        const scene = this.getScene();\n        if (!scene) {\n            return;\n        }\n        const engine = scene.getEngine();\n        (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, `render to face #${faceIndex} layer #${layer}`, 1);\n        // Bind\n        this._prepareFrame(scene, faceIndex, layer, useCameraPostProcess);\n        if (this.is2DArray) {\n            engine.currentRenderPassId = this._renderPassIds[layer];\n            this.onBeforeRenderObservable.notifyObservers(layer);\n        }\n        else {\n            engine.currentRenderPassId = this._renderPassIds[faceIndex];\n            this.onBeforeRenderObservable.notifyObservers(faceIndex);\n        }\n        const fastPath = engine.snapshotRendering && engine.snapshotRenderingMode === 1;\n        if (!fastPath) {\n            // Get the list of meshes to render\n            let currentRenderList = null;\n            const defaultRenderList = this.renderList ? this.renderList : scene.getActiveMeshes().data;\n            const defaultRenderListLength = this.renderList ? this.renderList.length : scene.getActiveMeshes().length;\n            if (this.getCustomRenderList) {\n                currentRenderList = this.getCustomRenderList(this.is2DArray ? layer : faceIndex, defaultRenderList, defaultRenderListLength);\n            }\n            if (!currentRenderList) {\n                // No custom render list provided, we prepare the rendering for the default list, but check\n                // first if we did not already performed the preparation before so as to avoid re-doing it several times\n                if (!this._defaultRenderListPrepared) {\n                    this._prepareRenderingManager(defaultRenderList, defaultRenderListLength, camera, !this.renderList || this.forceLayerMaskCheck);\n                    this._defaultRenderListPrepared = true;\n                }\n                currentRenderList = defaultRenderList;\n            }\n            else {\n                // Prepare the rendering for the custom render list provided\n                this._prepareRenderingManager(currentRenderList, currentRenderList.length, camera, this.forceLayerMaskCheck);\n            }\n            // Before clear\n            for (const step of scene._beforeRenderTargetClearStage) {\n                step.action(this, faceIndex, layer);\n            }\n            // Clear\n            if (this.onClearObservable.hasObservers()) {\n                this.onClearObservable.notifyObservers(engine);\n            }\n            else {\n                if (!this.skipInitialClear) {\n                    engine.clear(this.clearColor || scene.clearColor, true, true, true);\n                }\n            }\n            if (!this._doNotChangeAspectRatio) {\n                scene.updateTransformMatrix(true);\n            }\n            // Before Camera Draw\n            for (const step of scene._beforeRenderTargetDrawStage) {\n                step.action(this, faceIndex, layer);\n            }\n            // Render\n            this._renderingManager.render(this.customRenderFunction, currentRenderList, this.renderParticles, this.renderSprites);\n            // After Camera Draw\n            for (const step of scene._afterRenderTargetDrawStage) {\n                step.action(this, faceIndex, layer);\n            }\n            const saveGenerateMipMaps = (_c = (_b = this._texture) === null || _b === void 0 ? void 0 : _b.generateMipMaps) !== null && _c !== void 0 ? _c : false;\n            if (this._texture) {\n                this._texture.generateMipMaps = false; // if left true, the mipmaps will be generated (if this._texture.generateMipMaps = true) when the first post process binds its own RTT: by doing so it will unbind the current RTT,\n                // which will trigger a mipmap generation. We don't want this because it's a wasted work, we will do an unbind of the current RTT at the end of the process (see unbindFrameBuffer) which will\n                // trigger the generation of the final mipmaps\n            }\n            if (this._postProcessManager) {\n                this._postProcessManager._finalizeFrame(false, (_d = this._renderTarget) !== null && _d !== void 0 ? _d : undefined, faceIndex, this._postProcesses, this.ignoreCameraViewport);\n            }\n            else if (useCameraPostProcess) {\n                scene.postProcessManager._finalizeFrame(false, (_e = this._renderTarget) !== null && _e !== void 0 ? _e : undefined, faceIndex);\n            }\n            for (const step of scene._afterRenderTargetPostProcessStage) {\n                step.action(this, faceIndex, layer);\n            }\n            if (this._texture) {\n                this._texture.generateMipMaps = saveGenerateMipMaps;\n            }\n            if (!this._doNotChangeAspectRatio) {\n                scene.updateTransformMatrix(true);\n            }\n            // Dump ?\n            if (dumpForDebug) {\n                DumpTools.DumpFramebuffer(this.getRenderWidth(), this.getRenderHeight(), engine);\n            }\n        }\n        else {\n            // Clear\n            if (this.onClearObservable.hasObservers()) {\n                this.onClearObservable.notifyObservers(engine);\n            }\n            else {\n                if (!this.skipInitialClear) {\n                    engine.clear(this.clearColor || scene.clearColor, true, true, true);\n                }\n            }\n        }\n        // Unbind\n        this._unbindFrameBuffer(engine, faceIndex);\n        if (this._texture && this.isCube && faceIndex === 5) {\n            engine.generateMipMapsForCubemap(this._texture);\n        }\n        (_f = engine._debugPopGroup) === null || _f === void 0 ? void 0 : _f.call(engine, 1);\n    }\n    /**\n     * Overrides the default sort function applied in the rendering group to prepare the meshes.\n     * This allowed control for front to back rendering or reversely depending of the special needs.\n     *\n     * @param renderingGroupId The rendering group id corresponding to its index\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\n     */\n    setRenderingOrder(renderingGroupId, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {\n        this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);\n    }\n    /**\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\n     *\n     * @param renderingGroupId The rendering group id corresponding to its index\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n     */\n    setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil) {\n        this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);\n        this._renderingManager._useSceneAutoClearSetup = false;\n    }\n    /**\n     * Clones the texture.\n     * @returns the cloned texture\n     */\n    clone() {\n        const textureSize = this.getSize();\n        const newTexture = new RenderTargetTexture(this.name, textureSize, this.getScene(), this._renderTargetOptions.generateMipMaps, this._doNotChangeAspectRatio, this._renderTargetOptions.type, this.isCube, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer, this._renderTargetOptions.generateStencilBuffer, undefined, this._renderTargetOptions.format, undefined, this._renderTargetOptions.samples);\n        // Base texture\n        newTexture.hasAlpha = this.hasAlpha;\n        newTexture.level = this.level;\n        // RenderTarget Texture\n        newTexture.coordinatesMode = this.coordinatesMode;\n        if (this.renderList) {\n            newTexture.renderList = this.renderList.slice(0);\n        }\n        return newTexture;\n    }\n    /**\n     * Serialize the texture to a JSON representation we can easily use in the respective Parse function.\n     * @returns The JSON representation of the texture\n     */\n    serialize() {\n        if (!this.name) {\n            return null;\n        }\n        const serializationObject = super.serialize();\n        serializationObject.renderTargetSize = this.getRenderSize();\n        serializationObject.renderList = [];\n        if (this.renderList) {\n            for (let index = 0; index < this.renderList.length; index++) {\n                serializationObject.renderList.push(this.renderList[index].id);\n            }\n        }\n        return serializationObject;\n    }\n    /**\n     *  This will remove the attached framebuffer objects. The texture will not be able to be used as render target anymore\n     */\n    disposeFramebufferObjects() {\n        var _a;\n        (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.dispose(true);\n    }\n    /**\n     * Release and destroy the underlying lower level texture aka internalTexture.\n     */\n    releaseInternalTexture() {\n        var _a;\n        (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.releaseTextures();\n        this._texture = null;\n    }\n    /**\n     * Dispose the texture and release its associated resources.\n     */\n    dispose() {\n        var _a;\n        this.onResizeObservable.clear();\n        this.onClearObservable.clear();\n        this.onAfterRenderObservable.clear();\n        this.onAfterUnbindObservable.clear();\n        this.onBeforeBindObservable.clear();\n        this.onBeforeRenderObservable.clear();\n        if (this._postProcessManager) {\n            this._postProcessManager.dispose();\n            this._postProcessManager = null;\n        }\n        if (this._prePassRenderTarget) {\n            this._prePassRenderTarget.dispose();\n        }\n        this._releaseRenderPassId();\n        this.clearPostProcesses(true);\n        if (this._resizeObserver) {\n            this.getScene().getEngine().onResizeObservable.remove(this._resizeObserver);\n            this._resizeObserver = null;\n        }\n        this.renderList = null;\n        // Remove from custom render targets\n        const scene = this.getScene();\n        if (!scene) {\n            return;\n        }\n        let index = scene.customRenderTargets.indexOf(this);\n        if (index >= 0) {\n            scene.customRenderTargets.splice(index, 1);\n        }\n        for (const camera of scene.cameras) {\n            index = camera.customRenderTargets.indexOf(this);\n            if (index >= 0) {\n                camera.customRenderTargets.splice(index, 1);\n            }\n        }\n        (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._renderTarget = null;\n        this._texture = null;\n        super.dispose();\n    }\n    /** @internal */\n    _rebuild() {\n        if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\n            this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\n        }\n        if (this._postProcessManager) {\n            this._postProcessManager._rebuild();\n        }\n    }\n    /**\n     * Clear the info related to rendering groups preventing retention point in material dispose.\n     */\n    freeRenderingGroups() {\n        if (this._renderingManager) {\n            this._renderingManager.freeRenderingGroups();\n        }\n    }\n    /**\n     * Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)\n     * @returns the view count\n     */\n    getViewCount() {\n        return 1;\n    }\n}\n/**\n * The texture will only be rendered once which can be useful to improve performance if everything in your render is static for instance.\n */\nRenderTargetTexture.REFRESHRATE_RENDER_ONCE = 0;\n/**\n * The texture will only be rendered rendered every frame and is recommended for dynamic contents.\n */\nRenderTargetTexture.REFRESHRATE_RENDER_ONEVERYFRAME = 1;\n/**\n * The texture will be rendered every 2 frames which could be enough if your dynamic objects are not\n * the central point of your effect and can save a lot of performances.\n */\nRenderTargetTexture.REFRESHRATE_RENDER_ONEVERYTWOFRAMES = 2;\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nTexture._CreateRenderTargetTexture = (name, renderTargetSize, scene, generateMipMaps, creationFlags) => {\n    return new RenderTargetTexture(name, renderTargetSize, scene, generateMipMaps);\n};\n//# sourceMappingURL=renderTargetTexture.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { SmartArray } from \"../Misc/smartArray.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector2 } from \"../Maths/math.vector.js\";\n\nimport \"../Shaders/postprocess.vertex.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport \"../Engines/Extensions/engine.renderTarget.js\";\nimport { serialize, serializeAsColor4, SerializationHelper } from \"../Misc/decorators.js\";\nimport { GetClass, RegisterClass } from \"../Misc/typeStore.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { ShaderLanguage } from \"../Materials/shaderLanguage.js\";\n/**\n * PostProcess can be used to apply a shader to a texture after it has been rendered\n * See https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses\n */\nexport class PostProcess {\n    /**\n     * Registers a shader code processing with a post process name.\n     * @param postProcessName name of the post process. Use null for the fallback shader code processing. This is the shader code processing that will be used in case no specific shader code processing has been associated to a post process name\n     * @param customShaderCodeProcessing shader code processing to associate to the post process name\n     * @returns\n     */\n    static RegisterShaderCodeProcessing(postProcessName, customShaderCodeProcessing) {\n        if (!customShaderCodeProcessing) {\n            delete PostProcess._CustomShaderCodeProcessing[postProcessName !== null && postProcessName !== void 0 ? postProcessName : \"\"];\n            return;\n        }\n        PostProcess._CustomShaderCodeProcessing[postProcessName !== null && postProcessName !== void 0 ? postProcessName : \"\"] = customShaderCodeProcessing;\n    }\n    static _GetShaderCodeProcessing(postProcessName) {\n        var _a;\n        return (_a = PostProcess._CustomShaderCodeProcessing[postProcessName]) !== null && _a !== void 0 ? _a : PostProcess._CustomShaderCodeProcessing[\"\"];\n    }\n    /**\n     * Number of sample textures (default: 1)\n     */\n    get samples() {\n        return this._samples;\n    }\n    set samples(n) {\n        this._samples = Math.min(n, this._engine.getCaps().maxMSAASamples);\n        this._textures.forEach((texture) => {\n            texture.setSamples(this._samples);\n        });\n    }\n    /**\n     * Returns the fragment url or shader name used in the post process.\n     * @returns the fragment url or name in the shader store.\n     */\n    getEffectName() {\n        return this._fragmentUrl;\n    }\n    /**\n     * A function that is added to the onActivateObservable\n     */\n    set onActivate(callback) {\n        if (this._onActivateObserver) {\n            this.onActivateObservable.remove(this._onActivateObserver);\n        }\n        if (callback) {\n            this._onActivateObserver = this.onActivateObservable.add(callback);\n        }\n    }\n    /**\n     * A function that is added to the onSizeChangedObservable\n     */\n    set onSizeChanged(callback) {\n        if (this._onSizeChangedObserver) {\n            this.onSizeChangedObservable.remove(this._onSizeChangedObserver);\n        }\n        this._onSizeChangedObserver = this.onSizeChangedObservable.add(callback);\n    }\n    /**\n     * A function that is added to the onApplyObservable\n     */\n    set onApply(callback) {\n        if (this._onApplyObserver) {\n            this.onApplyObservable.remove(this._onApplyObserver);\n        }\n        this._onApplyObserver = this.onApplyObservable.add(callback);\n    }\n    /**\n     * A function that is added to the onBeforeRenderObservable\n     */\n    set onBeforeRender(callback) {\n        if (this._onBeforeRenderObserver) {\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n        }\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n    }\n    /**\n     * A function that is added to the onAfterRenderObservable\n     */\n    set onAfterRender(callback) {\n        if (this._onAfterRenderObserver) {\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n        }\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n    }\n    /**\n     * The input texture for this post process and the output texture of the previous post process. When added to a pipeline the previous post process will\n     * render it's output into this texture and this texture will be used as textureSampler in the fragment shader of this post process.\n     */\n    get inputTexture() {\n        return this._textures.data[this._currentRenderTextureInd];\n    }\n    set inputTexture(value) {\n        this._forcedOutputTexture = value;\n    }\n    /**\n     * Since inputTexture should always be defined, if we previously manually set `inputTexture`,\n     * the only way to unset it is to use this function to restore its internal state\n     */\n    restoreDefaultInputTexture() {\n        if (this._forcedOutputTexture) {\n            this._forcedOutputTexture = null;\n            this.markTextureDirty();\n        }\n    }\n    /**\n     * Gets the camera which post process is applied to.\n     * @returns The camera the post process is applied to.\n     */\n    getCamera() {\n        return this._camera;\n    }\n    /**\n     * Gets the texel size of the postprocess.\n     * See https://en.wikipedia.org/wiki/Texel_(graphics)\n     */\n    get texelSize() {\n        if (this._shareOutputWithPostProcess) {\n            return this._shareOutputWithPostProcess.texelSize;\n        }\n        if (this._forcedOutputTexture) {\n            this._texelSize.copyFromFloats(1.0 / this._forcedOutputTexture.width, 1.0 / this._forcedOutputTexture.height);\n        }\n        return this._texelSize;\n    }\n    /**\n     * Creates a new instance PostProcess\n     * @param name The name of the PostProcess.\n     * @param fragmentUrl The url of the fragment shader to be used.\n     * @param parameters Array of the names of uniform non-sampler2D variables that will be passed to the shader.\n     * @param samplers Array of the names of uniform sampler2D variables that will be passed to the shader.\n     * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\n     * @param camera The camera to apply the render pass to.\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n     * @param engine The engine which the post process will be applied. (default: current engine)\n     * @param reusable If the post process can be reused on the same frame. (default: false)\n     * @param defines String of defines that will be set when running the fragment shader. (default: null)\n     * @param textureType Type of textures used when performing the post process. (default: 0)\n     * @param vertexUrl The url of the vertex shader to be used. (default: \"postprocess\")\n     * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\n     * @param blockCompilation If the shader should not be compiled immediatly. (default: false)\n     * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\n     */\n    constructor(name, fragmentUrl, parameters, samplers, options, camera, samplingMode = 1, engine, reusable, defines = null, textureType = 0, vertexUrl = \"postprocess\", indexParameters, blockCompilation = false, textureFormat = 5, shaderLanguage = ShaderLanguage.GLSL) {\n        /** @internal */\n        this._parentContainer = null;\n        /**\n         * Width of the texture to apply the post process on\n         */\n        this.width = -1;\n        /**\n         * Height of the texture to apply the post process on\n         */\n        this.height = -1;\n        /**\n         * Gets the node material used to create this postprocess (null if the postprocess was manually created)\n         */\n        this.nodeMaterialSource = null;\n        /**\n         * Internal, reference to the location where this postprocess was output to. (Typically the texture on the next postprocess in the chain)\n         * @internal\n         */\n        this._outputTexture = null;\n        /**\n         * If the buffer needs to be cleared before applying the post process. (default: true)\n         * Should be set to false if shader will overwrite all previous pixels.\n         */\n        this.autoClear = true;\n        /**\n         * If clearing the buffer should be forced in autoClear mode, even when alpha mode is enabled (default: false).\n         * By default, the buffer will only be cleared if alpha mode is disabled (and autoClear is true).\n         */\n        this.forceAutoClearInAlphaMode = false;\n        /**\n         * Type of alpha mode to use when performing the post process (default: Engine.ALPHA_DISABLE)\n         */\n        this.alphaMode = 0;\n        /**\n         * Animations to be used for the post processing\n         */\n        this.animations = new Array();\n        /**\n         * Enable Pixel Perfect mode where texture is not scaled to be power of 2.\n         * Can only be used on a single postprocess or on the last one of a chain. (default: false)\n         */\n        this.enablePixelPerfectMode = false;\n        /**\n         * Force the postprocess to be applied without taking in account viewport\n         */\n        this.forceFullscreenViewport = true;\n        /**\n         * Scale mode for the post process (default: Engine.SCALEMODE_FLOOR)\n         *\n         * | Value | Type                                | Description |\n         * | ----- | ----------------------------------- | ----------- |\n         * | 1     | SCALEMODE_FLOOR                     | [engine.scalemode_floor](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_floor) |\n         * | 2     | SCALEMODE_NEAREST                   | [engine.scalemode_nearest](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_nearest) |\n         * | 3     | SCALEMODE_CEILING                   | [engine.scalemode_ceiling](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_ceiling) |\n         *\n         */\n        this.scaleMode = 1;\n        /**\n         * Force textures to be a power of two (default: false)\n         */\n        this.alwaysForcePOT = false;\n        this._samples = 1;\n        /**\n         * Modify the scale of the post process to be the same as the viewport (default: false)\n         */\n        this.adaptScaleToCurrentViewport = false;\n        this._reusable = false;\n        this._renderId = 0;\n        /**\n         * if externalTextureSamplerBinding is true, the \"apply\" method won't bind the textureSampler texture, it is expected to be done by the \"outside\" (by the onApplyObservable observer most probably).\n         * counter-productive in some cases because if the texture bound by \"apply\" is different from the currently texture bound, (the one set by the onApplyObservable observer, for eg) some\n         * internal structures (materialContext) will be dirtified, which may impact performances\n         */\n        this.externalTextureSamplerBinding = false;\n        /**\n         * Smart array of input and output textures for the post process.\n         * @internal\n         */\n        this._textures = new SmartArray(2);\n        /**\n         * Smart array of input and output textures for the post process.\n         * @internal\n         */\n        this._textureCache = [];\n        /**\n         * The index in _textures that corresponds to the output texture.\n         * @internal\n         */\n        this._currentRenderTextureInd = 0;\n        this._scaleRatio = new Vector2(1, 1);\n        this._texelSize = Vector2.Zero();\n        // Events\n        /**\n         * An event triggered when the postprocess is activated.\n         */\n        this.onActivateObservable = new Observable();\n        /**\n         * An event triggered when the postprocess changes its size.\n         */\n        this.onSizeChangedObservable = new Observable();\n        /**\n         * An event triggered when the postprocess applies its effect.\n         */\n        this.onApplyObservable = new Observable();\n        /**\n         * An event triggered before rendering the postprocess\n         */\n        this.onBeforeRenderObservable = new Observable();\n        /**\n         * An event triggered after rendering the postprocess\n         */\n        this.onAfterRenderObservable = new Observable();\n        this.name = name;\n        if (camera != null) {\n            this._camera = camera;\n            this._scene = camera.getScene();\n            camera.attachPostProcess(this);\n            this._engine = this._scene.getEngine();\n            this._scene.postProcesses.push(this);\n            this.uniqueId = this._scene.getUniqueId();\n        }\n        else if (engine) {\n            this._engine = engine;\n            this._engine.postProcesses.push(this);\n        }\n        this._options = options;\n        this.renderTargetSamplingMode = samplingMode ? samplingMode : 1;\n        this._reusable = reusable || false;\n        this._textureType = textureType;\n        this._textureFormat = textureFormat;\n        this._shaderLanguage = shaderLanguage;\n        this._samplers = samplers || [];\n        this._samplers.push(\"textureSampler\");\n        this._fragmentUrl = fragmentUrl;\n        this._vertexUrl = vertexUrl;\n        this._parameters = parameters || [];\n        this._parameters.push(\"scale\");\n        this._indexParameters = indexParameters;\n        this._drawWrapper = new DrawWrapper(this._engine);\n        if (!blockCompilation) {\n            this.updateEffect(defines);\n        }\n    }\n    /**\n     * Gets a string identifying the name of the class\n     * @returns \"PostProcess\" string\n     */\n    getClassName() {\n        return \"PostProcess\";\n    }\n    /**\n     * Gets the engine which this post process belongs to.\n     * @returns The engine the post process was enabled with.\n     */\n    getEngine() {\n        return this._engine;\n    }\n    /**\n     * The effect that is created when initializing the post process.\n     * @returns The created effect corresponding the the postprocess.\n     */\n    getEffect() {\n        return this._drawWrapper.effect;\n    }\n    /**\n     * To avoid multiple redundant textures for multiple post process, the output the output texture for this post process can be shared with another.\n     * @param postProcess The post process to share the output with.\n     * @returns This post process.\n     */\n    shareOutputWith(postProcess) {\n        this._disposeTextures();\n        this._shareOutputWithPostProcess = postProcess;\n        return this;\n    }\n    /**\n     * Reverses the effect of calling shareOutputWith and returns the post process back to its original state.\n     * This should be called if the post process that shares output with this post process is disabled/disposed.\n     */\n    useOwnOutput() {\n        if (this._textures.length == 0) {\n            this._textures = new SmartArray(2);\n        }\n        this._shareOutputWithPostProcess = null;\n    }\n    /**\n     * Updates the effect with the current post process compile time values and recompiles the shader.\n     * @param defines Define statements that should be added at the beginning of the shader. (default: null)\n     * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)\n     * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)\n     * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\n     * @param onCompiled Called when the shader has been compiled.\n     * @param onError Called if there is an error when compiling a shader.\n     * @param vertexUrl The url of the vertex shader to be used (default: the one given at construction time)\n     * @param fragmentUrl The url of the fragment shader to be used (default: the one given at construction time)\n     */\n    updateEffect(defines = null, uniforms = null, samplers = null, indexParameters, onCompiled, onError, vertexUrl, fragmentUrl) {\n        var _a, _b;\n        const customShaderCodeProcessing = PostProcess._GetShaderCodeProcessing(this.name);\n        if (customShaderCodeProcessing === null || customShaderCodeProcessing === void 0 ? void 0 : customShaderCodeProcessing.defineCustomBindings) {\n            const newUniforms = (_a = uniforms === null || uniforms === void 0 ? void 0 : uniforms.slice()) !== null && _a !== void 0 ? _a : [];\n            newUniforms.push(...this._parameters);\n            const newSamplers = (_b = samplers === null || samplers === void 0 ? void 0 : samplers.slice()) !== null && _b !== void 0 ? _b : [];\n            newSamplers.push(...this._samplers);\n            defines = customShaderCodeProcessing.defineCustomBindings(this.name, defines, newUniforms, newSamplers);\n            uniforms = newUniforms;\n            samplers = newSamplers;\n        }\n        this._postProcessDefines = defines;\n        this._drawWrapper.effect = this._engine.createEffect({ vertex: vertexUrl !== null && vertexUrl !== void 0 ? vertexUrl : this._vertexUrl, fragment: fragmentUrl !== null && fragmentUrl !== void 0 ? fragmentUrl : this._fragmentUrl }, {\n            attributes: [\"position\"],\n            uniformsNames: uniforms || this._parameters,\n            uniformBuffersNames: [],\n            samplers: samplers || this._samplers,\n            defines: defines !== null ? defines : \"\",\n            fallbacks: null,\n            onCompiled: onCompiled !== null && onCompiled !== void 0 ? onCompiled : null,\n            onError: onError !== null && onError !== void 0 ? onError : null,\n            indexParameters: indexParameters || this._indexParameters,\n            processCodeAfterIncludes: (customShaderCodeProcessing === null || customShaderCodeProcessing === void 0 ? void 0 : customShaderCodeProcessing.processCodeAfterIncludes)\n                ? (shaderType, code) => customShaderCodeProcessing.processCodeAfterIncludes(this.name, shaderType, code)\n                : null,\n            processFinalCode: (customShaderCodeProcessing === null || customShaderCodeProcessing === void 0 ? void 0 : customShaderCodeProcessing.processFinalCode)\n                ? (shaderType, code) => customShaderCodeProcessing.processFinalCode(this.name, shaderType, code)\n                : null,\n            shaderLanguage: this._shaderLanguage,\n        }, this._engine);\n    }\n    /**\n     * The post process is reusable if it can be used multiple times within one frame.\n     * @returns If the post process is reusable\n     */\n    isReusable() {\n        return this._reusable;\n    }\n    /** invalidate frameBuffer to hint the postprocess to create a depth buffer */\n    markTextureDirty() {\n        this.width = -1;\n    }\n    _createRenderTargetTexture(textureSize, textureOptions, channel = 0) {\n        for (let i = 0; i < this._textureCache.length; i++) {\n            if (this._textureCache[i].texture.width === textureSize.width &&\n                this._textureCache[i].texture.height === textureSize.height &&\n                this._textureCache[i].postProcessChannel === channel &&\n                this._textureCache[i].texture._generateDepthBuffer === textureOptions.generateDepthBuffer &&\n                this._textureCache[i].texture.samples === textureOptions.samples) {\n                return this._textureCache[i].texture;\n            }\n        }\n        const tex = this._engine.createRenderTargetTexture(textureSize, textureOptions);\n        this._textureCache.push({ texture: tex, postProcessChannel: channel, lastUsedRenderId: -1 });\n        return tex;\n    }\n    _flushTextureCache() {\n        const currentRenderId = this._renderId;\n        for (let i = this._textureCache.length - 1; i >= 0; i--) {\n            if (currentRenderId - this._textureCache[i].lastUsedRenderId > 100) {\n                let currentlyUsed = false;\n                for (let j = 0; j < this._textures.length; j++) {\n                    if (this._textures.data[j] === this._textureCache[i].texture) {\n                        currentlyUsed = true;\n                        break;\n                    }\n                }\n                if (!currentlyUsed) {\n                    this._textureCache[i].texture.dispose();\n                    this._textureCache.splice(i, 1);\n                }\n            }\n        }\n    }\n    _resize(width, height, camera, needMipMaps, forceDepthStencil) {\n        if (this._textures.length > 0) {\n            this._textures.reset();\n        }\n        this.width = width;\n        this.height = height;\n        let firstPP = null;\n        for (let i = 0; i < camera._postProcesses.length; i++) {\n            if (camera._postProcesses[i] !== null) {\n                firstPP = camera._postProcesses[i];\n                break;\n            }\n        }\n        const textureSize = { width: this.width, height: this.height };\n        const textureOptions = {\n            generateMipMaps: needMipMaps,\n            generateDepthBuffer: forceDepthStencil || firstPP === this,\n            generateStencilBuffer: (forceDepthStencil || firstPP === this) && this._engine.isStencilEnable,\n            samplingMode: this.renderTargetSamplingMode,\n            type: this._textureType,\n            format: this._textureFormat,\n            samples: this._samples,\n            label: \"PostProcessRTT-\" + this.name,\n        };\n        this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 0));\n        if (this._reusable) {\n            this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 1));\n        }\n        this._texelSize.copyFromFloats(1.0 / this.width, 1.0 / this.height);\n        this.onSizeChangedObservable.notifyObservers(this);\n    }\n    /**\n     * Activates the post process by intializing the textures to be used when executed. Notifies onActivateObservable.\n     * When this post process is used in a pipeline, this is call will bind the input texture of this post process to the output of the previous.\n     * @param camera The camera that will be used in the post process. This camera will be used when calling onActivateObservable.\n     * @param sourceTexture The source texture to be inspected to get the width and height if not specified in the post process constructor. (default: null)\n     * @param forceDepthStencil If true, a depth and stencil buffer will be generated. (default: false)\n     * @returns The render target wrapper that was bound to be written to.\n     */\n    activate(camera, sourceTexture = null, forceDepthStencil) {\n        var _a, _b;\n        camera = camera || this._camera;\n        const scene = camera.getScene();\n        const engine = scene.getEngine();\n        const maxSize = engine.getCaps().maxTextureSize;\n        let requiredWidth = ((sourceTexture ? sourceTexture.width : this._engine.getRenderWidth(true)) * this._options) | 0;\n        const requiredHeight = ((sourceTexture ? sourceTexture.height : this._engine.getRenderHeight(true)) * this._options) | 0;\n        // If rendering to a webvr camera's left or right eye only half the width should be used to avoid resize when rendered to screen\n        const webVRCamera = camera.parent;\n        if (webVRCamera && (webVRCamera.leftCamera == camera || webVRCamera.rightCamera == camera)) {\n            requiredWidth /= 2;\n        }\n        let desiredWidth = this._options.width || requiredWidth;\n        let desiredHeight = this._options.height || requiredHeight;\n        const needMipMaps = this.renderTargetSamplingMode !== 7 &&\n            this.renderTargetSamplingMode !== 1 &&\n            this.renderTargetSamplingMode !== 2;\n        if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {\n            if (this.adaptScaleToCurrentViewport) {\n                const currentViewport = engine.currentViewport;\n                if (currentViewport) {\n                    desiredWidth *= currentViewport.width;\n                    desiredHeight *= currentViewport.height;\n                }\n            }\n            if (needMipMaps || this.alwaysForcePOT) {\n                if (!this._options.width) {\n                    desiredWidth = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredWidth, maxSize, this.scaleMode) : desiredWidth;\n                }\n                if (!this._options.height) {\n                    desiredHeight = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredHeight, maxSize, this.scaleMode) : desiredHeight;\n                }\n            }\n            if (this.width !== desiredWidth || this.height !== desiredHeight) {\n                this._resize(desiredWidth, desiredHeight, camera, needMipMaps, forceDepthStencil);\n            }\n            this._textures.forEach((texture) => {\n                if (texture.samples !== this.samples) {\n                    this._engine.updateRenderTargetTextureSampleCount(texture, this.samples);\n                }\n            });\n            this._flushTextureCache();\n            this._renderId++;\n        }\n        let target;\n        if (this._shareOutputWithPostProcess) {\n            target = this._shareOutputWithPostProcess.inputTexture;\n        }\n        else if (this._forcedOutputTexture) {\n            target = this._forcedOutputTexture;\n            this.width = this._forcedOutputTexture.width;\n            this.height = this._forcedOutputTexture.height;\n        }\n        else {\n            target = this.inputTexture;\n            let cache;\n            for (let i = 0; i < this._textureCache.length; i++) {\n                if (this._textureCache[i].texture === target) {\n                    cache = this._textureCache[i];\n                    break;\n                }\n            }\n            if (cache) {\n                cache.lastUsedRenderId = this._renderId;\n            }\n        }\n        // Bind the input of this post process to be used as the output of the previous post process.\n        if (this.enablePixelPerfectMode) {\n            this._scaleRatio.copyFromFloats(requiredWidth / desiredWidth, requiredHeight / desiredHeight);\n            this._engine.bindFramebuffer(target, 0, requiredWidth, requiredHeight, this.forceFullscreenViewport);\n        }\n        else {\n            this._scaleRatio.copyFromFloats(1, 1);\n            this._engine.bindFramebuffer(target, 0, undefined, undefined, this.forceFullscreenViewport);\n        }\n        (_b = (_a = this._engine)._debugInsertMarker) === null || _b === void 0 ? void 0 : _b.call(_a, `post process ${this.name} input`);\n        this.onActivateObservable.notifyObservers(camera);\n        // Clear\n        if (this.autoClear && (this.alphaMode === 0 || this.forceAutoClearInAlphaMode)) {\n            this._engine.clear(this.clearColor ? this.clearColor : scene.clearColor, scene._allowPostProcessClearColor, true, true);\n        }\n        if (this._reusable) {\n            this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2;\n        }\n        return target;\n    }\n    /**\n     * If the post process is supported.\n     */\n    get isSupported() {\n        return this._drawWrapper.effect.isSupported;\n    }\n    /**\n     * The aspect ratio of the output texture.\n     */\n    get aspectRatio() {\n        if (this._shareOutputWithPostProcess) {\n            return this._shareOutputWithPostProcess.aspectRatio;\n        }\n        if (this._forcedOutputTexture) {\n            return this._forcedOutputTexture.width / this._forcedOutputTexture.height;\n        }\n        return this.width / this.height;\n    }\n    /**\n     * Get a value indicating if the post-process is ready to be used\n     * @returns true if the post-process is ready (shader is compiled)\n     */\n    isReady() {\n        var _a, _b;\n        return (_b = (_a = this._drawWrapper.effect) === null || _a === void 0 ? void 0 : _a.isReady()) !== null && _b !== void 0 ? _b : false;\n    }\n    /**\n     * Binds all textures and uniforms to the shader, this will be run on every pass.\n     * @returns the effect corresponding to this post process. Null if not compiled or not ready.\n     */\n    apply() {\n        var _a, _b, _c;\n        // Check\n        if (!((_a = this._drawWrapper.effect) === null || _a === void 0 ? void 0 : _a.isReady())) {\n            return null;\n        }\n        // States\n        this._engine.enableEffect(this._drawWrapper);\n        this._engine.setState(false);\n        this._engine.setDepthBuffer(false);\n        this._engine.setDepthWrite(false);\n        // Alpha\n        this._engine.setAlphaMode(this.alphaMode);\n        if (this.alphaConstants) {\n            this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a);\n        }\n        // Bind the output texture of the preivous post process as the input to this post process.\n        let source;\n        if (this._shareOutputWithPostProcess) {\n            source = this._shareOutputWithPostProcess.inputTexture;\n        }\n        else if (this._forcedOutputTexture) {\n            source = this._forcedOutputTexture;\n        }\n        else {\n            source = this.inputTexture;\n        }\n        if (!this.externalTextureSamplerBinding) {\n            this._drawWrapper.effect._bindTexture(\"textureSampler\", source === null || source === void 0 ? void 0 : source.texture);\n        }\n        // Parameters\n        this._drawWrapper.effect.setVector2(\"scale\", this._scaleRatio);\n        this.onApplyObservable.notifyObservers(this._drawWrapper.effect);\n        (_c = (_b = PostProcess._GetShaderCodeProcessing(this.name)) === null || _b === void 0 ? void 0 : _b.bindCustomBindings) === null || _c === void 0 ? void 0 : _c.call(_b, this.name, this._drawWrapper.effect);\n        return this._drawWrapper.effect;\n    }\n    _disposeTextures() {\n        if (this._shareOutputWithPostProcess || this._forcedOutputTexture) {\n            this._disposeTextureCache();\n            return;\n        }\n        this._disposeTextureCache();\n        this._textures.dispose();\n    }\n    _disposeTextureCache() {\n        for (let i = this._textureCache.length - 1; i >= 0; i--) {\n            this._textureCache[i].texture.dispose();\n        }\n        this._textureCache.length = 0;\n    }\n    /**\n     * Sets the required values to the prepass renderer.\n     * @param prePassRenderer defines the prepass renderer to setup.\n     * @returns true if the pre pass is needed.\n     */\n    setPrePassRenderer(prePassRenderer) {\n        if (this._prePassEffectConfiguration) {\n            this._prePassEffectConfiguration = prePassRenderer.addEffectConfiguration(this._prePassEffectConfiguration);\n            this._prePassEffectConfiguration.enabled = true;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Disposes the post process.\n     * @param camera The camera to dispose the post process on.\n     */\n    dispose(camera) {\n        camera = camera || this._camera;\n        this._disposeTextures();\n        let index;\n        if (this._scene) {\n            index = this._scene.postProcesses.indexOf(this);\n            if (index !== -1) {\n                this._scene.postProcesses.splice(index, 1);\n            }\n        }\n        if (this._parentContainer) {\n            const index = this._parentContainer.postProcesses.indexOf(this);\n            if (index > -1) {\n                this._parentContainer.postProcesses.splice(index, 1);\n            }\n            this._parentContainer = null;\n        }\n        index = this._engine.postProcesses.indexOf(this);\n        if (index !== -1) {\n            this._engine.postProcesses.splice(index, 1);\n        }\n        if (!camera) {\n            return;\n        }\n        camera.detachPostProcess(this);\n        index = camera._postProcesses.indexOf(this);\n        if (index === 0 && camera._postProcesses.length > 0) {\n            const firstPostProcess = this._camera._getFirstPostProcess();\n            if (firstPostProcess) {\n                firstPostProcess.markTextureDirty();\n            }\n        }\n        this.onActivateObservable.clear();\n        this.onAfterRenderObservable.clear();\n        this.onApplyObservable.clear();\n        this.onBeforeRenderObservable.clear();\n        this.onSizeChangedObservable.clear();\n    }\n    /**\n     * Serializes the post process to a JSON object\n     * @returns the JSON object\n     */\n    serialize() {\n        const serializationObject = SerializationHelper.Serialize(this);\n        const camera = this.getCamera() || (this._scene && this._scene.activeCamera);\n        serializationObject.customType = \"BABYLON.\" + this.getClassName();\n        serializationObject.cameraId = camera ? camera.id : null;\n        serializationObject.reusable = this._reusable;\n        serializationObject.textureType = this._textureType;\n        serializationObject.fragmentUrl = this._fragmentUrl;\n        serializationObject.parameters = this._parameters;\n        serializationObject.samplers = this._samplers;\n        serializationObject.options = this._options;\n        serializationObject.defines = this._postProcessDefines;\n        serializationObject.textureFormat = this._textureFormat;\n        serializationObject.vertexUrl = this._vertexUrl;\n        serializationObject.indexParameters = this._indexParameters;\n        return serializationObject;\n    }\n    /**\n     * Clones this post process\n     * @returns a new post process similar to this one\n     */\n    clone() {\n        const serializationObject = this.serialize();\n        serializationObject._engine = this._engine;\n        serializationObject.cameraId = null;\n        const result = PostProcess.Parse(serializationObject, this._scene, \"\");\n        if (!result) {\n            return null;\n        }\n        result.onActivateObservable = this.onActivateObservable.clone();\n        result.onSizeChangedObservable = this.onSizeChangedObservable.clone();\n        result.onApplyObservable = this.onApplyObservable.clone();\n        result.onBeforeRenderObservable = this.onBeforeRenderObservable.clone();\n        result.onAfterRenderObservable = this.onAfterRenderObservable.clone();\n        result._prePassEffectConfiguration = this._prePassEffectConfiguration;\n        return result;\n    }\n    /**\n     * Creates a material from parsed material data\n     * @param parsedPostProcess defines parsed post process data\n     * @param scene defines the hosting scene\n     * @param rootUrl defines the root URL to use to load textures\n     * @returns a new post process\n     */\n    static Parse(parsedPostProcess, scene, rootUrl) {\n        const postProcessType = GetClass(parsedPostProcess.customType);\n        if (!postProcessType || !postProcessType._Parse) {\n            return null;\n        }\n        const camera = scene ? scene.getCameraById(parsedPostProcess.cameraId) : null;\n        return postProcessType._Parse(parsedPostProcess, camera, scene, rootUrl);\n    }\n    /**\n     * @internal\n     */\n    static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {\n        return SerializationHelper.Parse(() => {\n            return new PostProcess(parsedPostProcess.name, parsedPostProcess.fragmentUrl, parsedPostProcess.parameters, parsedPostProcess.samplers, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, parsedPostProcess._engine, parsedPostProcess.reusable, parsedPostProcess.defines, parsedPostProcess.textureType, parsedPostProcess.vertexUrl, parsedPostProcess.indexParameters, false, parsedPostProcess.textureFormat);\n        }, parsedPostProcess, scene, rootUrl);\n    }\n}\nPostProcess._CustomShaderCodeProcessing = {};\n__decorate([\n    serialize()\n], PostProcess.prototype, \"uniqueId\", void 0);\n__decorate([\n    serialize()\n], PostProcess.prototype, \"name\", void 0);\n__decorate([\n    serialize()\n], PostProcess.prototype, \"width\", void 0);\n__decorate([\n    serialize()\n], PostProcess.prototype, \"height\", void 0);\n__decorate([\n    serialize()\n], PostProcess.prototype, \"renderTargetSamplingMode\", void 0);\n__decorate([\n    serializeAsColor4()\n], PostProcess.prototype, \"clearColor\", void 0);\n__decorate([\n    serialize()\n], PostProcess.prototype, \"autoClear\", void 0);\n__decorate([\n    serialize()\n], PostProcess.prototype, \"forceAutoClearInAlphaMode\", void 0);\n__decorate([\n    serialize()\n], PostProcess.prototype, \"alphaMode\", void 0);\n__decorate([\n    serialize()\n], PostProcess.prototype, \"alphaConstants\", void 0);\n__decorate([\n    serialize()\n], PostProcess.prototype, \"enablePixelPerfectMode\", void 0);\n__decorate([\n    serialize()\n], PostProcess.prototype, \"forceFullscreenViewport\", void 0);\n__decorate([\n    serialize()\n], PostProcess.prototype, \"scaleMode\", void 0);\n__decorate([\n    serialize()\n], PostProcess.prototype, \"alwaysForcePOT\", void 0);\n__decorate([\n    serialize(\"samples\")\n], PostProcess.prototype, \"_samples\", void 0);\n__decorate([\n    serialize()\n], PostProcess.prototype, \"adaptScaleToCurrentViewport\", void 0);\nRegisterClass(\"BABYLON.PostProcess\", PostProcess);\n//# sourceMappingURL=postProcess.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"kernelBlurVaryingDeclaration\";\nconst shader = `varying vec2 sampleCoord{X};`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const kernelBlurVaryingDeclaration = { name, shader };\n//# sourceMappingURL=kernelBlurVaryingDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"packingFunctions\";\nconst shader = `vec4 pack(float depth)\r{\rconst vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);\rconst vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);\rvec4 res=fract(depth*bit_shift);\rres-=res.xxyz*bit_mask;\rreturn res;\r}\rfloat unpack(vec4 color)\r{\rconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\rreturn dot(color,bit_shift);\r}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const packingFunctions = { name, shader };\n//# sourceMappingURL=packingFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"kernelBlurFragment\";\nconst shader = `#ifdef DOF\nfactor=sampleCoC(sampleCoord{X}); \rcomputedWeight=KERNEL_WEIGHT{X}*factor;\rsumOfWeights+=computedWeight;\r#else\ncomputedWeight=KERNEL_WEIGHT{X};\r#endif\n#ifdef PACKEDFLOAT\nblend+=unpack(texture2D(textureSampler,sampleCoord{X}))*computedWeight;\r#else\nblend+=texture2D(textureSampler,sampleCoord{X})*computedWeight;\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const kernelBlurFragment = { name, shader };\n//# sourceMappingURL=kernelBlurFragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"kernelBlurFragment2\";\nconst shader = `#ifdef DOF\nfactor=sampleCoC(sampleCenter+delta*KERNEL_DEP_OFFSET{X});\rcomputedWeight=KERNEL_DEP_WEIGHT{X}*factor;\rsumOfWeights+=computedWeight;\r#else\ncomputedWeight=KERNEL_DEP_WEIGHT{X};\r#endif\n#ifdef PACKEDFLOAT\nblend+=unpack(texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X}))*computedWeight;\r#else\nblend+=texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X})*computedWeight;\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const kernelBlurFragment2 = { name, shader };\n//# sourceMappingURL=kernelBlurFragment2.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/kernelBlurVaryingDeclaration.js\";\nimport \"./ShadersInclude/packingFunctions.js\";\nimport \"./ShadersInclude/kernelBlurFragment.js\";\nimport \"./ShadersInclude/kernelBlurFragment2.js\";\nconst name = \"kernelBlurPixelShader\";\nconst shader = `uniform sampler2D textureSampler;\runiform vec2 delta;\rvarying vec2 sampleCenter;\r#ifdef DOF\nuniform sampler2D circleOfConfusionSampler;\rfloat sampleCoC(in vec2 offset) {\rfloat coc=texture2D(circleOfConfusionSampler,offset).r;\rreturn coc; \r}\r#endif\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\n#ifdef PACKEDFLOAT\n#include<packingFunctions>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\r{\rfloat computedWeight=0.0;\r#ifdef PACKEDFLOAT\nfloat blend=0.;\r#else\nvec4 blend=vec4(0.);\r#endif\n#ifdef DOF\nfloat sumOfWeights=CENTER_WEIGHT; \rfloat factor=0.0;\r#ifdef PACKEDFLOAT\nblend+=unpack(texture2D(textureSampler,sampleCenter))*CENTER_WEIGHT;\r#else\nblend+=texture2D(textureSampler,sampleCenter)*CENTER_WEIGHT;\r#endif\n#endif\n#include<kernelBlurFragment>[0..varyingCount]\n#include<kernelBlurFragment2>[0..depCount]\n#ifdef PACKEDFLOAT\ngl_FragColor=pack(blend);\r#else\ngl_FragColor=blend;\r#endif\n#ifdef DOF\ngl_FragColor/=sumOfWeights;\r#endif\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const kernelBlurPixelShader = { name, shader };\n//# sourceMappingURL=kernelBlur.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/kernelBlurVaryingDeclaration.js\";\nimport \"./ShadersInclude/kernelBlurVertex.js\";\nconst name = \"kernelBlurVertexShader\";\nconst shader = `attribute vec2 position;\runiform vec2 delta;\rvarying vec2 sampleCenter;\r#include<kernelBlurVaryingDeclaration>[0..varyingCount]\nconst vec2 madd=vec2(0.5,0.5);\r#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\nsampleCenter=(position*madd+madd);\r#include<kernelBlurVertex>[0..varyingCount]\ngl_Position=vec4(position,0.0,1.0);\r#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const kernelBlurVertexShader = { name, shader };\n//# sourceMappingURL=kernelBlur.vertex.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { PostProcess } from \"./postProcess.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\n\nimport \"../Shaders/kernelBlur.fragment.js\";\nimport \"../Shaders/kernelBlur.vertex.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { serialize, serializeAsVector2, SerializationHelper } from \"../Misc/decorators.js\";\n/**\n * The Blur Post Process which blurs an image based on a kernel and direction.\n * Can be used twice in x and y directions to perform a gaussian blur in two passes.\n */\nexport class BlurPostProcess extends PostProcess {\n    /**\n     * Sets the length in pixels of the blur sample region\n     */\n    set kernel(v) {\n        if (this._idealKernel === v) {\n            return;\n        }\n        v = Math.max(v, 1);\n        this._idealKernel = v;\n        this._kernel = this._nearestBestKernel(v);\n        if (!this._blockCompilation) {\n            this._updateParameters();\n        }\n    }\n    /**\n     * Gets the length in pixels of the blur sample region\n     */\n    get kernel() {\n        return this._idealKernel;\n    }\n    /**\n     * Sets whether or not the blur needs to unpack/repack floats\n     */\n    set packedFloat(v) {\n        if (this._packedFloat === v) {\n            return;\n        }\n        this._packedFloat = v;\n        if (!this._blockCompilation) {\n            this._updateParameters();\n        }\n    }\n    /**\n     * Gets whether or not the blur is unpacking/repacking floats\n     */\n    get packedFloat() {\n        return this._packedFloat;\n    }\n    /**\n     * Gets a string identifying the name of the class\n     * @returns \"BlurPostProcess\" string\n     */\n    getClassName() {\n        return \"BlurPostProcess\";\n    }\n    /**\n     * Creates a new instance BlurPostProcess\n     * @param name The name of the effect.\n     * @param direction The direction in which to blur the image.\n     * @param kernel The size of the kernel to be used when computing the blur. eg. Size of 3 will blur the center pixel by 2 pixels surrounding it.\n     * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\n     * @param camera The camera to apply the render pass to.\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n     * @param engine The engine which the post process will be applied. (default: current engine)\n     * @param reusable If the post process can be reused on the same frame. (default: false)\n     * @param textureType Type of textures used when performing the post process. (default: 0)\n     * @param defines\n     * @param _blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\n     * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\n     */\n    constructor(name, direction, kernel, options, camera, samplingMode = Texture.BILINEAR_SAMPLINGMODE, engine, reusable, textureType = 0, defines = \"\", _blockCompilation = false, textureFormat = 5) {\n        super(name, \"kernelBlur\", [\"delta\", \"direction\"], [\"circleOfConfusionSampler\"], options, camera, samplingMode, engine, reusable, null, textureType, \"kernelBlur\", { varyingCount: 0, depCount: 0 }, true, textureFormat);\n        this._blockCompilation = _blockCompilation;\n        this._packedFloat = false;\n        this._staticDefines = \"\";\n        this._staticDefines = defines;\n        this.direction = direction;\n        this.onApplyObservable.add((effect) => {\n            if (this._outputTexture) {\n                effect.setFloat2(\"delta\", (1 / this._outputTexture.width) * this.direction.x, (1 / this._outputTexture.height) * this.direction.y);\n            }\n            else {\n                effect.setFloat2(\"delta\", (1 / this.width) * this.direction.x, (1 / this.height) * this.direction.y);\n            }\n        });\n        this.kernel = kernel;\n    }\n    /**\n     * Updates the effect with the current post process compile time values and recompiles the shader.\n     * @param defines Define statements that should be added at the beginning of the shader. (default: null)\n     * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)\n     * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)\n     * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\n     * @param onCompiled Called when the shader has been compiled.\n     * @param onError Called if there is an error when compiling a shader.\n     */\n    updateEffect(defines = null, uniforms = null, samplers = null, indexParameters, onCompiled, onError) {\n        this._updateParameters(onCompiled, onError);\n    }\n    _updateParameters(onCompiled, onError) {\n        // Generate sampling offsets and weights\n        const N = this._kernel;\n        const centerIndex = (N - 1) / 2;\n        // Generate Gaussian sampling weights over kernel\n        let offsets = [];\n        let weights = [];\n        let totalWeight = 0;\n        for (let i = 0; i < N; i++) {\n            const u = i / (N - 1);\n            const w = this._gaussianWeight(u * 2.0 - 1);\n            offsets[i] = i - centerIndex;\n            weights[i] = w;\n            totalWeight += w;\n        }\n        // Normalize weights\n        for (let i = 0; i < weights.length; i++) {\n            weights[i] /= totalWeight;\n        }\n        // Optimize: combine samples to take advantage of hardware linear sampling\n        // Walk from left to center, combining pairs (symmetrically)\n        const linearSamplingWeights = [];\n        const linearSamplingOffsets = [];\n        const linearSamplingMap = [];\n        for (let i = 0; i <= centerIndex; i += 2) {\n            const j = Math.min(i + 1, Math.floor(centerIndex));\n            const singleCenterSample = i === j;\n            if (singleCenterSample) {\n                linearSamplingMap.push({ o: offsets[i], w: weights[i] });\n            }\n            else {\n                const sharedCell = j === centerIndex;\n                const weightLinear = weights[i] + weights[j] * (sharedCell ? 0.5 : 1);\n                const offsetLinear = offsets[i] + 1 / (1 + weights[i] / weights[j]);\n                if (offsetLinear === 0) {\n                    linearSamplingMap.push({ o: offsets[i], w: weights[i] });\n                    linearSamplingMap.push({ o: offsets[i + 1], w: weights[i + 1] });\n                }\n                else {\n                    linearSamplingMap.push({ o: offsetLinear, w: weightLinear });\n                    linearSamplingMap.push({ o: -offsetLinear, w: weightLinear });\n                }\n            }\n        }\n        for (let i = 0; i < linearSamplingMap.length; i++) {\n            linearSamplingOffsets[i] = linearSamplingMap[i].o;\n            linearSamplingWeights[i] = linearSamplingMap[i].w;\n        }\n        // Replace with optimized\n        offsets = linearSamplingOffsets;\n        weights = linearSamplingWeights;\n        // Generate shaders\n        const maxVaryingRows = this.getEngine().getCaps().maxVaryingVectors;\n        const freeVaryingVec2 = Math.max(maxVaryingRows, 0) - 1; // Because of sampleCenter\n        let varyingCount = Math.min(offsets.length, freeVaryingVec2);\n        let defines = \"\";\n        defines += this._staticDefines;\n        // The DOF fragment should ignore the center pixel when looping as it is handled manually in the fragment shader.\n        if (this._staticDefines.indexOf(\"DOF\") != -1) {\n            defines += `#define CENTER_WEIGHT ${this._glslFloat(weights[varyingCount - 1])}\\r\\n`;\n            varyingCount--;\n        }\n        for (let i = 0; i < varyingCount; i++) {\n            defines += `#define KERNEL_OFFSET${i} ${this._glslFloat(offsets[i])}\\r\\n`;\n            defines += `#define KERNEL_WEIGHT${i} ${this._glslFloat(weights[i])}\\r\\n`;\n        }\n        let depCount = 0;\n        for (let i = freeVaryingVec2; i < offsets.length; i++) {\n            defines += `#define KERNEL_DEP_OFFSET${depCount} ${this._glslFloat(offsets[i])}\\r\\n`;\n            defines += `#define KERNEL_DEP_WEIGHT${depCount} ${this._glslFloat(weights[i])}\\r\\n`;\n            depCount++;\n        }\n        if (this.packedFloat) {\n            defines += `#define PACKEDFLOAT 1`;\n        }\n        this._blockCompilation = false;\n        super.updateEffect(defines, null, null, {\n            varyingCount: varyingCount,\n            depCount: depCount,\n        }, onCompiled, onError);\n    }\n    /**\n     * Best kernels are odd numbers that when divided by 2, their integer part is even, so 5, 9 or 13.\n     * Other odd kernels optimize correctly but require proportionally more samples, even kernels are\n     * possible but will produce minor visual artifacts. Since each new kernel requires a new shader we\n     * want to minimize kernel changes, having gaps between physical kernels is helpful in that regard.\n     * The gaps between physical kernels are compensated for in the weighting of the samples\n     * @param idealKernel Ideal blur kernel.\n     * @returns Nearest best kernel.\n     */\n    _nearestBestKernel(idealKernel) {\n        const v = Math.round(idealKernel);\n        for (const k of [v, v - 1, v + 1, v - 2, v + 2]) {\n            if (k % 2 !== 0 && Math.floor(k / 2) % 2 === 0 && k > 0) {\n                return Math.max(k, 3);\n            }\n        }\n        return Math.max(v, 3);\n    }\n    /**\n     * Calculates the value of a Gaussian distribution with sigma 3 at a given point.\n     * @param x The point on the Gaussian distribution to sample.\n     * @returns the value of the Gaussian function at x.\n     */\n    _gaussianWeight(x) {\n        //reference: Engines/ImageProcessingBlur.cpp #dcc760\n        // We are evaluating the Gaussian (normal) distribution over a kernel parameter space of [-1,1],\n        // so we truncate at three standard deviations by setting stddev (sigma) to 1/3.\n        // The choice of 3-sigma truncation is common but arbitrary, and means that the signal is\n        // truncated at around 1.3% of peak strength.\n        //the distribution is scaled to account for the difference between the actual kernel size and the requested kernel size\n        const sigma = 1 / 3;\n        const denominator = Math.sqrt(2.0 * Math.PI) * sigma;\n        const exponent = -((x * x) / (2.0 * sigma * sigma));\n        const weight = (1.0 / denominator) * Math.exp(exponent);\n        return weight;\n    }\n    /**\n     * Generates a string that can be used as a floating point number in GLSL.\n     * @param x Value to print.\n     * @param decimalFigures Number of decimal places to print the number to (excluding trailing 0s).\n     * @returns GLSL float string.\n     */\n    _glslFloat(x, decimalFigures = 8) {\n        return x.toFixed(decimalFigures).replace(/0+$/, \"\");\n    }\n    /**\n     * @internal\n     */\n    static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {\n        return SerializationHelper.Parse(() => {\n            return new BlurPostProcess(parsedPostProcess.name, parsedPostProcess.direction, parsedPostProcess.kernel, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType, undefined, false);\n        }, parsedPostProcess, scene, rootUrl);\n    }\n}\n__decorate([\n    serialize(\"kernel\")\n], BlurPostProcess.prototype, \"_kernel\", void 0);\n__decorate([\n    serialize(\"packedFloat\")\n], BlurPostProcess.prototype, \"_packedFloat\", void 0);\n__decorate([\n    serializeAsVector2()\n], BlurPostProcess.prototype, \"direction\", void 0);\nRegisterClass(\"BABYLON.BlurPostProcess\", BlurPostProcess);\n//# sourceMappingURL=blurPostProcess.js.map","/**\n * EffectFallbacks can be used to add fallbacks (properties to disable) to certain properties when desired to improve performance.\n * (Eg. Start at high quality with reflection and fog, if fps is low, remove reflection, if still low remove fog)\n */\nexport class EffectFallbacks {\n    constructor() {\n        this._defines = {};\n        this._currentRank = 32;\n        this._maxRank = -1;\n        this._mesh = null;\n    }\n    /**\n     * Removes the fallback from the bound mesh.\n     */\n    unBindMesh() {\n        this._mesh = null;\n    }\n    /**\n     * Adds a fallback on the specified property.\n     * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)\n     * @param define The name of the define in the shader\n     */\n    addFallback(rank, define) {\n        if (!this._defines[rank]) {\n            if (rank < this._currentRank) {\n                this._currentRank = rank;\n            }\n            if (rank > this._maxRank) {\n                this._maxRank = rank;\n            }\n            this._defines[rank] = new Array();\n        }\n        this._defines[rank].push(define);\n    }\n    /**\n     * Sets the mesh to use CPU skinning when needing to fallback.\n     * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)\n     * @param mesh The mesh to use the fallbacks.\n     */\n    addCPUSkinningFallback(rank, mesh) {\n        this._mesh = mesh;\n        if (rank < this._currentRank) {\n            this._currentRank = rank;\n        }\n        if (rank > this._maxRank) {\n            this._maxRank = rank;\n        }\n    }\n    /**\n     * Checks to see if more fallbacks are still available.\n     */\n    get hasMoreFallbacks() {\n        return this._currentRank <= this._maxRank;\n    }\n    /**\n     * Removes the defines that should be removed when falling back.\n     * @param currentDefines defines the current define statements for the shader.\n     * @param effect defines the current effect we try to compile\n     * @returns The resulting defines with defines of the current rank removed.\n     */\n    reduce(currentDefines, effect) {\n        // First we try to switch to CPU skinning\n        if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {\n            this._mesh.computeBonesUsingShaders = false;\n            currentDefines = currentDefines.replace(\"#define NUM_BONE_INFLUENCERS \" + this._mesh.numBoneInfluencers, \"#define NUM_BONE_INFLUENCERS 0\");\n            effect._bonesComputationForcedToCPU = true;\n            const scene = this._mesh.getScene();\n            for (let index = 0; index < scene.meshes.length; index++) {\n                const otherMesh = scene.meshes[index];\n                if (!otherMesh.material) {\n                    if (!this._mesh.material && otherMesh.computeBonesUsingShaders && otherMesh.numBoneInfluencers > 0) {\n                        otherMesh.computeBonesUsingShaders = false;\n                    }\n                    continue;\n                }\n                if (!otherMesh.computeBonesUsingShaders || otherMesh.numBoneInfluencers === 0) {\n                    continue;\n                }\n                if (otherMesh.material.getEffect() === effect) {\n                    otherMesh.computeBonesUsingShaders = false;\n                }\n                else if (otherMesh.subMeshes) {\n                    for (const subMesh of otherMesh.subMeshes) {\n                        const subMeshEffect = subMesh.effect;\n                        if (subMeshEffect === effect) {\n                            otherMesh.computeBonesUsingShaders = false;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            const currentFallbacks = this._defines[this._currentRank];\n            if (currentFallbacks) {\n                for (let index = 0; index < currentFallbacks.length; index++) {\n                    currentDefines = currentDefines.replace(\"#define \" + currentFallbacks[index], \"\");\n                }\n            }\n            this._currentRank++;\n        }\n        return currentDefines;\n    }\n}\n//# sourceMappingURL=effectFallbacks.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"bayerDitherFunctions\";\nconst shader = `float bayerDither2(vec2 _P) {\rreturn mod(2.0*_P.y+_P.x+1.0,4.0);\r}\rfloat bayerDither4(vec2 _P) {\rvec2 P1=mod(_P,2.0); \rvec2 P2=floor(0.5*mod(_P,4.0)); \rreturn 4.0*bayerDither2(P1)+bayerDither2(P2);\r}\rfloat bayerDither8(vec2 _P) {\rvec2 P1=mod(_P,2.0); \rvec2 P2=floor(0.5 *mod(_P,4.0)); \rvec2 P4=floor(0.25*mod(_P,8.0)); \rreturn 4.0*(4.0*bayerDither2(P1)+bayerDither2(P2))+bayerDither2(P4);\r}\r`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bayerDitherFunctions = { name, shader };\n//# sourceMappingURL=bayerDitherFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nimport \"./packingFunctions.js\";\nimport \"./bayerDitherFunctions.js\";\nconst name = \"shadowMapFragmentExtraDeclaration\";\nconst shader = `#if SM_FLOAT==0\n#include<packingFunctions>\n#endif\n#if SM_SOFTTRANSPARENTSHADOW==1\n#include<bayerDitherFunctions>\nuniform float softTransparentShadowSM;\r#endif\nvarying float vDepthMetricSM;\r#if SM_USEDISTANCE==1\nuniform vec3 lightDataSM;\rvarying vec3 vPositionWSM;\r#endif\nuniform vec3 biasAndScaleSM;\runiform vec2 depthValuesSM;\r#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\nvarying float zSM;\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const shadowMapFragmentExtraDeclaration = { name, shader };\n//# sourceMappingURL=shadowMapFragmentExtraDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"clipPlaneFragmentDeclaration\";\nconst shader = `#ifdef CLIPPLANE\nvarying float fClipDistance;\r#endif\n#ifdef CLIPPLANE2\nvarying float fClipDistance2;\r#endif\n#ifdef CLIPPLANE3\nvarying float fClipDistance3;\r#endif\n#ifdef CLIPPLANE4\nvarying float fClipDistance4;\r#endif\n#ifdef CLIPPLANE5\nvarying float fClipDistance5;\r#endif\n#ifdef CLIPPLANE6\nvarying float fClipDistance6;\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const clipPlaneFragmentDeclaration = { name, shader };\n//# sourceMappingURL=clipPlaneFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"clipPlaneFragment\";\nconst shader = `#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nif (false) {}\r#endif\n#ifdef CLIPPLANE\nelse if (fClipDistance>0.0)\r{\rdiscard;\r}\r#endif\n#ifdef CLIPPLANE2\nelse if (fClipDistance2>0.0)\r{\rdiscard;\r}\r#endif\n#ifdef CLIPPLANE3\nelse if (fClipDistance3>0.0)\r{\rdiscard;\r}\r#endif\n#ifdef CLIPPLANE4\nelse if (fClipDistance4>0.0)\r{\rdiscard;\r}\r#endif\n#ifdef CLIPPLANE5\nelse if (fClipDistance5>0.0)\r{\rdiscard;\r}\r#endif\n#ifdef CLIPPLANE6\nelse if (fClipDistance6>0.0)\r{\rdiscard;\r}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const clipPlaneFragment = { name, shader };\n//# sourceMappingURL=clipPlaneFragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"shadowMapFragment\";\nconst shader = `float depthSM=vDepthMetricSM;\r#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\n#if SM_USEDISTANCE==1\ndepthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\r#else\n#ifdef USE_REVERSE_DEPTHBUFFER\ndepthSM=(-zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\r#else\ndepthSM=(zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\r#endif\n#endif\n#ifdef USE_REVERSE_DEPTHBUFFER\ngl_FragDepth=clamp(1.0-depthSM,0.0,1.0);\r#else\ngl_FragDepth=clamp(depthSM,0.0,1.0); \r#endif\n#elif SM_USEDISTANCE==1\ndepthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\r#endif\n#if SM_ESM==1\ndepthSM=clamp(exp(-min(87.,biasAndScaleSM.z*depthSM)),0.,1.);\r#endif\n#if SM_FLOAT==1\ngl_FragColor=vec4(depthSM,1.0,1.0,1.0);\r#else\ngl_FragColor=pack(depthSM);\r#endif\nreturn;`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const shadowMapFragment = { name, shader };\n//# sourceMappingURL=shadowMapFragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/shadowMapFragmentExtraDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneFragment.js\";\nimport \"./ShadersInclude/shadowMapFragment.js\";\nconst name = \"shadowMapPixelShader\";\nconst shader = `#include<shadowMapFragmentExtraDeclaration>\n#ifdef ALPHATEXTURE\nvarying vec2 vUV;\runiform sampler2D diffuseSampler;\r#endif\n#include<clipPlaneFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\r{\r#include<clipPlaneFragment>\n#ifdef ALPHATEXTURE\nfloat alphaFromAlphaTexture=texture2D(diffuseSampler,vUV).a;\r#ifdef ALPHATESTVALUE\nif (alphaFromAlphaTexture<ALPHATESTVALUE)\rdiscard;\r#endif\n#endif\n#if SM_SOFTTRANSPARENTSHADOW==1\n#ifdef ALPHATEXTURE\nif ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM*alphaFromAlphaTexture) discard;\r#else\nif ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM) discard;\r#endif\n#endif\n#include<shadowMapFragment>\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const shadowMapPixelShader = { name, shader };\n//# sourceMappingURL=shadowMap.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"bakedVertexAnimationDeclaration\";\nconst shader = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\nuniform float bakedVertexAnimationTime;\runiform vec2 bakedVertexAnimationTextureSizeInverted;\runiform vec4 bakedVertexAnimationSettings;\runiform sampler2D bakedVertexAnimationTexture;\r#ifdef INSTANCES\nattribute vec4 bakedVertexAnimationSettingsInstanced;\r#endif\n#define inline\nmat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)\r{\rfloat offset=index*4.0;\rfloat frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;\rfloat dx=bakedVertexAnimationTextureSizeInverted.x;\rvec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));\rvec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));\rvec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));\rvec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));\rreturn mat4(m0,m1,m2,m3);\r}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bakedVertexAnimationDeclaration = { name, shader };\n//# sourceMappingURL=bakedVertexAnimationDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"bonesDeclaration\";\nconst shader = `#if NUM_BONE_INFLUENCERS>0\nattribute vec4 matricesIndices;\rattribute vec4 matricesWeights;\r#if NUM_BONE_INFLUENCERS>4\nattribute vec4 matricesIndicesExtra;\rattribute vec4 matricesWeightsExtra;\r#endif\n#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#ifdef BONETEXTURE\nuniform sampler2D boneSampler;\runiform float boneTextureWidth;\r#else\nuniform mat4 mBones[BonesPerMesh];\r#ifdef BONES_VELOCITY_ENABLED\nuniform mat4 mPreviousBones[BonesPerMesh];\r#endif\n#endif\n#ifdef BONETEXTURE\n#define inline\nmat4 readMatrixFromRawSampler(sampler2D smp,float index)\r{\rfloat offset=index *4.0;\rfloat dx=1.0/boneTextureWidth;\rvec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));\rvec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));\rvec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));\rvec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));\rreturn mat4(m0,m1,m2,m3);\r}\r#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bonesDeclaration = { name, shader };\n//# sourceMappingURL=bonesDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"helperFunctions\";\nconst shader = `const float PI=3.1415926535897932384626433832795;\rconst float HALF_MIN=5.96046448e-08; \rconst float LinearEncodePowerApprox=2.2;\rconst float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;\rconst vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);\rconst float Epsilon=0.0000001;\r#define saturate(x) clamp(x,0.0,1.0)\n#define absEps(x) abs(x)+Epsilon\n#define maxEps(x) max(x,Epsilon)\n#define saturateEps(x) clamp(x,Epsilon,1.0)\nmat3 transposeMat3(mat3 inMatrix) {\rvec3 i0=inMatrix[0];\rvec3 i1=inMatrix[1];\rvec3 i2=inMatrix[2];\rmat3 outMatrix=mat3(\rvec3(i0.x,i1.x,i2.x),\rvec3(i0.y,i1.y,i2.y),\rvec3(i0.z,i1.z,i2.z)\r);\rreturn outMatrix;\r}\rmat3 inverseMat3(mat3 inMatrix) {\rfloat a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];\rfloat a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];\rfloat a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];\rfloat b01=a22*a11-a12*a21;\rfloat b11=-a22*a10+a12*a20;\rfloat b21=a21*a10-a11*a20;\rfloat det=a00*b01+a01*b11+a02*b21;\rreturn mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),\rb11,(a22*a00-a02*a20),(-a12*a00+a02*a10),\rb21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;\r}\r#if USE_EXACT_SRGB_CONVERSIONS\nvec3 toLinearSpaceExact(vec3 color)\r{\rvec3 nearZeroSection=0.0773993808*color;\rvec3 remainingSection=pow(0.947867299*(color+vec3(0.055)),vec3(2.4));\r#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.04045)));\r#else\nreturn\rvec3(\rcolor.r<=0.04045 ? nearZeroSection.r : remainingSection.r,\rcolor.g<=0.04045 ? nearZeroSection.g : remainingSection.g,\rcolor.b<=0.04045 ? nearZeroSection.b : remainingSection.b);\r#endif\n}\rvec3 toGammaSpaceExact(vec3 color)\r{\rvec3 nearZeroSection=12.92*color;\rvec3 remainingSection=1.055*pow(color,vec3(0.41666))-vec3(0.055);\r#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.0031308)));\r#else\nreturn\rvec3(\rcolor.r<=0.0031308 ? nearZeroSection.r : remainingSection.r,\rcolor.g<=0.0031308 ? nearZeroSection.g : remainingSection.g,\rcolor.b<=0.0031308 ? nearZeroSection.b : remainingSection.b);\r#endif\n}\r#endif\nfloat toLinearSpace(float color)\r{\r#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=0.0773993808*color;\rfloat remainingSection=pow(0.947867299*(color+0.055),2.4);\rreturn color<=0.04045 ? nearZeroSection : remainingSection;\r#else\nreturn pow(color,LinearEncodePowerApprox);\r#endif\n}\rvec3 toLinearSpace(vec3 color)\r{\r#if USE_EXACT_SRGB_CONVERSIONS\nreturn toLinearSpaceExact(color);\r#else\nreturn pow(color,vec3(LinearEncodePowerApprox));\r#endif\n}\rvec4 toLinearSpace(vec4 color)\r{\r#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toLinearSpaceExact(color.rgb),color.a);\r#else\nreturn vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);\r#endif\n}\rfloat toGammaSpace(float color)\r{\r#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=12.92*color;\rfloat remainingSection=1.055*pow(color,0.41666)-0.055;\rreturn color<=0.0031308 ? nearZeroSection : remainingSection;\r#else\nreturn pow(color,GammaEncodePowerApprox);\r#endif\n}\rvec3 toGammaSpace(vec3 color)\r{\r#if USE_EXACT_SRGB_CONVERSIONS\nreturn toGammaSpaceExact(color);\r#else\nreturn pow(color,vec3(GammaEncodePowerApprox));\r#endif\n}\rvec4 toGammaSpace(vec4 color)\r{\r#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toGammaSpaceExact(color.rgb),color.a);\r#else\nreturn vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);\r#endif\n}\rfloat square(float value)\r{\rreturn value*value;\r}\rvec3 square(vec3 value)\r{\rreturn value*value;\r}\rfloat pow5(float value) {\rfloat sq=value*value;\rreturn sq*sq*value;\r}\rfloat getLuminance(vec3 color)\r{\rreturn clamp(dot(color,LuminanceEncodeApprox),0.,1.);\r}\rfloat getRand(vec2 seed) {\rreturn fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);\r}\rfloat dither(vec2 seed,float varianceAmount) {\rfloat rand=getRand(seed);\rfloat normVariance=varianceAmount/255.0;\rfloat dither=mix(-normVariance,normVariance,rand);\rreturn dither;\r}\rconst float rgbdMaxRange=255.0;\rvec4 toRGBD(vec3 color) {\rfloat maxRGB=maxEps(max(color.r,max(color.g,color.b)));\rfloat D =max(rgbdMaxRange/maxRGB,1.);\rD =clamp(floor(D)/255.0,0.,1.);\rvec3 rgb=color.rgb*D;\rrgb=toGammaSpace(rgb);\rreturn vec4(clamp(rgb,0.,1.),D); \r}\rvec3 fromRGBD(vec4 rgbd) {\rrgbd.rgb=toLinearSpace(rgbd.rgb);\rreturn rgbd.rgb/rgbd.a;\r}\rvec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {\rvec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;\rvec3 halfSize=cubeSize*0.5;\rvec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;\rvec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;\rvec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);\rfloat distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);\rvec3 intersectPositionWS=vertexPos+origVec*distance;\rreturn intersectPositionWS-cubePos;\r}\r`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const helperFunctions = { name, shader };\n//# sourceMappingURL=helperFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"meshVertexDeclaration\";\nconst shader = `uniform mat4 world;\runiform float visibility;\r`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const meshVertexDeclaration = { name, shader };\n//# sourceMappingURL=meshVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nimport \"./sceneUboDeclaration.js\";\nimport \"./meshUboDeclaration.js\";\nconst name = \"shadowMapUboDeclaration\";\nconst shader = `layout(std140,column_major) uniform;\r#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const shadowMapUboDeclaration = { name, shader };\n//# sourceMappingURL=shadowMapUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"morphTargetsVertex\";\nconst shader = `#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE \nvertexID=float(gl_VertexID)*morphTargetTextureInfo.x;\rpositionUpdated+=(readVector3FromRawSampler({X},vertexID)-position)*morphTargetInfluences[{X}];\rvertexID+=1.0;\r#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(readVector3FromRawSampler({X},vertexID) -normal)*morphTargetInfluences[{X}];\rvertexID+=1.0;\r#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(readVector3FromRawSampler({X},vertexID).xy-uv)*morphTargetInfluences[{X}];\rvertexID+=1.0;\r#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(readVector3FromRawSampler({X},vertexID) -tangent.xyz)*morphTargetInfluences[{X}];\r#endif\n#else\npositionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];\r#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];\r#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];\r#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];\r#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const morphTargetsVertex = { name, shader };\n//# sourceMappingURL=morphTargetsVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"morphTargetsVertexGlobal\";\nconst shader = `#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE\nfloat vertexID;\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const morphTargetsVertexGlobal = { name, shader };\n//# sourceMappingURL=morphTargetsVertexGlobal.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"instancesVertex\";\nconst shader = `#ifdef INSTANCES\nmat4 finalWorld=mat4(world0,world1,world2,world3);\r#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nmat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,previousWorld2,previousWorld3);\r#endif\n#ifdef THIN_INSTANCES\nfinalWorld=world*finalWorld;\r#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nfinalPreviousWorld=previousWorld*finalPreviousWorld;\r#endif\n#endif\n#else\nmat4 finalWorld=world;\r#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nmat4 finalPreviousWorld=previousWorld;\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const instancesVertex = { name, shader };\n//# sourceMappingURL=instancesVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"bonesVertex\";\nconst shader = `#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#if NUM_BONE_INFLUENCERS>0\nmat4 influence;\r#ifdef BONETEXTURE\ninfluence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];\r#if NUM_BONE_INFLUENCERS>1\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];\r#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];\r#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];\r#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];\r#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];\r#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];\r#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];\r#endif\n#else\ninfluence=mBones[int(matricesIndices[0])]*matricesWeights[0];\r#if NUM_BONE_INFLUENCERS>1\ninfluence+=mBones[int(matricesIndices[1])]*matricesWeights[1];\r#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=mBones[int(matricesIndices[2])]*matricesWeights[2];\r#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=mBones[int(matricesIndices[3])]*matricesWeights[3];\r#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\r#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\r#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\r#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\r#endif\n#endif\nfinalWorld=finalWorld*influence;\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bonesVertex = { name, shader };\n//# sourceMappingURL=bonesVertex.js.map","import { Matrix, Vector3, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { Light } from \"../../Lights/light.js\";\nimport { MaterialHelper } from \"../../Materials/materialHelper.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture.js\";\nimport { PostProcess } from \"../../PostProcesses/postProcess.js\";\nimport { BlurPostProcess } from \"../../PostProcesses/blurPostProcess.js\";\n\nimport { Observable } from \"../../Misc/observable.js\";\nimport { _WarnImport } from \"../../Misc/devTools.js\";\nimport { EffectFallbacks } from \"../../Materials/effectFallbacks.js\";\nimport { RenderingManager } from \"../../Rendering/renderingManager.js\";\nimport { DrawWrapper } from \"../../Materials/drawWrapper.js\";\nimport \"../../Shaders/shadowMap.fragment.js\";\nimport \"../../Shaders/shadowMap.vertex.js\";\nimport \"../../Shaders/depthBoxBlur.fragment.js\";\nimport \"../../Shaders/ShadersInclude/shadowMapFragmentSoftTransparentShadow.js\";\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"../../Materials/clipPlaneMaterialHelper.js\";\n/**\n * Default implementation IShadowGenerator.\n * This is the main object responsible of generating shadows in the framework.\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/shadows\n */\nexport class ShadowGenerator {\n    /**\n     * Gets the bias: offset applied on the depth preventing acnea (in light direction).\n     */\n    get bias() {\n        return this._bias;\n    }\n    /**\n     * Sets the bias: offset applied on the depth preventing acnea (in light direction).\n     */\n    set bias(bias) {\n        this._bias = bias;\n    }\n    /**\n     * Gets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportional to the light/normal angle).\n     */\n    get normalBias() {\n        return this._normalBias;\n    }\n    /**\n     * Sets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportional to the light/normal angle).\n     */\n    set normalBias(normalBias) {\n        this._normalBias = normalBias;\n    }\n    /**\n     * Gets the blur box offset: offset applied during the blur pass.\n     * Only useful if useKernelBlur = false\n     */\n    get blurBoxOffset() {\n        return this._blurBoxOffset;\n    }\n    /**\n     * Sets the blur box offset: offset applied during the blur pass.\n     * Only useful if useKernelBlur = false\n     */\n    set blurBoxOffset(value) {\n        if (this._blurBoxOffset === value) {\n            return;\n        }\n        this._blurBoxOffset = value;\n        this._disposeBlurPostProcesses();\n    }\n    /**\n     * Gets the blur scale: scale of the blurred texture compared to the main shadow map.\n     * 2 means half of the size.\n     */\n    get blurScale() {\n        return this._blurScale;\n    }\n    /**\n     * Sets the blur scale: scale of the blurred texture compared to the main shadow map.\n     * 2 means half of the size.\n     */\n    set blurScale(value) {\n        if (this._blurScale === value) {\n            return;\n        }\n        this._blurScale = value;\n        this._disposeBlurPostProcesses();\n    }\n    /**\n     * Gets the blur kernel: kernel size of the blur pass.\n     * Only useful if useKernelBlur = true\n     */\n    get blurKernel() {\n        return this._blurKernel;\n    }\n    /**\n     * Sets the blur kernel: kernel size of the blur pass.\n     * Only useful if useKernelBlur = true\n     */\n    set blurKernel(value) {\n        if (this._blurKernel === value) {\n            return;\n        }\n        this._blurKernel = value;\n        this._disposeBlurPostProcesses();\n    }\n    /**\n     * Gets whether the blur pass is a kernel blur (if true) or box blur.\n     * Only useful in filtered mode (useBlurExponentialShadowMap...)\n     */\n    get useKernelBlur() {\n        return this._useKernelBlur;\n    }\n    /**\n     * Sets whether the blur pass is a kernel blur (if true) or box blur.\n     * Only useful in filtered mode (useBlurExponentialShadowMap...)\n     */\n    set useKernelBlur(value) {\n        if (this._useKernelBlur === value) {\n            return;\n        }\n        this._useKernelBlur = value;\n        this._disposeBlurPostProcesses();\n    }\n    /**\n     * Gets the depth scale used in ESM mode.\n     */\n    get depthScale() {\n        return this._depthScale !== undefined ? this._depthScale : this._light.getDepthScale();\n    }\n    /**\n     * Sets the depth scale used in ESM mode.\n     * This can override the scale stored on the light.\n     */\n    set depthScale(value) {\n        this._depthScale = value;\n    }\n    _validateFilter(filter) {\n        return filter;\n    }\n    /**\n     * Gets the current mode of the shadow generator (normal, PCF, ESM...).\n     * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE\n     */\n    get filter() {\n        return this._filter;\n    }\n    /**\n     * Sets the current mode of the shadow generator (normal, PCF, ESM...).\n     * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE\n     */\n    set filter(value) {\n        value = this._validateFilter(value);\n        // Blurring the cubemap is going to be too expensive. Reverting to unblurred version\n        if (this._light.needCube()) {\n            if (value === ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP) {\n                this.useExponentialShadowMap = true;\n                return;\n            }\n            else if (value === ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {\n                this.useCloseExponentialShadowMap = true;\n                return;\n            }\n            // PCF on cubemap would also be expensive\n            else if (value === ShadowGenerator.FILTER_PCF || value === ShadowGenerator.FILTER_PCSS) {\n                this.usePoissonSampling = true;\n                return;\n            }\n        }\n        // Weblg1 fallback for PCF.\n        if (value === ShadowGenerator.FILTER_PCF || value === ShadowGenerator.FILTER_PCSS) {\n            if (!this._scene.getEngine()._features.supportShadowSamplers) {\n                this.usePoissonSampling = true;\n                return;\n            }\n        }\n        if (this._filter === value) {\n            return;\n        }\n        this._filter = value;\n        this._disposeBlurPostProcesses();\n        this._applyFilterValues();\n        this._light._markMeshesAsLightDirty();\n    }\n    /**\n     * Gets if the current filter is set to Poisson Sampling.\n     */\n    get usePoissonSampling() {\n        return this.filter === ShadowGenerator.FILTER_POISSONSAMPLING;\n    }\n    /**\n     * Sets the current filter to Poisson Sampling.\n     */\n    set usePoissonSampling(value) {\n        const filter = this._validateFilter(ShadowGenerator.FILTER_POISSONSAMPLING);\n        if (!value && this.filter !== ShadowGenerator.FILTER_POISSONSAMPLING) {\n            return;\n        }\n        this.filter = value ? filter : ShadowGenerator.FILTER_NONE;\n    }\n    /**\n     * Gets if the current filter is set to ESM.\n     */\n    get useExponentialShadowMap() {\n        return this.filter === ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP;\n    }\n    /**\n     * Sets the current filter is to ESM.\n     */\n    set useExponentialShadowMap(value) {\n        const filter = this._validateFilter(ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP);\n        if (!value && this.filter !== ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP) {\n            return;\n        }\n        this.filter = value ? filter : ShadowGenerator.FILTER_NONE;\n    }\n    /**\n     * Gets if the current filter is set to filtered ESM.\n     */\n    get useBlurExponentialShadowMap() {\n        return this.filter === ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP;\n    }\n    /**\n     * Gets if the current filter is set to filtered  ESM.\n     */\n    set useBlurExponentialShadowMap(value) {\n        const filter = this._validateFilter(ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP);\n        if (!value && this.filter !== ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP) {\n            return;\n        }\n        this.filter = value ? filter : ShadowGenerator.FILTER_NONE;\n    }\n    /**\n     * Gets if the current filter is set to \"close ESM\" (using the inverse of the\n     * exponential to prevent steep falloff artifacts).\n     */\n    get useCloseExponentialShadowMap() {\n        return this.filter === ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP;\n    }\n    /**\n     * Sets the current filter to \"close ESM\" (using the inverse of the\n     * exponential to prevent steep falloff artifacts).\n     */\n    set useCloseExponentialShadowMap(value) {\n        const filter = this._validateFilter(ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP);\n        if (!value && this.filter !== ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP) {\n            return;\n        }\n        this.filter = value ? filter : ShadowGenerator.FILTER_NONE;\n    }\n    /**\n     * Gets if the current filter is set to filtered \"close ESM\" (using the inverse of the\n     * exponential to prevent steep falloff artifacts).\n     */\n    get useBlurCloseExponentialShadowMap() {\n        return this.filter === ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP;\n    }\n    /**\n     * Sets the current filter to filtered \"close ESM\" (using the inverse of the\n     * exponential to prevent steep falloff artifacts).\n     */\n    set useBlurCloseExponentialShadowMap(value) {\n        const filter = this._validateFilter(ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP);\n        if (!value && this.filter !== ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {\n            return;\n        }\n        this.filter = value ? filter : ShadowGenerator.FILTER_NONE;\n    }\n    /**\n     * Gets if the current filter is set to \"PCF\" (percentage closer filtering).\n     */\n    get usePercentageCloserFiltering() {\n        return this.filter === ShadowGenerator.FILTER_PCF;\n    }\n    /**\n     * Sets the current filter to \"PCF\" (percentage closer filtering).\n     */\n    set usePercentageCloserFiltering(value) {\n        const filter = this._validateFilter(ShadowGenerator.FILTER_PCF);\n        if (!value && this.filter !== ShadowGenerator.FILTER_PCF) {\n            return;\n        }\n        this.filter = value ? filter : ShadowGenerator.FILTER_NONE;\n    }\n    /**\n     * Gets the PCF or PCSS Quality.\n     * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.\n     */\n    get filteringQuality() {\n        return this._filteringQuality;\n    }\n    /**\n     * Sets the PCF or PCSS Quality.\n     * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.\n     */\n    set filteringQuality(filteringQuality) {\n        if (this._filteringQuality === filteringQuality) {\n            return;\n        }\n        this._filteringQuality = filteringQuality;\n        this._disposeBlurPostProcesses();\n        this._applyFilterValues();\n        this._light._markMeshesAsLightDirty();\n    }\n    /**\n     * Gets if the current filter is set to \"PCSS\" (contact hardening).\n     */\n    get useContactHardeningShadow() {\n        return this.filter === ShadowGenerator.FILTER_PCSS;\n    }\n    /**\n     * Sets the current filter to \"PCSS\" (contact hardening).\n     */\n    set useContactHardeningShadow(value) {\n        const filter = this._validateFilter(ShadowGenerator.FILTER_PCSS);\n        if (!value && this.filter !== ShadowGenerator.FILTER_PCSS) {\n            return;\n        }\n        this.filter = value ? filter : ShadowGenerator.FILTER_NONE;\n    }\n    /**\n     * Gets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.\n     * Using a ratio helps keeping shape stability independently of the map size.\n     *\n     * It does not account for the light projection as it was having too much\n     * instability during the light setup or during light position changes.\n     *\n     * Only valid if useContactHardeningShadow is true.\n     */\n    get contactHardeningLightSizeUVRatio() {\n        return this._contactHardeningLightSizeUVRatio;\n    }\n    /**\n     * Sets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.\n     * Using a ratio helps keeping shape stability independently of the map size.\n     *\n     * It does not account for the light projection as it was having too much\n     * instability during the light setup or during light position changes.\n     *\n     * Only valid if useContactHardeningShadow is true.\n     */\n    set contactHardeningLightSizeUVRatio(contactHardeningLightSizeUVRatio) {\n        this._contactHardeningLightSizeUVRatio = contactHardeningLightSizeUVRatio;\n    }\n    /** Gets or sets the actual darkness of a shadow */\n    get darkness() {\n        return this._darkness;\n    }\n    set darkness(value) {\n        this.setDarkness(value);\n    }\n    /**\n     * Returns the darkness value (float). This can only decrease the actual darkness of a shadow.\n     * 0 means strongest and 1 would means no shadow.\n     * @returns the darkness.\n     */\n    getDarkness() {\n        return this._darkness;\n    }\n    /**\n     * Sets the darkness value (float). This can only decrease the actual darkness of a shadow.\n     * @param darkness The darkness value 0 means strongest and 1 would means no shadow.\n     * @returns the shadow generator allowing fluent coding.\n     */\n    setDarkness(darkness) {\n        if (darkness >= 1.0) {\n            this._darkness = 1.0;\n        }\n        else if (darkness <= 0.0) {\n            this._darkness = 0.0;\n        }\n        else {\n            this._darkness = darkness;\n        }\n        return this;\n    }\n    /** Gets or sets the ability to have transparent shadow  */\n    get transparencyShadow() {\n        return this._transparencyShadow;\n    }\n    set transparencyShadow(value) {\n        this.setTransparencyShadow(value);\n    }\n    /**\n     * Sets the ability to have transparent shadow (boolean).\n     * @param transparent True if transparent else False\n     * @returns the shadow generator allowing fluent coding\n     */\n    setTransparencyShadow(transparent) {\n        this._transparencyShadow = transparent;\n        return this;\n    }\n    /**\n     * Gets the main RTT containing the shadow map (usually storing depth from the light point of view).\n     * @returns The render target texture if present otherwise, null\n     */\n    getShadowMap() {\n        return this._shadowMap;\n    }\n    /**\n     * Gets the RTT used during rendering (can be a blurred version of the shadow map or the shadow map itself).\n     * @returns The render target texture if the shadow map is present otherwise, null\n     */\n    getShadowMapForRendering() {\n        if (this._shadowMap2) {\n            return this._shadowMap2;\n        }\n        return this._shadowMap;\n    }\n    /**\n     * Gets the class name of that object\n     * @returns \"ShadowGenerator\"\n     */\n    getClassName() {\n        return ShadowGenerator.CLASSNAME;\n    }\n    /**\n     * Helper function to add a mesh and its descendants to the list of shadow casters.\n     * @param mesh Mesh to add\n     * @param includeDescendants boolean indicating if the descendants should be added. Default to true\n     * @returns the Shadow Generator itself\n     */\n    addShadowCaster(mesh, includeDescendants = true) {\n        if (!this._shadowMap) {\n            return this;\n        }\n        if (!this._shadowMap.renderList) {\n            this._shadowMap.renderList = [];\n        }\n        if (this._shadowMap.renderList.indexOf(mesh) === -1) {\n            this._shadowMap.renderList.push(mesh);\n        }\n        if (includeDescendants) {\n            for (const childMesh of mesh.getChildMeshes()) {\n                if (this._shadowMap.renderList.indexOf(childMesh) === -1) {\n                    this._shadowMap.renderList.push(childMesh);\n                }\n            }\n        }\n        return this;\n    }\n    /**\n     * Helper function to remove a mesh and its descendants from the list of shadow casters\n     * @param mesh Mesh to remove\n     * @param includeDescendants boolean indicating if the descendants should be removed. Default to true\n     * @returns the Shadow Generator itself\n     */\n    removeShadowCaster(mesh, includeDescendants = true) {\n        if (!this._shadowMap || !this._shadowMap.renderList) {\n            return this;\n        }\n        const index = this._shadowMap.renderList.indexOf(mesh);\n        if (index !== -1) {\n            this._shadowMap.renderList.splice(index, 1);\n        }\n        if (includeDescendants) {\n            for (const child of mesh.getChildren()) {\n                this.removeShadowCaster(child);\n            }\n        }\n        return this;\n    }\n    /**\n     * Returns the associated light object.\n     * @returns the light generating the shadow\n     */\n    getLight() {\n        return this._light;\n    }\n    _getCamera() {\n        var _a;\n        return (_a = this._camera) !== null && _a !== void 0 ? _a : this._scene.activeCamera;\n    }\n    /**\n     * Gets or sets the size of the texture what stores the shadows\n     */\n    get mapSize() {\n        return this._mapSize;\n    }\n    set mapSize(size) {\n        this._mapSize = size;\n        this._light._markMeshesAsLightDirty();\n        this.recreateShadowMap();\n    }\n    /**\n     * Creates a ShadowGenerator object.\n     * A ShadowGenerator is the required tool to use the shadows.\n     * Each light casting shadows needs to use its own ShadowGenerator.\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/shadows\n     * @param mapSize The size of the texture what stores the shadows. Example : 1024.\n     * @param light The light object generating the shadows.\n     * @param usefullFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.\n     * @param camera Camera associated with this shadow generator (default: null). If null, takes the scene active camera at the time we need to access it\n     */\n    constructor(mapSize, light, usefullFloatFirst, camera) {\n        /**\n         * Observable triggered before the shadow is rendered. Can be used to update internal effect state\n         */\n        this.onBeforeShadowMapRenderObservable = new Observable();\n        /**\n         * Observable triggered after the shadow is rendered. Can be used to restore internal effect state\n         */\n        this.onAfterShadowMapRenderObservable = new Observable();\n        /**\n         * Observable triggered before a mesh is rendered in the shadow map.\n         * Can be used to update internal effect state (that you can get from the onBeforeShadowMapRenderObservable)\n         */\n        this.onBeforeShadowMapRenderMeshObservable = new Observable();\n        /**\n         * Observable triggered after a mesh is rendered in the shadow map.\n         * Can be used to update internal effect state (that you can get from the onAfterShadowMapRenderObservable)\n         */\n        this.onAfterShadowMapRenderMeshObservable = new Observable();\n        this._bias = 0.00005;\n        this._normalBias = 0;\n        this._blurBoxOffset = 1;\n        this._blurScale = 2;\n        this._blurKernel = 1;\n        this._useKernelBlur = false;\n        this._filter = ShadowGenerator.FILTER_NONE;\n        this._filteringQuality = ShadowGenerator.QUALITY_HIGH;\n        this._contactHardeningLightSizeUVRatio = 0.1;\n        this._darkness = 0;\n        this._transparencyShadow = false;\n        /**\n         * Enables or disables shadows with varying strength based on the transparency\n         * When it is enabled, the strength of the shadow is taken equal to mesh.visibility\n         * If you enabled an alpha texture on your material, the alpha value red from the texture is also combined to compute the strength:\n         *          mesh.visibility * alphaTexture.a\n         * The texture used is the diffuse by default, but it can be set to the opacity by setting useOpacityTextureForTransparentShadow\n         * Note that by definition transparencyShadow must be set to true for enableSoftTransparentShadow to work!\n         */\n        this.enableSoftTransparentShadow = false;\n        /**\n         * If this is true, use the opacity texture's alpha channel for transparent shadows instead of the diffuse one\n         */\n        this.useOpacityTextureForTransparentShadow = false;\n        /**\n         * Controls the extent to which the shadows fade out at the edge of the frustum\n         */\n        this.frustumEdgeFalloff = 0;\n        /**\n         * If true the shadow map is generated by rendering the back face of the mesh instead of the front face.\n         * This can help with self-shadowing as the geometry making up the back of objects is slightly offset.\n         * It might on the other hand introduce peter panning.\n         */\n        this.forceBackFacesOnly = false;\n        this._lightDirection = Vector3.Zero();\n        this._viewMatrix = Matrix.Zero();\n        this._projectionMatrix = Matrix.Zero();\n        this._transformMatrix = Matrix.Zero();\n        this._cachedPosition = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        this._cachedDirection = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        this._currentFaceIndex = 0;\n        this._currentFaceIndexCache = 0;\n        this._defaultTextureMatrix = Matrix.Identity();\n        this._mapSize = mapSize;\n        this._light = light;\n        this._scene = light.getScene();\n        this._camera = camera !== null && camera !== void 0 ? camera : null;\n        let shadowGenerators = light._shadowGenerators;\n        if (!shadowGenerators) {\n            shadowGenerators = light._shadowGenerators = new Map();\n        }\n        shadowGenerators.set(this._camera, this);\n        this.id = light.id;\n        this._useUBO = this._scene.getEngine().supportsUniformBuffers;\n        if (this._useUBO) {\n            this._sceneUBOs = [];\n            this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for Shadow Generator (light \"${this._light.name}\")`));\n        }\n        ShadowGenerator._SceneComponentInitialization(this._scene);\n        // Texture type fallback from float to int if not supported.\n        const caps = this._scene.getEngine().getCaps();\n        if (!usefullFloatFirst) {\n            if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\n                this._textureType = 2;\n            }\n            else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\n                this._textureType = 1;\n            }\n            else {\n                this._textureType = 0;\n            }\n        }\n        else {\n            if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\n                this._textureType = 1;\n            }\n            else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\n                this._textureType = 2;\n            }\n            else {\n                this._textureType = 0;\n            }\n        }\n        this._initializeGenerator();\n        this._applyFilterValues();\n    }\n    _initializeGenerator() {\n        this._light._markMeshesAsLightDirty();\n        this._initializeShadowMap();\n    }\n    _createTargetRenderTexture() {\n        const engine = this._scene.getEngine();\n        if (engine._features.supportDepthStencilTexture) {\n            this._shadowMap = new RenderTargetTexture(this._light.name + \"_shadowMap\", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube(), undefined, false, false);\n            this._shadowMap.createDepthStencilTexture(engine.useReverseDepthBuffer ? 516 : 513, true);\n        }\n        else {\n            this._shadowMap = new RenderTargetTexture(this._light.name + \"_shadowMap\", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube());\n        }\n    }\n    _initializeShadowMap() {\n        this._createTargetRenderTexture();\n        if (this._shadowMap === null) {\n            return;\n        }\n        this._shadowMap.wrapU = Texture.CLAMP_ADDRESSMODE;\n        this._shadowMap.wrapV = Texture.CLAMP_ADDRESSMODE;\n        this._shadowMap.anisotropicFilteringLevel = 1;\n        this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\n        this._shadowMap.renderParticles = false;\n        this._shadowMap.ignoreCameraViewport = true;\n        if (this._storedUniqueId) {\n            this._shadowMap.uniqueId = this._storedUniqueId;\n        }\n        // Custom render function.\n        this._shadowMap.customRenderFunction = this._renderForShadowMap.bind(this);\n        // Force the mesh is ready function to true as we are double checking it\n        // in the custom render function. Also it prevents side effects and useless\n        // shader variations in DEPTHPREPASS mode.\n        this._shadowMap.customIsReadyFunction = () => {\n            return true;\n        };\n        const engine = this._scene.getEngine();\n        this._shadowMap.onBeforeBindObservable.add(() => {\n            var _a;\n            this._currentSceneUBO = this._scene.getSceneUniformBuffer();\n            (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, `shadow map generation for pass id ${engine.currentRenderPassId}`, 1);\n        });\n        // Record Face Index before render.\n        this._shadowMap.onBeforeRenderObservable.add((faceIndex) => {\n            if (this._sceneUBOs) {\n                this._scene.setSceneUniformBuffer(this._sceneUBOs[0]);\n            }\n            this._currentFaceIndex = faceIndex;\n            if (this._filter === ShadowGenerator.FILTER_PCF) {\n                engine.setColorWrite(false);\n            }\n            this.getTransformMatrix(); // generate the view/projection matrix\n            this._scene.setTransformMatrix(this._viewMatrix, this._projectionMatrix);\n            if (this._useUBO) {\n                this._scene.getSceneUniformBuffer().unbindEffect();\n                this._scene.finalizeSceneUbo();\n            }\n        });\n        // Blur if required after render.\n        this._shadowMap.onAfterUnbindObservable.add(() => {\n            var _a, _b;\n            if (this._sceneUBOs) {\n                this._scene.setSceneUniformBuffer(this._currentSceneUBO);\n            }\n            this._scene.updateTransformMatrix(); // restore the view/projection matrices of the active camera\n            if (this._filter === ShadowGenerator.FILTER_PCF) {\n                engine.setColorWrite(true);\n            }\n            if (!this.useBlurExponentialShadowMap && !this.useBlurCloseExponentialShadowMap) {\n                (_a = engine._debugPopGroup) === null || _a === void 0 ? void 0 : _a.call(engine, 1);\n                return;\n            }\n            const shadowMap = this.getShadowMapForRendering();\n            if (shadowMap) {\n                this._scene.postProcessManager.directRender(this._blurPostProcesses, shadowMap.renderTarget, true);\n                engine.unBindFramebuffer(shadowMap.renderTarget, true);\n                (_b = engine._debugPopGroup) === null || _b === void 0 ? void 0 : _b.call(engine, 1);\n            }\n        });\n        // Clear according to the chosen filter.\n        const clearZero = new Color4(0, 0, 0, 0);\n        const clearOne = new Color4(1.0, 1.0, 1.0, 1.0);\n        this._shadowMap.onClearObservable.add((engine) => {\n            if (this._filter === ShadowGenerator.FILTER_PCF) {\n                engine.clear(clearOne, false, true, false);\n            }\n            else if (this.useExponentialShadowMap || this.useBlurExponentialShadowMap) {\n                engine.clear(clearZero, true, true, false);\n            }\n            else {\n                engine.clear(clearOne, true, true, false);\n            }\n        });\n        // Recreate on resize.\n        this._shadowMap.onResizeObservable.add((rtt) => {\n            this._storedUniqueId = this._shadowMap.uniqueId;\n            this._mapSize = rtt.getRenderSize();\n            this._light._markMeshesAsLightDirty();\n            this.recreateShadowMap();\n        });\n        // Ensures rendering groupids do not erase the depth buffer\n        // or we would lose the shadows information.\n        for (let i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {\n            this._shadowMap.setRenderingAutoClearDepthStencil(i, false);\n        }\n    }\n    _initializeBlurRTTAndPostProcesses() {\n        const engine = this._scene.getEngine();\n        const targetSize = this._mapSize / this.blurScale;\n        if (!this.useKernelBlur || this.blurScale !== 1.0) {\n            this._shadowMap2 = new RenderTargetTexture(this._light.name + \"_shadowMap2\", targetSize, this._scene, false, true, this._textureType, undefined, undefined, false);\n            this._shadowMap2.wrapU = Texture.CLAMP_ADDRESSMODE;\n            this._shadowMap2.wrapV = Texture.CLAMP_ADDRESSMODE;\n            this._shadowMap2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\n        }\n        if (this.useKernelBlur) {\n            this._kernelBlurXPostprocess = new BlurPostProcess(this._light.name + \"KernelBlurX\", new Vector2(1, 0), this.blurKernel, 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);\n            this._kernelBlurXPostprocess.width = targetSize;\n            this._kernelBlurXPostprocess.height = targetSize;\n            this._kernelBlurXPostprocess.externalTextureSamplerBinding = true;\n            this._kernelBlurXPostprocess.onApplyObservable.add((effect) => {\n                effect.setTexture(\"textureSampler\", this._shadowMap);\n            });\n            this._kernelBlurYPostprocess = new BlurPostProcess(this._light.name + \"KernelBlurY\", new Vector2(0, 1), this.blurKernel, 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);\n            this._kernelBlurXPostprocess.autoClear = false;\n            this._kernelBlurYPostprocess.autoClear = false;\n            if (this._textureType === 0) {\n                this._kernelBlurXPostprocess.packedFloat = true;\n                this._kernelBlurYPostprocess.packedFloat = true;\n            }\n            this._blurPostProcesses = [this._kernelBlurXPostprocess, this._kernelBlurYPostprocess];\n        }\n        else {\n            this._boxBlurPostprocess = new PostProcess(this._light.name + \"DepthBoxBlur\", \"depthBoxBlur\", [\"screenSize\", \"boxOffset\"], [], 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, \"#define OFFSET \" + this._blurBoxOffset, this._textureType);\n            this._boxBlurPostprocess.externalTextureSamplerBinding = true;\n            this._boxBlurPostprocess.onApplyObservable.add((effect) => {\n                effect.setFloat2(\"screenSize\", targetSize, targetSize);\n                effect.setTexture(\"textureSampler\", this._shadowMap);\n            });\n            this._boxBlurPostprocess.autoClear = false;\n            this._blurPostProcesses = [this._boxBlurPostprocess];\n        }\n    }\n    _renderForShadowMap(opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {\n        let index;\n        if (depthOnlySubMeshes.length) {\n            for (index = 0; index < depthOnlySubMeshes.length; index++) {\n                this._renderSubMeshForShadowMap(depthOnlySubMeshes.data[index]);\n            }\n        }\n        for (index = 0; index < opaqueSubMeshes.length; index++) {\n            this._renderSubMeshForShadowMap(opaqueSubMeshes.data[index]);\n        }\n        for (index = 0; index < alphaTestSubMeshes.length; index++) {\n            this._renderSubMeshForShadowMap(alphaTestSubMeshes.data[index]);\n        }\n        if (this._transparencyShadow) {\n            for (index = 0; index < transparentSubMeshes.length; index++) {\n                this._renderSubMeshForShadowMap(transparentSubMeshes.data[index], true);\n            }\n        }\n        else {\n            for (index = 0; index < transparentSubMeshes.length; index++) {\n                transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect, mesh) {\n        effect.setMatrix(\"viewProjection\", this.getTransformMatrix());\n    }\n    _renderSubMeshForShadowMap(subMesh, isTransparent = false) {\n        var _a, _b;\n        const renderingMesh = subMesh.getRenderingMesh();\n        const effectiveMesh = subMesh.getEffectiveMesh();\n        const scene = this._scene;\n        const engine = scene.getEngine();\n        const material = subMesh.getMaterial();\n        effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n        if (!material || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {\n            return;\n        }\n        // Culling\n        const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;\n        let sideOrientation = (_a = renderingMesh.overrideMaterialSideOrientation) !== null && _a !== void 0 ? _a : material.sideOrientation;\n        if (detNeg) {\n            sideOrientation =\n                sideOrientation === 0 ? 1 : 0;\n        }\n        const reverseSideOrientation = sideOrientation === 0;\n        engine.setState(material.backFaceCulling, undefined, undefined, reverseSideOrientation, material.cullBackFaces);\n        // Managing instances\n        const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n        if (batch.mustReturn) {\n            return;\n        }\n        const hardwareInstancedRendering = engine.getCaps().instancedArrays &&\n            ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || renderingMesh.hasThinInstances);\n        if (this.customAllowRendering && !this.customAllowRendering(subMesh)) {\n            return;\n        }\n        if (this.isReady(subMesh, hardwareInstancedRendering, isTransparent)) {\n            subMesh._renderId = scene.getRenderId();\n            const shadowDepthWrapper = material.shadowDepthWrapper;\n            const drawWrapper = (_b = shadowDepthWrapper === null || shadowDepthWrapper === void 0 ? void 0 : shadowDepthWrapper.getEffect(subMesh, this, engine.currentRenderPassId)) !== null && _b !== void 0 ? _b : subMesh._getDrawWrapper();\n            const effect = DrawWrapper.GetEffect(drawWrapper);\n            engine.enableEffect(drawWrapper);\n            if (!hardwareInstancedRendering) {\n                renderingMesh._bind(subMesh, effect, material.fillMode);\n            }\n            this.getTransformMatrix(); // make sure _cachedDirection et _cachedPosition are up to date\n            effect.setFloat3(\"biasAndScaleSM\", this.bias, this.normalBias, this.depthScale);\n            if (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {\n                effect.setVector3(\"lightDataSM\", this._cachedDirection);\n            }\n            else {\n                effect.setVector3(\"lightDataSM\", this._cachedPosition);\n            }\n            const camera = this._getCamera();\n            if (camera) {\n                effect.setFloat2(\"depthValuesSM\", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera));\n            }\n            if (isTransparent && this.enableSoftTransparentShadow) {\n                effect.setFloat(\"softTransparentShadowSM\", effectiveMesh.visibility * material.alpha);\n            }\n            if (shadowDepthWrapper) {\n                subMesh._setMainDrawWrapperOverride(drawWrapper);\n                if (shadowDepthWrapper.standalone) {\n                    shadowDepthWrapper.baseMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), renderingMesh, subMesh);\n                }\n                else {\n                    material.bindForSubMesh(effectiveMesh.getWorldMatrix(), renderingMesh, subMesh);\n                }\n                subMesh._setMainDrawWrapperOverride(null);\n            }\n            else {\n                // Alpha test\n                if (this._opacityTexture) {\n                    effect.setTexture(\"diffuseSampler\", this._opacityTexture);\n                    effect.setMatrix(\"diffuseMatrix\", this._opacityTexture.getTextureMatrix() || this._defaultTextureMatrix);\n                }\n                // Bones\n                if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n                    const skeleton = renderingMesh.skeleton;\n                    if (skeleton.isUsingTextureForMatrices) {\n                        const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\n                        if (!boneTexture) {\n                            return;\n                        }\n                        effect.setTexture(\"boneSampler\", boneTexture);\n                        effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n                    }\n                    else {\n                        effect.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\n                    }\n                }\n                // Morph targets\n                MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\n                if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n                    renderingMesh.morphTargetManager._bind(effect);\n                }\n                // Clip planes\n                bindClipPlane(effect, material, scene);\n            }\n            if (!this._useUBO && !shadowDepthWrapper) {\n                this._bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect, effectiveMesh);\n            }\n            MaterialHelper.BindSceneUniformBuffer(effect, this._scene.getSceneUniformBuffer());\n            this._scene.getSceneUniformBuffer().bindUniformBuffer();\n            const world = effectiveMesh.getWorldMatrix();\n            // In the non hardware instanced mode, the Mesh ubo update is done by the callback passed to renderingMesh._processRendering (see below)\n            if (hardwareInstancedRendering) {\n                effectiveMesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\n                effectiveMesh.transferToEffect(world);\n            }\n            if (this.forceBackFacesOnly) {\n                engine.setState(true, 0, false, true, material.cullBackFaces);\n            }\n            // Observables\n            this.onBeforeShadowMapRenderMeshObservable.notifyObservers(renderingMesh);\n            this.onBeforeShadowMapRenderObservable.notifyObservers(effect);\n            // Draw\n            renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, worldOverride) => {\n                if (effectiveMesh !== renderingMesh && !isInstance) {\n                    renderingMesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\n                    renderingMesh.transferToEffect(worldOverride);\n                }\n                else {\n                    effectiveMesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\n                    effectiveMesh.transferToEffect(isInstance ? worldOverride : world);\n                }\n            });\n            if (this.forceBackFacesOnly) {\n                engine.setState(true, 0, false, false, material.cullBackFaces);\n            }\n            // Observables\n            this.onAfterShadowMapRenderObservable.notifyObservers(effect);\n            this.onAfterShadowMapRenderMeshObservable.notifyObservers(renderingMesh);\n        }\n        else {\n            // Need to reset refresh rate of the shadowMap\n            if (this._shadowMap) {\n                this._shadowMap.resetRefreshCounter();\n            }\n        }\n    }\n    _applyFilterValues() {\n        if (!this._shadowMap) {\n            return;\n        }\n        if (this.filter === ShadowGenerator.FILTER_NONE || this.filter === ShadowGenerator.FILTER_PCSS) {\n            this._shadowMap.updateSamplingMode(Texture.NEAREST_SAMPLINGMODE);\n        }\n        else {\n            this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\n        }\n    }\n    /**\n     * Forces all the attached effect to compile to enable rendering only once ready vs. lazily compiling effects.\n     * @param onCompiled Callback triggered at the and of the effects compilation\n     * @param options Sets of optional options forcing the compilation with different modes\n     */\n    forceCompilation(onCompiled, options) {\n        const localOptions = {\n            useInstances: false,\n            ...options,\n        };\n        const shadowMap = this.getShadowMap();\n        if (!shadowMap) {\n            if (onCompiled) {\n                onCompiled(this);\n            }\n            return;\n        }\n        const renderList = shadowMap.renderList;\n        if (!renderList) {\n            if (onCompiled) {\n                onCompiled(this);\n            }\n            return;\n        }\n        const subMeshes = new Array();\n        for (const mesh of renderList) {\n            subMeshes.push(...mesh.subMeshes);\n        }\n        if (subMeshes.length === 0) {\n            if (onCompiled) {\n                onCompiled(this);\n            }\n            return;\n        }\n        let currentIndex = 0;\n        const checkReady = () => {\n            var _a, _b;\n            if (!this._scene || !this._scene.getEngine()) {\n                return;\n            }\n            while (this.isReady(subMeshes[currentIndex], localOptions.useInstances, (_b = (_a = subMeshes[currentIndex].getMaterial()) === null || _a === void 0 ? void 0 : _a.needAlphaBlendingForMesh(subMeshes[currentIndex].getMesh())) !== null && _b !== void 0 ? _b : false)) {\n                currentIndex++;\n                if (currentIndex >= subMeshes.length) {\n                    if (onCompiled) {\n                        onCompiled(this);\n                    }\n                    return;\n                }\n            }\n            setTimeout(checkReady, 16);\n        };\n        checkReady();\n    }\n    /**\n     * Forces all the attached effect to compile to enable rendering only once ready vs. lazily compiling effects.\n     * @param options Sets of optional options forcing the compilation with different modes\n     * @returns A promise that resolves when the compilation completes\n     */\n    forceCompilationAsync(options) {\n        return new Promise((resolve) => {\n            this.forceCompilation(() => {\n                resolve();\n            }, options);\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _isReadyCustomDefines(defines, subMesh, useInstances) { }\n    _prepareShadowDefines(subMesh, useInstances, defines, isTransparent) {\n        defines.push(\"#define SM_LIGHTTYPE_\" + this._light.getClassName().toUpperCase());\n        defines.push(\"#define SM_FLOAT \" + (this._textureType !== 0 ? \"1\" : \"0\"));\n        defines.push(\"#define SM_ESM \" + (this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? \"1\" : \"0\"));\n        defines.push(\"#define SM_DEPTHTEXTURE \" + (this.usePercentageCloserFiltering || this.useContactHardeningShadow ? \"1\" : \"0\"));\n        const mesh = subMesh.getMesh();\n        // Normal bias.\n        defines.push(\"#define SM_NORMALBIAS \" + (this.normalBias && mesh.isVerticesDataPresent(VertexBuffer.NormalKind) ? \"1\" : \"0\"));\n        defines.push(\"#define SM_DIRECTIONINLIGHTDATA \" + (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT ? \"1\" : \"0\"));\n        // Point light\n        defines.push(\"#define SM_USEDISTANCE \" + (this._light.needCube() ? \"1\" : \"0\"));\n        // Soft transparent shadows\n        defines.push(\"#define SM_SOFTTRANSPARENTSHADOW \" + (this.enableSoftTransparentShadow && isTransparent ? \"1\" : \"0\"));\n        this._isReadyCustomDefines(defines, subMesh, useInstances);\n        return defines;\n    }\n    /**\n     * Determine whether the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).\n     * @param subMesh The submesh we want to render in the shadow map\n     * @param useInstances Defines whether will draw in the map using instances\n     * @param isTransparent Indicates that isReady is called for a transparent subMesh\n     * @returns true if ready otherwise, false\n     */\n    isReady(subMesh, useInstances, isTransparent) {\n        var _a;\n        const material = subMesh.getMaterial(), shadowDepthWrapper = material === null || material === void 0 ? void 0 : material.shadowDepthWrapper;\n        this._opacityTexture = null;\n        if (!material) {\n            return false;\n        }\n        const defines = [];\n        this._prepareShadowDefines(subMesh, useInstances, defines, isTransparent);\n        if (shadowDepthWrapper) {\n            if (!shadowDepthWrapper.isReadyForSubMesh(subMesh, defines, this, useInstances, this._scene.getEngine().currentRenderPassId)) {\n                return false;\n            }\n        }\n        else {\n            const subMeshEffect = subMesh._getDrawWrapper(undefined, true);\n            let effect = subMeshEffect.effect;\n            let cachedDefines = subMeshEffect.defines;\n            const attribs = [VertexBuffer.PositionKind];\n            const mesh = subMesh.getMesh();\n            // Normal bias.\n            if (this.normalBias && mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n                attribs.push(VertexBuffer.NormalKind);\n                defines.push(\"#define NORMAL\");\n                if (mesh.nonUniformScaling) {\n                    defines.push(\"#define NONUNIFORMSCALING\");\n                }\n            }\n            // Alpha test\n            const needAlphaTesting = material.needAlphaTesting();\n            if (needAlphaTesting || material.needAlphaBlending()) {\n                if (this.useOpacityTextureForTransparentShadow) {\n                    this._opacityTexture = material.opacityTexture;\n                }\n                else {\n                    this._opacityTexture = material.getAlphaTestTexture();\n                }\n                if (this._opacityTexture) {\n                    if (!this._opacityTexture.isReady()) {\n                        return false;\n                    }\n                    const alphaCutOff = (_a = material.alphaCutOff) !== null && _a !== void 0 ? _a : ShadowGenerator.DEFAULT_ALPHA_CUTOFF;\n                    defines.push(\"#define ALPHATEXTURE\");\n                    if (needAlphaTesting) {\n                        defines.push(`#define ALPHATESTVALUE ${alphaCutOff}${alphaCutOff % 1 === 0 ? \".\" : \"\"}`);\n                    }\n                    if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n                        attribs.push(VertexBuffer.UVKind);\n                        defines.push(\"#define UV1\");\n                    }\n                    if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n                        if (this._opacityTexture.coordinatesIndex === 1) {\n                            attribs.push(VertexBuffer.UV2Kind);\n                            defines.push(\"#define UV2\");\n                        }\n                    }\n                }\n            }\n            // Bones\n            const fallbacks = new EffectFallbacks();\n            if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n                attribs.push(VertexBuffer.MatricesIndicesKind);\n                attribs.push(VertexBuffer.MatricesWeightsKind);\n                if (mesh.numBoneInfluencers > 4) {\n                    attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n                    attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n                }\n                const skeleton = mesh.skeleton;\n                defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n                if (mesh.numBoneInfluencers > 0) {\n                    fallbacks.addCPUSkinningFallback(0, mesh);\n                }\n                if (skeleton.isUsingTextureForMatrices) {\n                    defines.push(\"#define BONETEXTURE\");\n                }\n                else {\n                    defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\n                }\n            }\n            else {\n                defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n            }\n            // Morph targets\n            const manager = mesh.morphTargetManager;\n            let morphInfluencers = 0;\n            if (manager) {\n                if (manager.numInfluencers > 0) {\n                    defines.push(\"#define MORPHTARGETS\");\n                    morphInfluencers = manager.numInfluencers;\n                    defines.push(\"#define NUM_MORPH_INFLUENCERS \" + morphInfluencers);\n                    if (manager.isUsingTextureForTargets) {\n                        defines.push(\"#define MORPHTARGETS_TEXTURE\");\n                    }\n                    MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, morphInfluencers);\n                }\n            }\n            // ClipPlanes\n            prepareStringDefinesForClipPlanes(material, this._scene, defines);\n            // Instances\n            if (useInstances) {\n                defines.push(\"#define INSTANCES\");\n                MaterialHelper.PushAttributesForInstances(attribs);\n                if (subMesh.getRenderingMesh().hasThinInstances) {\n                    defines.push(\"#define THIN_INSTANCES\");\n                }\n            }\n            if (this.customShaderOptions) {\n                if (this.customShaderOptions.defines) {\n                    for (const define of this.customShaderOptions.defines) {\n                        if (defines.indexOf(define) === -1) {\n                            defines.push(define);\n                        }\n                    }\n                }\n            }\n            // Get correct effect\n            const join = defines.join(\"\\n\");\n            if (cachedDefines !== join) {\n                cachedDefines = join;\n                let shaderName = \"shadowMap\";\n                const uniforms = [\n                    \"world\",\n                    \"mBones\",\n                    \"viewProjection\",\n                    \"diffuseMatrix\",\n                    \"lightDataSM\",\n                    \"depthValuesSM\",\n                    \"biasAndScaleSM\",\n                    \"morphTargetInfluences\",\n                    \"boneTextureWidth\",\n                    \"softTransparentShadowSM\",\n                    \"morphTargetTextureInfo\",\n                    \"morphTargetTextureIndices\",\n                ];\n                const samplers = [\"diffuseSampler\", \"boneSampler\", \"morphTargets\"];\n                const uniformBuffers = [\"Scene\", \"Mesh\"];\n                addClipPlaneUniforms(uniforms);\n                // Custom shader?\n                if (this.customShaderOptions) {\n                    shaderName = this.customShaderOptions.shaderName;\n                    if (this.customShaderOptions.attributes) {\n                        for (const attrib of this.customShaderOptions.attributes) {\n                            if (attribs.indexOf(attrib) === -1) {\n                                attribs.push(attrib);\n                            }\n                        }\n                    }\n                    if (this.customShaderOptions.uniforms) {\n                        for (const uniform of this.customShaderOptions.uniforms) {\n                            if (uniforms.indexOf(uniform) === -1) {\n                                uniforms.push(uniform);\n                            }\n                        }\n                    }\n                    if (this.customShaderOptions.samplers) {\n                        for (const sampler of this.customShaderOptions.samplers) {\n                            if (samplers.indexOf(sampler) === -1) {\n                                samplers.push(sampler);\n                            }\n                        }\n                    }\n                }\n                const engine = this._scene.getEngine();\n                effect = engine.createEffect(shaderName, {\n                    attributes: attribs,\n                    uniformsNames: uniforms,\n                    uniformBuffersNames: uniformBuffers,\n                    samplers: samplers,\n                    defines: join,\n                    fallbacks: fallbacks,\n                    onCompiled: null,\n                    onError: null,\n                    indexParameters: { maxSimultaneousMorphTargets: morphInfluencers },\n                }, engine);\n                subMeshEffect.setEffect(effect, cachedDefines);\n            }\n            if (!effect.isReady()) {\n                return false;\n            }\n        }\n        if (this.useBlurExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {\n            if (!this._blurPostProcesses || !this._blurPostProcesses.length) {\n                this._initializeBlurRTTAndPostProcesses();\n            }\n        }\n        if (this._kernelBlurXPostprocess && !this._kernelBlurXPostprocess.isReady()) {\n            return false;\n        }\n        if (this._kernelBlurYPostprocess && !this._kernelBlurYPostprocess.isReady()) {\n            return false;\n        }\n        if (this._boxBlurPostprocess && !this._boxBlurPostprocess.isReady()) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Prepare all the defines in a material relying on a shadow map at the specified light index.\n     * @param defines Defines of the material we want to update\n     * @param lightIndex Index of the light in the enabled light list of the material\n     */\n    prepareDefines(defines, lightIndex) {\n        const scene = this._scene;\n        const light = this._light;\n        if (!scene.shadowsEnabled || !light.shadowEnabled) {\n            return;\n        }\n        defines[\"SHADOW\" + lightIndex] = true;\n        if (this.useContactHardeningShadow) {\n            defines[\"SHADOWPCSS\" + lightIndex] = true;\n            if (this._filteringQuality === ShadowGenerator.QUALITY_LOW) {\n                defines[\"SHADOWLOWQUALITY\" + lightIndex] = true;\n            }\n            else if (this._filteringQuality === ShadowGenerator.QUALITY_MEDIUM) {\n                defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = true;\n            }\n            // else default to high.\n        }\n        else if (this.usePercentageCloserFiltering) {\n            defines[\"SHADOWPCF\" + lightIndex] = true;\n            if (this._filteringQuality === ShadowGenerator.QUALITY_LOW) {\n                defines[\"SHADOWLOWQUALITY\" + lightIndex] = true;\n            }\n            else if (this._filteringQuality === ShadowGenerator.QUALITY_MEDIUM) {\n                defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = true;\n            }\n            // else default to high.\n        }\n        else if (this.usePoissonSampling) {\n            defines[\"SHADOWPOISSON\" + lightIndex] = true;\n        }\n        else if (this.useExponentialShadowMap || this.useBlurExponentialShadowMap) {\n            defines[\"SHADOWESM\" + lightIndex] = true;\n        }\n        else if (this.useCloseExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {\n            defines[\"SHADOWCLOSEESM\" + lightIndex] = true;\n        }\n        if (light.needCube()) {\n            defines[\"SHADOWCUBE\" + lightIndex] = true;\n        }\n    }\n    /**\n     * Binds the shadow related information inside of an effect (information like near, far, darkness...\n     * defined in the generator but impacting the effect).\n     * @param lightIndex Index of the light in the enabled light list of the material owning the effect\n     * @param effect The effect we are binding the information for\n     */\n    bindShadowLight(lightIndex, effect) {\n        const light = this._light;\n        const scene = this._scene;\n        if (!scene.shadowsEnabled || !light.shadowEnabled) {\n            return;\n        }\n        const camera = this._getCamera();\n        if (!camera) {\n            return;\n        }\n        const shadowMap = this.getShadowMap();\n        if (!shadowMap) {\n            return;\n        }\n        if (!light.needCube()) {\n            effect.setMatrix(\"lightMatrix\" + lightIndex, this.getTransformMatrix());\n        }\n        // Only PCF uses depth stencil texture.\n        if (this._filter === ShadowGenerator.FILTER_PCF) {\n            effect.setDepthStencilTexture(\"shadowSampler\" + lightIndex, this.getShadowMapForRendering());\n            light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), shadowMap.getSize().width, 1 / shadowMap.getSize().width, this.frustumEdgeFalloff, lightIndex);\n        }\n        else if (this._filter === ShadowGenerator.FILTER_PCSS) {\n            effect.setDepthStencilTexture(\"shadowSampler\" + lightIndex, this.getShadowMapForRendering());\n            effect.setTexture(\"depthSampler\" + lightIndex, this.getShadowMapForRendering());\n            light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), 1 / shadowMap.getSize().width, this._contactHardeningLightSizeUVRatio * shadowMap.getSize().width, this.frustumEdgeFalloff, lightIndex);\n        }\n        else {\n            effect.setTexture(\"shadowSampler\" + lightIndex, this.getShadowMapForRendering());\n            light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), this.blurScale / shadowMap.getSize().width, this.depthScale, this.frustumEdgeFalloff, lightIndex);\n        }\n        light._uniformBuffer.updateFloat2(\"depthValues\", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera), lightIndex);\n    }\n    /**\n     * Gets the transformation matrix used to project the meshes into the map from the light point of view.\n     * (eq to shadow projection matrix * light transform matrix)\n     * @returns The transform matrix used to create the shadow map\n     */\n    getTransformMatrix() {\n        const scene = this._scene;\n        if (this._currentRenderId === scene.getRenderId() && this._currentFaceIndexCache === this._currentFaceIndex) {\n            return this._transformMatrix;\n        }\n        this._currentRenderId = scene.getRenderId();\n        this._currentFaceIndexCache = this._currentFaceIndex;\n        let lightPosition = this._light.position;\n        if (this._light.computeTransformedInformation()) {\n            lightPosition = this._light.transformedPosition;\n        }\n        Vector3.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex), this._lightDirection);\n        if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1.0) {\n            this._lightDirection.z = 0.0000000000001; // Required to avoid perfectly perpendicular light\n        }\n        if (this._light.needProjectionMatrixCompute() ||\n            !this._cachedPosition ||\n            !this._cachedDirection ||\n            !lightPosition.equals(this._cachedPosition) ||\n            !this._lightDirection.equals(this._cachedDirection)) {\n            this._cachedPosition.copyFrom(lightPosition);\n            this._cachedDirection.copyFrom(this._lightDirection);\n            Matrix.LookAtLHToRef(lightPosition, lightPosition.add(this._lightDirection), Vector3.Up(), this._viewMatrix);\n            const shadowMap = this.getShadowMap();\n            if (shadowMap) {\n                const renderList = shadowMap.renderList;\n                if (renderList) {\n                    this._light.setShadowProjectionMatrix(this._projectionMatrix, this._viewMatrix, renderList);\n                }\n            }\n            this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);\n        }\n        return this._transformMatrix;\n    }\n    /**\n     * Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between\n     * Cube and 2D textures for instance.\n     */\n    recreateShadowMap() {\n        const shadowMap = this._shadowMap;\n        if (!shadowMap) {\n            return;\n        }\n        // Track render list.\n        const renderList = shadowMap.renderList;\n        // Clean up existing data.\n        this._disposeRTTandPostProcesses();\n        // Reinitializes.\n        this._initializeGenerator();\n        // Reaffect the filter to ensure a correct fallback if necessary.\n        this.filter = this._filter;\n        // Reaffect the filter.\n        this._applyFilterValues();\n        // Reaffect Render List.\n        if (renderList) {\n            // Note: don't do this._shadowMap!.renderList = renderList;\n            // The renderList hooked array is accessing the old RenderTargetTexture (see RenderTargetTexture._hookArray), which is disposed at this point (by the call to _disposeRTTandPostProcesses)\n            if (!this._shadowMap.renderList) {\n                this._shadowMap.renderList = [];\n            }\n            for (const mesh of renderList) {\n                this._shadowMap.renderList.push(mesh);\n            }\n        }\n        else {\n            this._shadowMap.renderList = null;\n        }\n    }\n    _disposeBlurPostProcesses() {\n        if (this._shadowMap2) {\n            this._shadowMap2.dispose();\n            this._shadowMap2 = null;\n        }\n        if (this._boxBlurPostprocess) {\n            this._boxBlurPostprocess.dispose();\n            this._boxBlurPostprocess = null;\n        }\n        if (this._kernelBlurXPostprocess) {\n            this._kernelBlurXPostprocess.dispose();\n            this._kernelBlurXPostprocess = null;\n        }\n        if (this._kernelBlurYPostprocess) {\n            this._kernelBlurYPostprocess.dispose();\n            this._kernelBlurYPostprocess = null;\n        }\n        this._blurPostProcesses = [];\n    }\n    _disposeRTTandPostProcesses() {\n        if (this._shadowMap) {\n            this._shadowMap.dispose();\n            this._shadowMap = null;\n        }\n        this._disposeBlurPostProcesses();\n    }\n    _disposeSceneUBOs() {\n        if (this._sceneUBOs) {\n            for (const ubo of this._sceneUBOs) {\n                ubo.dispose();\n            }\n            this._sceneUBOs = [];\n        }\n    }\n    /**\n     * Disposes the ShadowGenerator.\n     * Returns nothing.\n     */\n    dispose() {\n        this._disposeRTTandPostProcesses();\n        this._disposeSceneUBOs();\n        if (this._light) {\n            if (this._light._shadowGenerators) {\n                const iterator = this._light._shadowGenerators.entries();\n                for (let entry = iterator.next(); entry.done !== true; entry = iterator.next()) {\n                    const [camera, shadowGenerator] = entry.value;\n                    if (shadowGenerator === this) {\n                        this._light._shadowGenerators.delete(camera);\n                    }\n                }\n                if (this._light._shadowGenerators.size === 0) {\n                    this._light._shadowGenerators = null;\n                }\n            }\n            this._light._markMeshesAsLightDirty();\n        }\n        this.onBeforeShadowMapRenderMeshObservable.clear();\n        this.onBeforeShadowMapRenderObservable.clear();\n        this.onAfterShadowMapRenderMeshObservable.clear();\n        this.onAfterShadowMapRenderObservable.clear();\n    }\n    /**\n     * Serializes the shadow generator setup to a json object.\n     * @returns The serialized JSON object\n     */\n    serialize() {\n        var _a;\n        const serializationObject = {};\n        const shadowMap = this.getShadowMap();\n        if (!shadowMap) {\n            return serializationObject;\n        }\n        serializationObject.className = this.getClassName();\n        serializationObject.lightId = this._light.id;\n        serializationObject.cameraId = (_a = this._camera) === null || _a === void 0 ? void 0 : _a.id;\n        serializationObject.id = this.id;\n        serializationObject.mapSize = shadowMap.getRenderSize();\n        serializationObject.forceBackFacesOnly = this.forceBackFacesOnly;\n        serializationObject.darkness = this.getDarkness();\n        serializationObject.transparencyShadow = this._transparencyShadow;\n        serializationObject.frustumEdgeFalloff = this.frustumEdgeFalloff;\n        serializationObject.bias = this.bias;\n        serializationObject.normalBias = this.normalBias;\n        serializationObject.usePercentageCloserFiltering = this.usePercentageCloserFiltering;\n        serializationObject.useContactHardeningShadow = this.useContactHardeningShadow;\n        serializationObject.contactHardeningLightSizeUVRatio = this.contactHardeningLightSizeUVRatio;\n        serializationObject.filteringQuality = this.filteringQuality;\n        serializationObject.useExponentialShadowMap = this.useExponentialShadowMap;\n        serializationObject.useBlurExponentialShadowMap = this.useBlurExponentialShadowMap;\n        serializationObject.useCloseExponentialShadowMap = this.useBlurExponentialShadowMap;\n        serializationObject.useBlurCloseExponentialShadowMap = this.useBlurExponentialShadowMap;\n        serializationObject.usePoissonSampling = this.usePoissonSampling;\n        serializationObject.depthScale = this.depthScale;\n        serializationObject.blurBoxOffset = this.blurBoxOffset;\n        serializationObject.blurKernel = this.blurKernel;\n        serializationObject.blurScale = this.blurScale;\n        serializationObject.useKernelBlur = this.useKernelBlur;\n        serializationObject.renderList = [];\n        if (shadowMap.renderList) {\n            for (let meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {\n                const mesh = shadowMap.renderList[meshIndex];\n                serializationObject.renderList.push(mesh.id);\n            }\n        }\n        return serializationObject;\n    }\n    /**\n     * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.\n     * @param parsedShadowGenerator The JSON object to parse\n     * @param scene The scene to create the shadow map for\n     * @param constr A function that builds a shadow generator or undefined to create an instance of the default shadow generator\n     * @returns The parsed shadow generator\n     */\n    static Parse(parsedShadowGenerator, scene, constr) {\n        const light = scene.getLightById(parsedShadowGenerator.lightId);\n        const camera = parsedShadowGenerator.cameraId !== undefined ? scene.getCameraById(parsedShadowGenerator.cameraId) : null;\n        const shadowGenerator = constr ? constr(parsedShadowGenerator.mapSize, light, camera) : new ShadowGenerator(parsedShadowGenerator.mapSize, light, undefined, camera);\n        const shadowMap = shadowGenerator.getShadowMap();\n        for (let meshIndex = 0; meshIndex < parsedShadowGenerator.renderList.length; meshIndex++) {\n            const meshes = scene.getMeshesById(parsedShadowGenerator.renderList[meshIndex]);\n            meshes.forEach(function (mesh) {\n                if (!shadowMap) {\n                    return;\n                }\n                if (!shadowMap.renderList) {\n                    shadowMap.renderList = [];\n                }\n                shadowMap.renderList.push(mesh);\n            });\n        }\n        if (parsedShadowGenerator.id !== undefined) {\n            shadowGenerator.id = parsedShadowGenerator.id;\n        }\n        shadowGenerator.forceBackFacesOnly = !!parsedShadowGenerator.forceBackFacesOnly;\n        if (parsedShadowGenerator.darkness !== undefined) {\n            shadowGenerator.setDarkness(parsedShadowGenerator.darkness);\n        }\n        if (parsedShadowGenerator.transparencyShadow) {\n            shadowGenerator.setTransparencyShadow(true);\n        }\n        if (parsedShadowGenerator.frustumEdgeFalloff !== undefined) {\n            shadowGenerator.frustumEdgeFalloff = parsedShadowGenerator.frustumEdgeFalloff;\n        }\n        if (parsedShadowGenerator.bias !== undefined) {\n            shadowGenerator.bias = parsedShadowGenerator.bias;\n        }\n        if (parsedShadowGenerator.normalBias !== undefined) {\n            shadowGenerator.normalBias = parsedShadowGenerator.normalBias;\n        }\n        if (parsedShadowGenerator.usePercentageCloserFiltering) {\n            shadowGenerator.usePercentageCloserFiltering = true;\n        }\n        else if (parsedShadowGenerator.useContactHardeningShadow) {\n            shadowGenerator.useContactHardeningShadow = true;\n        }\n        else if (parsedShadowGenerator.usePoissonSampling) {\n            shadowGenerator.usePoissonSampling = true;\n        }\n        else if (parsedShadowGenerator.useExponentialShadowMap) {\n            shadowGenerator.useExponentialShadowMap = true;\n        }\n        else if (parsedShadowGenerator.useBlurExponentialShadowMap) {\n            shadowGenerator.useBlurExponentialShadowMap = true;\n        }\n        else if (parsedShadowGenerator.useCloseExponentialShadowMap) {\n            shadowGenerator.useCloseExponentialShadowMap = true;\n        }\n        else if (parsedShadowGenerator.useBlurCloseExponentialShadowMap) {\n            shadowGenerator.useBlurCloseExponentialShadowMap = true;\n        }\n        // Backward compat\n        else if (parsedShadowGenerator.useVarianceShadowMap) {\n            shadowGenerator.useExponentialShadowMap = true;\n        }\n        else if (parsedShadowGenerator.useBlurVarianceShadowMap) {\n            shadowGenerator.useBlurExponentialShadowMap = true;\n        }\n        if (parsedShadowGenerator.contactHardeningLightSizeUVRatio !== undefined) {\n            shadowGenerator.contactHardeningLightSizeUVRatio = parsedShadowGenerator.contactHardeningLightSizeUVRatio;\n        }\n        if (parsedShadowGenerator.filteringQuality !== undefined) {\n            shadowGenerator.filteringQuality = parsedShadowGenerator.filteringQuality;\n        }\n        if (parsedShadowGenerator.depthScale) {\n            shadowGenerator.depthScale = parsedShadowGenerator.depthScale;\n        }\n        if (parsedShadowGenerator.blurScale) {\n            shadowGenerator.blurScale = parsedShadowGenerator.blurScale;\n        }\n        if (parsedShadowGenerator.blurBoxOffset) {\n            shadowGenerator.blurBoxOffset = parsedShadowGenerator.blurBoxOffset;\n        }\n        if (parsedShadowGenerator.useKernelBlur) {\n            shadowGenerator.useKernelBlur = parsedShadowGenerator.useKernelBlur;\n        }\n        if (parsedShadowGenerator.blurKernel) {\n            shadowGenerator.blurKernel = parsedShadowGenerator.blurKernel;\n        }\n        return shadowGenerator;\n    }\n}\n/**\n * Name of the shadow generator class\n */\nShadowGenerator.CLASSNAME = \"ShadowGenerator\";\n/**\n * Shadow generator mode None: no filtering applied.\n */\nShadowGenerator.FILTER_NONE = 0;\n/**\n * Shadow generator mode ESM: Exponential Shadow Mapping.\n * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)\n */\nShadowGenerator.FILTER_EXPONENTIALSHADOWMAP = 1;\n/**\n * Shadow generator mode Poisson Sampling: Percentage Closer Filtering.\n * (Multiple Tap around evenly distributed around the pixel are used to evaluate the shadow strength)\n */\nShadowGenerator.FILTER_POISSONSAMPLING = 2;\n/**\n * Shadow generator mode ESM: Blurred Exponential Shadow Mapping.\n * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)\n */\nShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP = 3;\n/**\n * Shadow generator mode ESM: Exponential Shadow Mapping using the inverse of the exponential preventing\n * edge artifacts on steep falloff.\n * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)\n */\nShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP = 4;\n/**\n * Shadow generator mode ESM: Blurred Exponential Shadow Mapping using the inverse of the exponential preventing\n * edge artifacts on steep falloff.\n * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)\n */\nShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP = 5;\n/**\n * Shadow generator mode PCF: Percentage Closer Filtering\n * benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1\n * (https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html)\n */\nShadowGenerator.FILTER_PCF = 6;\n/**\n * Shadow generator mode PCSS: Percentage Closering Soft Shadow.\n * benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1\n * Contact Hardening\n */\nShadowGenerator.FILTER_PCSS = 7;\n/**\n * Reserved for PCF and PCSS\n * Highest Quality.\n *\n * Execute PCF on a 5*5 kernel improving a lot the shadow aliasing artifacts.\n *\n * Execute PCSS with 32 taps blocker search and 64 taps PCF.\n */\nShadowGenerator.QUALITY_HIGH = 0;\n/**\n * Reserved for PCF and PCSS\n * Good tradeoff for quality/perf cross devices\n *\n * Execute PCF on a 3*3 kernel.\n *\n * Execute PCSS with 16 taps blocker search and 32 taps PCF.\n */\nShadowGenerator.QUALITY_MEDIUM = 1;\n/**\n * Reserved for PCF and PCSS\n * The lowest quality but the fastest.\n *\n * Execute PCF on a 1*1 kernel.\n *\n * Execute PCSS with 16 taps blocker search and 16 taps PCF.\n */\nShadowGenerator.QUALITY_LOW = 2;\n/**\n * Defines the default alpha cutoff value used for transparent alpha tested materials.\n */\nShadowGenerator.DEFAULT_ALPHA_CUTOFF = 0.5;\n/**\n * @internal\n */\nShadowGenerator._SceneComponentInitialization = (_) => {\n    throw _WarnImport(\"ShadowGeneratorSceneComponent\");\n};\n//# sourceMappingURL=shadowGenerator.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration.js\";\nimport \"./ShadersInclude/packingFunctions.js\";\nimport \"./ShadersInclude/clipPlaneFragment.js\";\nconst name = \"depthPixelShader\";\nconst shader = `#ifdef ALPHATEST\nvarying vec2 vUV;\runiform sampler2D diffuseSampler;\r#endif\n#include<clipPlaneFragmentDeclaration>\nvarying float vDepthMetric;\r#ifdef PACKED\n#include<packingFunctions>\n#endif\n#ifdef STORE_CAMERASPACE_Z\nvarying vec4 vViewPos;\r#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\r{\r#include<clipPlaneFragment>\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\rdiscard;\r#endif\n#ifdef STORE_CAMERASPACE_Z\n#ifdef PACKED\ngl_FragColor=pack(vViewPos.z);\r#else\ngl_FragColor=vec4(vViewPos.z,0.0,0.0,1.0);\r#endif\n#else\n#ifdef NONLINEARDEPTH\n#ifdef PACKED\ngl_FragColor=pack(gl_FragCoord.z);\r#else\ngl_FragColor=vec4(gl_FragCoord.z,0.0,0.0,0.0);\r#endif\n#else\n#ifdef PACKED\ngl_FragColor=pack(vDepthMetric);\r#else\ngl_FragColor=vec4(vDepthMetric,0.0,0.0,1.0);\r#endif\n#endif\n#endif\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const depthPixelShader = { name, shader };\n//# sourceMappingURL=depth.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"instancesDeclaration\";\nconst shader = `#ifdef INSTANCES\nattribute vec4 world0;\rattribute vec4 world1;\rattribute vec4 world2;\rattribute vec4 world3;\r#ifdef INSTANCESCOLOR\nattribute vec4 instanceColor;\r#endif\n#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)\nuniform mat4 world;\r#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\nattribute vec4 previousWorld0;\rattribute vec4 previousWorld1;\rattribute vec4 previousWorld2;\rattribute vec4 previousWorld3;\r#ifdef THIN_INSTANCES\nuniform mat4 previousWorld;\r#endif\n#endif\n#else\n#if !defined(WORLD_UBO)\nuniform mat4 world;\r#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\nuniform mat4 previousWorld;\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const instancesDeclaration = { name, shader };\n//# sourceMappingURL=instancesDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/bonesDeclaration.js\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"./ShadersInclude/instancesDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal.js\";\nimport \"./ShadersInclude/morphTargetsVertex.js\";\nimport \"./ShadersInclude/instancesVertex.js\";\nimport \"./ShadersInclude/bonesVertex.js\";\nimport \"./ShadersInclude/bakedVertexAnimation.js\";\nimport \"./ShadersInclude/clipPlaneVertex.js\";\nconst name = \"depthVertexShader\";\nconst shader = `attribute vec3 position;\r#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<clipPlaneVertexDeclaration>\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\runiform vec2 depthValues;\r#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;\runiform mat4 diffuseMatrix;\r#ifdef UV1\nattribute vec2 uv;\r#endif\n#ifdef UV2\nattribute vec2 uv2;\r#endif\n#endif\n#ifdef STORE_CAMERASPACE_Z\nuniform mat4 view;\rvarying vec4 vViewPos;\r#endif\nvarying float vDepthMetric;\r#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\r{\rvec3 positionUpdated=position;\r#ifdef UV1\nvec2 uvUpdated=uv;\r#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\r#include<clipPlaneVertex>\ngl_Position=viewProjection*worldPos;\r#ifdef STORE_CAMERASPACE_Z\nvViewPos=view*worldPos;\r#else\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric=((-gl_Position.z+depthValues.x)/(depthValues.y));\r#else\nvDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));\r#endif\n#endif\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\r#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\r#endif\n#endif\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const depthVertexShader = { name, shader };\n//# sourceMappingURL=depth.vertex.js.map","import { Color4 } from \"../Maths/math.color.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport { Camera } from \"../Cameras/camera.js\";\n\nimport \"../Shaders/depth.fragment.js\";\nimport \"../Shaders/depth.vertex.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper.js\";\n/**\n * This represents a depth renderer in Babylon.\n * A depth renderer will render to it's depth map every frame which can be displayed or used in post processing\n */\nexport class DepthRenderer {\n    /**\n     * Sets a specific material to be used to render a mesh/a list of meshes by the depth renderer\n     * @param mesh mesh or array of meshes\n     * @param material material to use by the depth render when rendering the mesh(es). If undefined is passed, the specific material created by the depth renderer will be used.\n     */\n    setMaterialForRendering(mesh, material) {\n        this._depthMap.setMaterialForRendering(mesh, material);\n    }\n    /**\n     * Instantiates a depth renderer\n     * @param scene The scene the renderer belongs to\n     * @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)\n     * @param camera The camera to be used to render the depth map (default: scene's active camera)\n     * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z\n     * @param samplingMode The sampling mode to be used with the render target (Linear, Nearest...) (default: TRILINEAR_SAMPLINGMODE)\n     * @param storeCameraSpaceZ Defines whether the depth stored is the Z coordinate in camera space. If true, storeNonLinearDepth has no effect. (Default: false)\n     * @param name Name of the render target (default: DepthRenderer)\n     */\n    constructor(scene, type = 1, camera = null, storeNonLinearDepth = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, storeCameraSpaceZ = false, name) {\n        /** Enable or disable the depth renderer. When disabled, the depth texture is not updated */\n        this.enabled = true;\n        /** Force writing the transparent objects into the depth map */\n        this.forceDepthWriteTransparentMeshes = false;\n        /**\n         * Specifies that the depth renderer will only be used within\n         * the camera it is created for.\n         * This can help forcing its rendering during the camera processing.\n         */\n        this.useOnlyInActiveCamera = false;\n        /** If true, reverse the culling of materials before writing to the depth texture.\n         * So, basically, when \"true\", back facing instead of front facing faces are rasterized into the texture\n         */\n        this.reverseCulling = false;\n        this._scene = scene;\n        this._storeNonLinearDepth = storeNonLinearDepth;\n        this._storeCameraSpaceZ = storeCameraSpaceZ;\n        this.isPacked = type === 0;\n        if (this.isPacked) {\n            this.clearColor = new Color4(1.0, 1.0, 1.0, 1.0);\n        }\n        else {\n            this.clearColor = new Color4(storeCameraSpaceZ ? 1e8 : 1.0, 0.0, 0.0, 1.0);\n        }\n        DepthRenderer._SceneComponentInitialization(this._scene);\n        const engine = scene.getEngine();\n        this._camera = camera;\n        if (samplingMode !== Texture.NEAREST_SAMPLINGMODE) {\n            if (type === 1 && !engine._caps.textureFloatLinearFiltering) {\n                samplingMode = Texture.NEAREST_SAMPLINGMODE;\n            }\n            if (type === 2 && !engine._caps.textureHalfFloatLinearFiltering) {\n                samplingMode = Texture.NEAREST_SAMPLINGMODE;\n            }\n        }\n        // Render target\n        const format = this.isPacked || !engine._features.supportExtendedTextureFormats ? 5 : 6;\n        this._depthMap = new RenderTargetTexture(name !== null && name !== void 0 ? name : \"DepthRenderer\", { width: engine.getRenderWidth(), height: engine.getRenderHeight() }, this._scene, false, true, type, false, samplingMode, undefined, undefined, undefined, format);\n        this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;\n        this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;\n        this._depthMap.refreshRate = 1;\n        this._depthMap.renderParticles = false;\n        this._depthMap.renderList = null;\n        // Camera to get depth map from to support multiple concurrent cameras\n        this._depthMap.activeCamera = this._camera;\n        this._depthMap.ignoreCameraViewport = true;\n        this._depthMap.useCameraPostProcesses = false;\n        // set default depth value to 1.0 (far away)\n        this._depthMap.onClearObservable.add((engine) => {\n            engine.clear(this.clearColor, true, true, true);\n        });\n        this._depthMap.onBeforeBindObservable.add(() => {\n            var _a;\n            (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, \"depth renderer\", 1);\n        });\n        this._depthMap.onAfterUnbindObservable.add(() => {\n            var _a;\n            (_a = engine._debugPopGroup) === null || _a === void 0 ? void 0 : _a.call(engine, 1);\n        });\n        this._depthMap.customIsReadyFunction = (mesh, refreshRate, preWarm) => {\n            if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\n                for (let i = 0; i < mesh.subMeshes.length; ++i) {\n                    const subMesh = mesh.subMeshes[i];\n                    const renderingMesh = subMesh.getRenderingMesh();\n                    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n                    const hardwareInstancedRendering = engine.getCaps().instancedArrays &&\n                        ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || renderingMesh.hasThinInstances);\n                    if (!this.isReady(subMesh, hardwareInstancedRendering)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        // Custom render function\n        const renderSubMesh = (subMesh) => {\n            var _a, _b;\n            const renderingMesh = subMesh.getRenderingMesh();\n            const effectiveMesh = subMesh.getEffectiveMesh();\n            const scene = this._scene;\n            const engine = scene.getEngine();\n            const material = subMesh.getMaterial();\n            effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n            if (!material || effectiveMesh.infiniteDistance || material.disableDepthWrite || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {\n                return;\n            }\n            // Culling\n            const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;\n            let sideOrientation = (_a = renderingMesh.overrideMaterialSideOrientation) !== null && _a !== void 0 ? _a : material.sideOrientation;\n            if (detNeg) {\n                sideOrientation =\n                    sideOrientation === 0\n                        ? 1\n                        : 0;\n            }\n            const reverseSideOrientation = sideOrientation === 0;\n            engine.setState(material.backFaceCulling, 0, false, reverseSideOrientation, this.reverseCulling ? !material.cullBackFaces : material.cullBackFaces);\n            // Managing instances\n            const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n            if (batch.mustReturn) {\n                return;\n            }\n            const hardwareInstancedRendering = engine.getCaps().instancedArrays &&\n                ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || renderingMesh.hasThinInstances);\n            const camera = this._camera || scene.activeCamera;\n            if (this.isReady(subMesh, hardwareInstancedRendering) && camera) {\n                subMesh._renderId = scene.getRenderId();\n                const renderingMaterial = (_b = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _b === void 0 ? void 0 : _b[engine.currentRenderPassId];\n                let drawWrapper = subMesh._getDrawWrapper();\n                if (!drawWrapper && renderingMaterial) {\n                    drawWrapper = renderingMaterial._getDrawWrapper();\n                }\n                const cameraIsOrtho = camera.mode === Camera.ORTHOGRAPHIC_CAMERA;\n                if (!drawWrapper) {\n                    return;\n                }\n                const effect = drawWrapper.effect;\n                engine.enableEffect(drawWrapper);\n                if (!hardwareInstancedRendering) {\n                    renderingMesh._bind(subMesh, effect, material.fillMode);\n                }\n                if (!renderingMaterial) {\n                    effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n                    effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\n                    if (this._storeCameraSpaceZ) {\n                        effect.setMatrix(\"view\", scene.getViewMatrix());\n                    }\n                }\n                else {\n                    renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);\n                }\n                let minZ, maxZ;\n                if (cameraIsOrtho) {\n                    minZ = !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n                    maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n                }\n                else {\n                    minZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? camera.minZ : engine.isNDCHalfZRange ? 0 : camera.minZ;\n                    maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : camera.maxZ;\n                }\n                effect.setFloat2(\"depthValues\", minZ, minZ + maxZ);\n                if (!renderingMaterial) {\n                    // Alpha test\n                    if (material.needAlphaTesting()) {\n                        const alphaTexture = material.getAlphaTestTexture();\n                        if (alphaTexture) {\n                            effect.setTexture(\"diffuseSampler\", alphaTexture);\n                            effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n                        }\n                    }\n                    // Bones\n                    if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n                        const skeleton = renderingMesh.skeleton;\n                        if (skeleton.isUsingTextureForMatrices) {\n                            const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\n                            if (!boneTexture) {\n                                return;\n                            }\n                            effect.setTexture(\"boneSampler\", boneTexture);\n                            effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n                        }\n                        else {\n                            effect.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\n                        }\n                    }\n                    // Clip planes\n                    bindClipPlane(effect, material, scene);\n                    // Morph targets\n                    MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\n                    if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n                        renderingMesh.morphTargetManager._bind(effect);\n                    }\n                }\n                // Draw\n                renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) => effect.setMatrix(\"world\", world));\n            }\n        };\n        this._depthMap.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {\n            let index;\n            if (depthOnlySubMeshes.length) {\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\n                    renderSubMesh(depthOnlySubMeshes.data[index]);\n                }\n            }\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\n                renderSubMesh(opaqueSubMeshes.data[index]);\n            }\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\n                renderSubMesh(alphaTestSubMeshes.data[index]);\n            }\n            if (this.forceDepthWriteTransparentMeshes) {\n                for (index = 0; index < transparentSubMeshes.length; index++) {\n                    renderSubMesh(transparentSubMeshes.data[index]);\n                }\n            }\n            else {\n                for (index = 0; index < transparentSubMeshes.length; index++) {\n                    transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n                }\n            }\n        };\n    }\n    /**\n     * Creates the depth rendering effect and checks if the effect is ready.\n     * @param subMesh The submesh to be used to render the depth map of\n     * @param useInstances If multiple world instances should be used\n     * @returns if the depth renderer is ready to render the depth map\n     */\n    isReady(subMesh, useInstances) {\n        var _a;\n        const engine = this._scene.getEngine();\n        const mesh = subMesh.getMesh();\n        const scene = mesh.getScene();\n        const renderingMaterial = (_a = mesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[engine.currentRenderPassId];\n        if (renderingMaterial) {\n            return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\n        }\n        const material = subMesh.getMaterial();\n        if (!material || material.disableDepthWrite) {\n            return false;\n        }\n        const defines = [];\n        const attribs = [VertexBuffer.PositionKind];\n        // Alpha test\n        if (material && material.needAlphaTesting() && material.getAlphaTestTexture()) {\n            defines.push(\"#define ALPHATEST\");\n            if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n                attribs.push(VertexBuffer.UVKind);\n                defines.push(\"#define UV1\");\n            }\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n                attribs.push(VertexBuffer.UV2Kind);\n                defines.push(\"#define UV2\");\n            }\n        }\n        // Bones\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\n            attribs.push(VertexBuffer.MatricesIndicesKind);\n            attribs.push(VertexBuffer.MatricesWeightsKind);\n            if (mesh.numBoneInfluencers > 4) {\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n            }\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n            defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n            const skeleton = subMesh.getRenderingMesh().skeleton;\n            if (skeleton === null || skeleton === void 0 ? void 0 : skeleton.isUsingTextureForMatrices) {\n                defines.push(\"#define BONETEXTURE\");\n            }\n        }\n        else {\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n        }\n        // Morph targets\n        const morphTargetManager = mesh.morphTargetManager;\n        let numMorphInfluencers = 0;\n        if (morphTargetManager) {\n            if (morphTargetManager.numInfluencers > 0) {\n                numMorphInfluencers = morphTargetManager.numInfluencers;\n                defines.push(\"#define MORPHTARGETS\");\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\n                if (morphTargetManager.isUsingTextureForTargets) {\n                    defines.push(\"#define MORPHTARGETS_TEXTURE\");\n                }\n                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\n            }\n        }\n        // Instances\n        if (useInstances) {\n            defines.push(\"#define INSTANCES\");\n            MaterialHelper.PushAttributesForInstances(attribs);\n            if (subMesh.getRenderingMesh().hasThinInstances) {\n                defines.push(\"#define THIN_INSTANCES\");\n            }\n        }\n        // None linear depth\n        if (this._storeNonLinearDepth) {\n            defines.push(\"#define NONLINEARDEPTH\");\n        }\n        // Store camera space Z coordinate instead of NDC Z\n        if (this._storeCameraSpaceZ) {\n            defines.push(\"#define STORE_CAMERASPACE_Z\");\n        }\n        // Float Mode\n        if (this.isPacked) {\n            defines.push(\"#define PACKED\");\n        }\n        // Clip planes\n        prepareStringDefinesForClipPlanes(material, scene, defines);\n        // Get correct effect\n        const drawWrapper = subMesh._getDrawWrapper(undefined, true);\n        const cachedDefines = drawWrapper.defines;\n        const join = defines.join(\"\\n\");\n        if (cachedDefines !== join) {\n            const uniforms = [\n                \"world\",\n                \"mBones\",\n                \"boneTextureWidth\",\n                \"viewProjection\",\n                \"view\",\n                \"diffuseMatrix\",\n                \"depthValues\",\n                \"morphTargetInfluences\",\n                \"morphTargetTextureInfo\",\n                \"morphTargetTextureIndices\",\n            ];\n            addClipPlaneUniforms(uniforms);\n            drawWrapper.setEffect(engine.createEffect(\"depth\", attribs, uniforms, [\"diffuseSampler\", \"morphTargets\", \"boneSampler\"], join, undefined, undefined, undefined, {\n                maxSimultaneousMorphTargets: numMorphInfluencers,\n            }), join);\n        }\n        return drawWrapper.effect.isReady();\n    }\n    /**\n     * Gets the texture which the depth map will be written to.\n     * @returns The depth map texture\n     */\n    getDepthMap() {\n        return this._depthMap;\n    }\n    /**\n     * Disposes of the depth renderer.\n     */\n    dispose() {\n        const keysToDelete = [];\n        for (const key in this._scene._depthRenderer) {\n            const depthRenderer = this._scene._depthRenderer[key];\n            if (depthRenderer === this) {\n                keysToDelete.push(key);\n            }\n        }\n        if (keysToDelete.length > 0) {\n            this._depthMap.dispose();\n            for (const key of keysToDelete) {\n                delete this._scene._depthRenderer[key];\n            }\n        }\n    }\n}\n/**\n * @internal\n */\nDepthRenderer._SceneComponentInitialization = (_) => {\n    throw _WarnImport(\"DepthRendererSceneComponent\");\n};\n//# sourceMappingURL=depthRenderer.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"minmaxReduxPixelShader\";\nconst shader = `varying vec2 vUV;\runiform sampler2D textureSampler;\r#if defined(INITIAL)\nuniform sampler2D sourceTexture;\runiform vec2 texSize;\rvoid main(void)\r{\rivec2 coord=ivec2(vUV*(texSize-1.0));\rfloat f1=texelFetch(sourceTexture,coord,0).r;\rfloat f2=texelFetch(sourceTexture,coord+ivec2(1,0),0).r;\rfloat f3=texelFetch(sourceTexture,coord+ivec2(1,1),0).r;\rfloat f4=texelFetch(sourceTexture,coord+ivec2(0,1),0).r;\rfloat minz=min(min(min(f1,f2),f3),f4);\r#ifdef DEPTH_REDUX\nfloat maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);\r#else\nfloat maxz=max(max(max(f1,f2),f3),f4);\r#endif\nglFragColor=vec4(minz,maxz,0.,0.);\r}\r#elif defined(MAIN)\nuniform vec2 texSize;\rvoid main(void)\r{\rivec2 coord=ivec2(vUV*(texSize-1.0));\rvec2 f1=texelFetch(textureSampler,coord,0).rg;\rvec2 f2=texelFetch(textureSampler,coord+ivec2(1,0),0).rg;\rvec2 f3=texelFetch(textureSampler,coord+ivec2(1,1),0).rg;\rvec2 f4=texelFetch(textureSampler,coord+ivec2(0,1),0).rg;\rfloat minz=min(min(min(f1.x,f2.x),f3.x),f4.x);\rfloat maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);\rglFragColor=vec4(minz,maxz,0.,0.);\r}\r#elif defined(ONEBEFORELAST)\nuniform ivec2 texSize;\rvoid main(void)\r{\rivec2 coord=ivec2(vUV*vec2(texSize-1));\rvec2 f1=texelFetch(textureSampler,coord % texSize,0).rg;\rvec2 f2=texelFetch(textureSampler,(coord+ivec2(1,0)) % texSize,0).rg;\rvec2 f3=texelFetch(textureSampler,(coord+ivec2(1,1)) % texSize,0).rg;\rvec2 f4=texelFetch(textureSampler,(coord+ivec2(0,1)) % texSize,0).rg;\rfloat minz=min(f1.x,f2.x);\rfloat maxz=max(f1.y,f2.y);\rglFragColor=vec4(minz,maxz,0.,0.);\r}\r#elif defined(LAST)\nvoid main(void)\r{\rglFragColor=vec4(0.);\rif (true) { \rdiscard;\r}\r}\r#endif\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const minmaxReduxPixelShader = { name, shader };\n//# sourceMappingURL=minmaxRedux.fragment.js.map","\nimport { Observable } from \"./observable.js\";\nimport { PostProcess } from \"../PostProcesses/postProcess.js\";\nimport { PostProcessManager } from \"../PostProcesses/postProcessManager.js\";\nimport \"../Shaders/minmaxRedux.fragment.js\";\n/**\n * This class computes a min/max reduction from a texture: it means it computes the minimum\n * and maximum values from all values of the texture.\n * It is performed on the GPU for better performances, thanks to a succession of post processes.\n * The source values are read from the red channel of the texture.\n */\nexport class MinMaxReducer {\n    /**\n     * Creates a min/max reducer\n     * @param camera The camera to use for the post processes\n     */\n    constructor(camera) {\n        /**\n         * Observable triggered when the computation has been performed\n         */\n        this.onAfterReductionPerformed = new Observable();\n        this._forceFullscreenViewport = true;\n        this._activated = false;\n        this._camera = camera;\n        this._postProcessManager = new PostProcessManager(camera.getScene());\n        this._onContextRestoredObserver = camera.getEngine().onContextRestoredObservable.add(() => {\n            this._postProcessManager._rebuild();\n        });\n    }\n    /**\n     * Gets the texture used to read the values from.\n     */\n    get sourceTexture() {\n        return this._sourceTexture;\n    }\n    /**\n     * Sets the source texture to read the values from.\n     * One must indicate if the texture is a depth texture or not through the depthRedux parameter\n     * because in such textures '1' value must not be taken into account to compute the maximum\n     * as this value is used to clear the texture.\n     * Note that the computation is not activated by calling this function, you must call activate() for that!\n     * @param sourceTexture The texture to read the values from. The values should be in the red channel.\n     * @param depthRedux Indicates if the texture is a depth texture or not\n     * @param type The type of the textures created for the reduction (defaults to TEXTURETYPE_HALF_FLOAT)\n     * @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)\n     */\n    setSourceTexture(sourceTexture, depthRedux, type = 2, forceFullscreenViewport = true) {\n        if (sourceTexture === this._sourceTexture) {\n            return;\n        }\n        this.dispose(false);\n        this._sourceTexture = sourceTexture;\n        this._reductionSteps = [];\n        this._forceFullscreenViewport = forceFullscreenViewport;\n        const scene = this._camera.getScene();\n        // create the first step\n        const reductionInitial = new PostProcess(\"Initial reduction phase\", \"minmaxRedux\", // shader\n        [\"texSize\"], [\"sourceTexture\"], // textures\n        1.0, // options\n        null, // camera\n        1, // sampling\n        scene.getEngine(), // engine\n        false, // reusable\n        \"#define INITIAL\" + (depthRedux ? \"\\n#define DEPTH_REDUX\" : \"\"), // defines\n        type, undefined, undefined, undefined, 7);\n        reductionInitial.autoClear = false;\n        reductionInitial.forceFullscreenViewport = forceFullscreenViewport;\n        let w = this._sourceTexture.getRenderWidth(), h = this._sourceTexture.getRenderHeight();\n        reductionInitial.onApply = ((w, h) => {\n            return (effect) => {\n                effect.setTexture(\"sourceTexture\", this._sourceTexture);\n                effect.setFloat2(\"texSize\", w, h);\n            };\n        })(w, h);\n        this._reductionSteps.push(reductionInitial);\n        let index = 1;\n        // create the additional steps\n        while (w > 1 || h > 1) {\n            w = Math.max(Math.round(w / 2), 1);\n            h = Math.max(Math.round(h / 2), 1);\n            const reduction = new PostProcess(\"Reduction phase \" + index, \"minmaxRedux\", // shader\n            [\"texSize\"], null, { width: w, height: h }, // options\n            null, // camera\n            1, // sampling\n            scene.getEngine(), // engine\n            false, // reusable\n            \"#define \" + (w == 1 && h == 1 ? \"LAST\" : w == 1 || h == 1 ? \"ONEBEFORELAST\" : \"MAIN\"), // defines\n            type, undefined, undefined, undefined, 7);\n            reduction.autoClear = false;\n            reduction.forceFullscreenViewport = forceFullscreenViewport;\n            reduction.onApply = ((w, h) => {\n                return (effect) => {\n                    if (w == 1 || h == 1) {\n                        effect.setInt2(\"texSize\", w, h);\n                    }\n                    else {\n                        effect.setFloat2(\"texSize\", w, h);\n                    }\n                };\n            })(w, h);\n            this._reductionSteps.push(reduction);\n            index++;\n            if (w == 1 && h == 1) {\n                const func = (w, h, reduction) => {\n                    const buffer = new Float32Array(4 * w * h), minmax = { min: 0, max: 0 };\n                    return () => {\n                        scene.getEngine()._readTexturePixels(reduction.inputTexture.texture, w, h, -1, 0, buffer, false);\n                        minmax.min = buffer[0];\n                        minmax.max = buffer[1];\n                        this.onAfterReductionPerformed.notifyObservers(minmax);\n                    };\n                };\n                reduction.onAfterRenderObservable.add(func(w, h, reduction));\n            }\n        }\n    }\n    /**\n     * Defines the refresh rate of the computation.\n     * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...\n     */\n    get refreshRate() {\n        return this._sourceTexture ? this._sourceTexture.refreshRate : -1;\n    }\n    set refreshRate(value) {\n        if (this._sourceTexture) {\n            this._sourceTexture.refreshRate = value;\n        }\n    }\n    /**\n     * Gets the activation status of the reducer\n     */\n    get activated() {\n        return this._activated;\n    }\n    /**\n     * Activates the reduction computation.\n     * When activated, the observers registered in onAfterReductionPerformed are\n     * called after the computation is performed\n     */\n    activate() {\n        if (this._onAfterUnbindObserver || !this._sourceTexture) {\n            return;\n        }\n        this._onAfterUnbindObserver = this._sourceTexture.onAfterUnbindObservable.add(() => {\n            var _a, _b;\n            const engine = this._camera.getScene().getEngine();\n            (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, `min max reduction`, 1);\n            this._reductionSteps[0].activate(this._camera);\n            this._postProcessManager.directRender(this._reductionSteps, this._reductionSteps[0].inputTexture, this._forceFullscreenViewport);\n            engine.unBindFramebuffer(this._reductionSteps[0].inputTexture, false);\n            (_b = engine._debugPopGroup) === null || _b === void 0 ? void 0 : _b.call(engine, 1);\n        });\n        this._activated = true;\n    }\n    /**\n     * Deactivates the reduction computation.\n     */\n    deactivate() {\n        if (!this._onAfterUnbindObserver || !this._sourceTexture) {\n            return;\n        }\n        this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);\n        this._onAfterUnbindObserver = null;\n        this._activated = false;\n    }\n    /**\n     * Disposes the min/max reducer\n     * @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.\n     */\n    dispose(disposeAll = true) {\n        if (disposeAll) {\n            this.onAfterReductionPerformed.clear();\n            if (this._onContextRestoredObserver) {\n                this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);\n                this._onContextRestoredObserver = null;\n            }\n        }\n        this.deactivate();\n        if (this._reductionSteps) {\n            for (let i = 0; i < this._reductionSteps.length; ++i) {\n                this._reductionSteps[i].dispose();\n            }\n            this._reductionSteps = null;\n        }\n        if (this._postProcessManager && disposeAll) {\n            this._postProcessManager.dispose();\n        }\n        this._sourceTexture = null;\n    }\n}\n//# sourceMappingURL=minMaxReducer.js.map","\nimport { DepthRenderer } from \"../Rendering/depthRenderer.js\";\nimport { MinMaxReducer } from \"./minMaxReducer.js\";\n/**\n * This class is a small wrapper around the MinMaxReducer class to compute the min/max values of a depth texture\n */\nexport class DepthReducer extends MinMaxReducer {\n    /**\n     * Gets the depth renderer used for the computation.\n     * Note that the result is null if you provide your own renderer when calling setDepthRenderer.\n     */\n    get depthRenderer() {\n        return this._depthRenderer;\n    }\n    /**\n     * Creates a depth reducer\n     * @param camera The camera used to render the depth texture\n     */\n    constructor(camera) {\n        super(camera);\n    }\n    /**\n     * Sets the depth renderer to use to generate the depth map\n     * @param depthRenderer The depth renderer to use. If not provided, a new one will be created automatically\n     * @param type The texture type of the depth map (default: TEXTURETYPE_HALF_FLOAT)\n     * @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)\n     */\n    setDepthRenderer(depthRenderer = null, type = 2, forceFullscreenViewport = true) {\n        const scene = this._camera.getScene();\n        if (this._depthRenderer) {\n            delete scene._depthRenderer[this._depthRendererId];\n            this._depthRenderer.dispose();\n            this._depthRenderer = null;\n        }\n        if (depthRenderer === null) {\n            if (!scene._depthRenderer) {\n                scene._depthRenderer = {};\n            }\n            depthRenderer = this._depthRenderer = new DepthRenderer(scene, type, this._camera, false, 1);\n            depthRenderer.enabled = false;\n            this._depthRendererId = \"minmax\" + this._camera.id;\n            scene._depthRenderer[this._depthRendererId] = depthRenderer;\n        }\n        super.setSourceTexture(depthRenderer.getDepthMap(), true, type, forceFullscreenViewport);\n    }\n    /**\n     * @internal\n     */\n    setSourceTexture(sourceTexture, depthRedux, type = 2, forceFullscreenViewport = true) {\n        super.setSourceTexture(sourceTexture, depthRedux, type, forceFullscreenViewport);\n    }\n    /**\n     * Activates the reduction computation.\n     * When activated, the observers registered in onAfterReductionPerformed are\n     * called after the computation is performed\n     */\n    activate() {\n        if (this._depthRenderer) {\n            this._depthRenderer.enabled = true;\n        }\n        super.activate();\n    }\n    /**\n     * Deactivates the reduction computation.\n     */\n    deactivate() {\n        super.deactivate();\n        if (this._depthRenderer) {\n            this._depthRenderer.enabled = false;\n        }\n    }\n    /**\n     * Disposes the depth reducer\n     * @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.\n     */\n    dispose(disposeAll = true) {\n        super.dispose(disposeAll);\n        if (this._depthRenderer && disposeAll) {\n            const scene = this._depthRenderer.getDepthMap().getScene();\n            if (scene) {\n                delete scene._depthRenderer[this._depthRendererId];\n            }\n            this._depthRenderer.dispose();\n            this._depthRenderer = null;\n        }\n    }\n}\n//# sourceMappingURL=depthReducer.js.map","import { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture.js\";\n\nimport \"../../Shaders/shadowMap.fragment.js\";\nimport \"../../Shaders/shadowMap.vertex.js\";\nimport \"../../Shaders/depthBoxBlur.fragment.js\";\nimport { _WarnImport } from \"../../Misc/devTools.js\";\nimport { ShadowGenerator } from \"./shadowGenerator.js\";\nimport { BoundingInfo } from \"../../Culling/boundingInfo.js\";\nimport { DepthReducer } from \"../../Misc/depthReducer.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst UpDir = Vector3.Up();\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst ZeroVec = Vector3.Zero();\nconst tmpv1 = new Vector3(), tmpv2 = new Vector3(), tmpMatrix = new Matrix();\n/**\n * A CSM implementation allowing casting shadows on large scenes.\n * Documentation : https://doc.babylonjs.com/babylon101/cascadedShadows\n * Based on: https://github.com/TheRealMJP/Shadows and https://johanmedestrom.wordpress.com/2016/03/18/opengl-cascaded-shadow-maps/\n */\nexport class CascadedShadowGenerator extends ShadowGenerator {\n    _validateFilter(filter) {\n        if (filter === ShadowGenerator.FILTER_NONE || filter === ShadowGenerator.FILTER_PCF || filter === ShadowGenerator.FILTER_PCSS) {\n            return filter;\n        }\n        console.error('Unsupported filter \"' + filter + '\"!');\n        return ShadowGenerator.FILTER_NONE;\n    }\n    /**\n     * Gets or set the number of cascades used by the CSM.\n     */\n    get numCascades() {\n        return this._numCascades;\n    }\n    set numCascades(value) {\n        value = Math.min(Math.max(value, CascadedShadowGenerator.MIN_CASCADES_COUNT), CascadedShadowGenerator.MAX_CASCADES_COUNT);\n        if (value === this._numCascades) {\n            return;\n        }\n        this._numCascades = value;\n        this.recreateShadowMap();\n        this._recreateSceneUBOs();\n    }\n    /**\n     * Enables or disables the shadow casters bounding info computation.\n     * If your shadow casters don't move, you can disable this feature.\n     * If it is enabled, the bounding box computation is done every frame.\n     */\n    get freezeShadowCastersBoundingInfo() {\n        return this._freezeShadowCastersBoundingInfo;\n    }\n    set freezeShadowCastersBoundingInfo(freeze) {\n        if (this._freezeShadowCastersBoundingInfoObservable && freeze) {\n            this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);\n            this._freezeShadowCastersBoundingInfoObservable = null;\n        }\n        if (!this._freezeShadowCastersBoundingInfoObservable && !freeze) {\n            this._freezeShadowCastersBoundingInfoObservable = this._scene.onBeforeRenderObservable.add(this._computeShadowCastersBoundingInfo.bind(this));\n        }\n        this._freezeShadowCastersBoundingInfo = freeze;\n        if (freeze) {\n            this._computeShadowCastersBoundingInfo();\n        }\n    }\n    _computeShadowCastersBoundingInfo() {\n        this._scbiMin.copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        this._scbiMax.copyFromFloats(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);\n        if (this._shadowMap && this._shadowMap.renderList) {\n            const renderList = this._shadowMap.renderList;\n            for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {\n                const mesh = renderList[meshIndex];\n                if (!mesh) {\n                    continue;\n                }\n                const boundingInfo = mesh.getBoundingInfo(), boundingBox = boundingInfo.boundingBox;\n                this._scbiMin.minimizeInPlace(boundingBox.minimumWorld);\n                this._scbiMax.maximizeInPlace(boundingBox.maximumWorld);\n            }\n            const meshes = this._scene.meshes;\n            for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\n                const mesh = meshes[meshIndex];\n                if (!mesh || !mesh.isVisible || !mesh.isEnabled || !mesh.receiveShadows) {\n                    continue;\n                }\n                const boundingInfo = mesh.getBoundingInfo(), boundingBox = boundingInfo.boundingBox;\n                this._scbiMin.minimizeInPlace(boundingBox.minimumWorld);\n                this._scbiMax.maximizeInPlace(boundingBox.maximumWorld);\n            }\n        }\n        this._shadowCastersBoundingInfo.reConstruct(this._scbiMin, this._scbiMax);\n    }\n    /**\n     * Gets or sets the shadow casters bounding info.\n     * If you provide your own shadow casters bounding info, first enable freezeShadowCastersBoundingInfo\n     * so that the system won't overwrite the bounds you provide\n     */\n    get shadowCastersBoundingInfo() {\n        return this._shadowCastersBoundingInfo;\n    }\n    set shadowCastersBoundingInfo(boundingInfo) {\n        this._shadowCastersBoundingInfo = boundingInfo;\n    }\n    /**\n     * Sets the minimal and maximal distances to use when computing the cascade breaks.\n     *\n     * The values of min / max are typically the depth zmin and zmax values of your scene, for a given frame.\n     * If you don't know these values, simply leave them to their defaults and don't call this function.\n     * @param min minimal distance for the breaks (default to 0.)\n     * @param max maximal distance for the breaks (default to 1.)\n     */\n    setMinMaxDistance(min, max) {\n        if (this._minDistance === min && this._maxDistance === max) {\n            return;\n        }\n        if (min > max) {\n            min = 0;\n            max = 1;\n        }\n        if (min < 0) {\n            min = 0;\n        }\n        if (max > 1) {\n            max = 1;\n        }\n        this._minDistance = min;\n        this._maxDistance = max;\n        this._breaksAreDirty = true;\n    }\n    /** Gets the minimal distance used in the cascade break computation */\n    get minDistance() {\n        return this._minDistance;\n    }\n    /** Gets the maximal distance used in the cascade break computation */\n    get maxDistance() {\n        return this._maxDistance;\n    }\n    /**\n     * Gets the class name of that object\n     * @returns \"CascadedShadowGenerator\"\n     */\n    getClassName() {\n        return CascadedShadowGenerator.CLASSNAME;\n    }\n    /**\n     * Gets a cascade minimum extents\n     * @param cascadeIndex index of the cascade\n     * @returns the minimum cascade extents\n     */\n    getCascadeMinExtents(cascadeIndex) {\n        return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMinExtents[cascadeIndex] : null;\n    }\n    /**\n     * Gets a cascade maximum extents\n     * @param cascadeIndex index of the cascade\n     * @returns the maximum cascade extents\n     */\n    getCascadeMaxExtents(cascadeIndex) {\n        return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMaxExtents[cascadeIndex] : null;\n    }\n    /**\n     * Gets the shadow max z distance. It's the limit beyond which shadows are not displayed.\n     * It defaults to camera.maxZ\n     */\n    get shadowMaxZ() {\n        if (!this._getCamera()) {\n            return 0;\n        }\n        return this._shadowMaxZ;\n    }\n    /**\n     * Sets the shadow max z distance.\n     */\n    set shadowMaxZ(value) {\n        const camera = this._getCamera();\n        if (!camera) {\n            this._shadowMaxZ = value;\n            return;\n        }\n        if (this._shadowMaxZ === value || value < camera.minZ || value > camera.maxZ) {\n            return;\n        }\n        this._shadowMaxZ = value;\n        this._light._markMeshesAsLightDirty();\n        this._breaksAreDirty = true;\n    }\n    /**\n     * Gets or sets the debug flag.\n     * When enabled, the cascades are materialized by different colors on the screen.\n     */\n    get debug() {\n        return this._debug;\n    }\n    set debug(dbg) {\n        this._debug = dbg;\n        this._light._markMeshesAsLightDirty();\n    }\n    /**\n     * Gets or sets the depth clamping value.\n     *\n     * When enabled, it improves the shadow quality because the near z plane of the light frustum don't need to be adjusted\n     * to account for the shadow casters far away.\n     *\n     * Note that this property is incompatible with PCSS filtering, so it won't be used in that case.\n     */\n    get depthClamp() {\n        return this._depthClamp;\n    }\n    set depthClamp(value) {\n        this._depthClamp = value;\n    }\n    /**\n     * Gets or sets the percentage of blending between two cascades (value between 0. and 1.).\n     * It defaults to 0.1 (10% blending).\n     */\n    get cascadeBlendPercentage() {\n        return this._cascadeBlendPercentage;\n    }\n    set cascadeBlendPercentage(value) {\n        this._cascadeBlendPercentage = value;\n        this._light._markMeshesAsLightDirty();\n    }\n    /**\n     * Gets or set the lambda parameter.\n     * This parameter is used to split the camera frustum and create the cascades.\n     * It's a value between 0. and 1.: If 0, the split is a uniform split of the frustum, if 1 it is a logarithmic split.\n     * For all values in-between, it's a linear combination of the uniform and logarithm split algorithm.\n     */\n    get lambda() {\n        return this._lambda;\n    }\n    set lambda(value) {\n        const lambda = Math.min(Math.max(value, 0), 1);\n        if (this._lambda == lambda) {\n            return;\n        }\n        this._lambda = lambda;\n        this._breaksAreDirty = true;\n    }\n    /**\n     * Gets the view matrix corresponding to a given cascade\n     * @param cascadeNum cascade to retrieve the view matrix from\n     * @returns the cascade view matrix\n     */\n    getCascadeViewMatrix(cascadeNum) {\n        return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._viewMatrices[cascadeNum] : null;\n    }\n    /**\n     * Gets the projection matrix corresponding to a given cascade\n     * @param cascadeNum cascade to retrieve the projection matrix from\n     * @returns the cascade projection matrix\n     */\n    getCascadeProjectionMatrix(cascadeNum) {\n        return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._projectionMatrices[cascadeNum] : null;\n    }\n    /**\n     * Gets the transformation matrix corresponding to a given cascade\n     * @param cascadeNum cascade to retrieve the transformation matrix from\n     * @returns the cascade transformation matrix\n     */\n    getCascadeTransformMatrix(cascadeNum) {\n        return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._transformMatrices[cascadeNum] : null;\n    }\n    /**\n     * Sets the depth renderer to use when autoCalcDepthBounds is enabled.\n     *\n     * Note that if no depth renderer is set, a new one will be automatically created internally when necessary.\n     *\n     * You should call this function if you already have a depth renderer enabled in your scene, to avoid\n     * doing multiple depth rendering each frame. If you provide your own depth renderer, make sure it stores linear depth!\n     * @param depthRenderer The depth renderer to use when autoCalcDepthBounds is enabled. If you pass null or don't call this function at all, a depth renderer will be automatically created\n     */\n    setDepthRenderer(depthRenderer) {\n        this._depthRenderer = depthRenderer;\n        if (this._depthReducer) {\n            this._depthReducer.setDepthRenderer(this._depthRenderer);\n        }\n    }\n    /**\n     * Gets or sets the autoCalcDepthBounds property.\n     *\n     * When enabled, a depth rendering pass is first performed (with an internally created depth renderer or with the one\n     * you provide by calling setDepthRenderer). Then, a min/max reducing is applied on the depth map to compute the\n     * minimal and maximal depth of the map and those values are used as inputs for the setMinMaxDistance() function.\n     * It can greatly enhance the shadow quality, at the expense of more GPU works.\n     * When using this option, you should increase the value of the lambda parameter, and even set it to 1 for best results.\n     */\n    get autoCalcDepthBounds() {\n        return this._autoCalcDepthBounds;\n    }\n    set autoCalcDepthBounds(value) {\n        const camera = this._getCamera();\n        if (!camera) {\n            return;\n        }\n        this._autoCalcDepthBounds = value;\n        if (!value) {\n            if (this._depthReducer) {\n                this._depthReducer.deactivate();\n            }\n            this.setMinMaxDistance(0, 1);\n            return;\n        }\n        if (!this._depthReducer) {\n            this._depthReducer = new DepthReducer(camera);\n            this._depthReducer.onAfterReductionPerformed.add((minmax) => {\n                let min = minmax.min, max = minmax.max;\n                if (min >= max) {\n                    min = 0;\n                    max = 1;\n                }\n                if (min != this._minDistance || max != this._maxDistance) {\n                    this.setMinMaxDistance(min, max);\n                }\n            });\n            this._depthReducer.setDepthRenderer(this._depthRenderer);\n        }\n        this._depthReducer.activate();\n    }\n    /**\n     * Defines the refresh rate of the min/max computation used when autoCalcDepthBounds is set to true\n     * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...\n     * Note that if you provided your own depth renderer through a call to setDepthRenderer, you are responsible\n     * for setting the refresh rate on the renderer yourself!\n     */\n    get autoCalcDepthBoundsRefreshRate() {\n        var _a, _b, _c;\n        return (_c = (_b = (_a = this._depthReducer) === null || _a === void 0 ? void 0 : _a.depthRenderer) === null || _b === void 0 ? void 0 : _b.getDepthMap().refreshRate) !== null && _c !== void 0 ? _c : -1;\n    }\n    set autoCalcDepthBoundsRefreshRate(value) {\n        var _a;\n        if ((_a = this._depthReducer) === null || _a === void 0 ? void 0 : _a.depthRenderer) {\n            this._depthReducer.depthRenderer.getDepthMap().refreshRate = value;\n        }\n    }\n    /**\n     * Create the cascade breaks according to the lambda, shadowMaxZ and min/max distance properties, as well as the camera near and far planes.\n     * This function is automatically called when updating lambda, shadowMaxZ and min/max distances, however you should call it yourself if\n     * you change the camera near/far planes!\n     */\n    splitFrustum() {\n        this._breaksAreDirty = true;\n    }\n    _splitFrustum() {\n        const camera = this._getCamera();\n        if (!camera) {\n            return;\n        }\n        const near = camera.minZ, far = camera.maxZ, cameraRange = far - near, minDistance = this._minDistance, maxDistance = this._shadowMaxZ < far && this._shadowMaxZ >= near ? Math.min((this._shadowMaxZ - near) / (far - near), this._maxDistance) : this._maxDistance;\n        const minZ = near + minDistance * cameraRange, maxZ = near + maxDistance * cameraRange;\n        const range = maxZ - minZ, ratio = maxZ / minZ;\n        for (let cascadeIndex = 0; cascadeIndex < this._cascades.length; ++cascadeIndex) {\n            const p = (cascadeIndex + 1) / this._numCascades, log = minZ * ratio ** p, uniform = minZ + range * p;\n            const d = this._lambda * (log - uniform) + uniform;\n            this._cascades[cascadeIndex].prevBreakDistance = cascadeIndex === 0 ? minDistance : this._cascades[cascadeIndex - 1].breakDistance;\n            this._cascades[cascadeIndex].breakDistance = (d - near) / cameraRange;\n            this._viewSpaceFrustumsZ[cascadeIndex] = d;\n            this._frustumLengths[cascadeIndex] = (this._cascades[cascadeIndex].breakDistance - this._cascades[cascadeIndex].prevBreakDistance) * cameraRange;\n        }\n        this._breaksAreDirty = false;\n    }\n    _computeMatrices() {\n        const scene = this._scene;\n        const camera = this._getCamera();\n        if (!camera) {\n            return;\n        }\n        Vector3.NormalizeToRef(this._light.getShadowDirection(0), this._lightDirection);\n        if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1.0) {\n            this._lightDirection.z = 0.0000000000001; // Required to avoid perfectly perpendicular light\n        }\n        this._cachedDirection.copyFrom(this._lightDirection);\n        const useReverseDepthBuffer = scene.getEngine().useReverseDepthBuffer;\n        for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {\n            this._computeFrustumInWorldSpace(cascadeIndex);\n            this._computeCascadeFrustum(cascadeIndex);\n            this._cascadeMaxExtents[cascadeIndex].subtractToRef(this._cascadeMinExtents[cascadeIndex], tmpv1); // tmpv1 = cascadeExtents\n            // Get position of the shadow camera\n            this._frustumCenter[cascadeIndex].addToRef(this._lightDirection.scale(this._cascadeMinExtents[cascadeIndex].z), this._shadowCameraPos[cascadeIndex]);\n            // Come up with a new orthographic camera for the shadow caster\n            Matrix.LookAtLHToRef(this._shadowCameraPos[cascadeIndex], this._frustumCenter[cascadeIndex], UpDir, this._viewMatrices[cascadeIndex]);\n            let minZ = 0, maxZ = tmpv1.z;\n            // Try to tighten minZ and maxZ based on the bounding box of the shadow casters\n            const boundingInfo = this._shadowCastersBoundingInfo;\n            boundingInfo.update(this._viewMatrices[cascadeIndex]);\n            maxZ = Math.min(maxZ, boundingInfo.boundingBox.maximumWorld.z);\n            if (!this._depthClamp || this.filter === ShadowGenerator.FILTER_PCSS) {\n                // If we don't use depth clamping, we must set minZ so that all shadow casters are in the light frustum\n                minZ = Math.min(minZ, boundingInfo.boundingBox.minimumWorld.z);\n            }\n            else {\n                // If using depth clamping, we can adjust minZ to reduce the [minZ, maxZ] range (and get some additional precision in the shadow map)\n                minZ = Math.max(minZ, boundingInfo.boundingBox.minimumWorld.z);\n            }\n            Matrix.OrthoOffCenterLHToRef(this._cascadeMinExtents[cascadeIndex].x, this._cascadeMaxExtents[cascadeIndex].x, this._cascadeMinExtents[cascadeIndex].y, this._cascadeMaxExtents[cascadeIndex].y, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, this._projectionMatrices[cascadeIndex], scene.getEngine().isNDCHalfZRange);\n            this._cascadeMinExtents[cascadeIndex].z = minZ;\n            this._cascadeMaxExtents[cascadeIndex].z = maxZ;\n            this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);\n            // Create the rounding matrix, by projecting the world-space origin and determining\n            // the fractional offset in texel space\n            Vector3.TransformCoordinatesToRef(ZeroVec, this._transformMatrices[cascadeIndex], tmpv1); // tmpv1 = shadowOrigin\n            tmpv1.scaleInPlace(this._mapSize / 2);\n            tmpv2.copyFromFloats(Math.round(tmpv1.x), Math.round(tmpv1.y), Math.round(tmpv1.z)); // tmpv2 = roundedOrigin\n            tmpv2.subtractInPlace(tmpv1).scaleInPlace(2 / this._mapSize); // tmpv2 = roundOffset\n            Matrix.TranslationToRef(tmpv2.x, tmpv2.y, 0.0, tmpMatrix);\n            this._projectionMatrices[cascadeIndex].multiplyToRef(tmpMatrix, this._projectionMatrices[cascadeIndex]);\n            this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);\n            this._transformMatrices[cascadeIndex].copyToArray(this._transformMatricesAsArray, cascadeIndex * 16);\n        }\n    }\n    // Get the 8 points of the view frustum in world space\n    _computeFrustumInWorldSpace(cascadeIndex) {\n        const camera = this._getCamera();\n        if (!camera) {\n            return;\n        }\n        const prevSplitDist = this._cascades[cascadeIndex].prevBreakDistance, splitDist = this._cascades[cascadeIndex].breakDistance;\n        const isNDCHalfZRange = this._scene.getEngine().isNDCHalfZRange;\n        camera.getViewMatrix(); // make sure the transformation matrix we get when calling 'getTransformationMatrix()' is calculated with an up to date view matrix\n        const invViewProj = Matrix.Invert(camera.getTransformationMatrix());\n        const cornerIndexOffset = this._scene.getEngine().useReverseDepthBuffer ? 4 : 0;\n        for (let cornerIndex = 0; cornerIndex < CascadedShadowGenerator._FrustumCornersNDCSpace.length; ++cornerIndex) {\n            tmpv1.copyFrom(CascadedShadowGenerator._FrustumCornersNDCSpace[(cornerIndex + cornerIndexOffset) % CascadedShadowGenerator._FrustumCornersNDCSpace.length]);\n            if (isNDCHalfZRange && tmpv1.z === -1) {\n                tmpv1.z = 0;\n            }\n            Vector3.TransformCoordinatesToRef(tmpv1, invViewProj, this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\n        }\n        // Get the corners of the current cascade slice of the view frustum\n        for (let cornerIndex = 0; cornerIndex < CascadedShadowGenerator._FrustumCornersNDCSpace.length / 2; ++cornerIndex) {\n            tmpv1.copyFrom(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4]).subtractInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\n            tmpv2.copyFrom(tmpv1).scaleInPlace(prevSplitDist); // near corner ray\n            tmpv1.scaleInPlace(splitDist); // far corner ray\n            tmpv1.addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\n            this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4].copyFrom(tmpv1);\n            this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].addInPlace(tmpv2);\n        }\n    }\n    _computeCascadeFrustum(cascadeIndex) {\n        this._cascadeMinExtents[cascadeIndex].copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        this._cascadeMaxExtents[cascadeIndex].copyFromFloats(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);\n        this._frustumCenter[cascadeIndex].copyFromFloats(0, 0, 0);\n        const camera = this._getCamera();\n        if (!camera) {\n            return;\n        }\n        // Calculate the centroid of the view frustum slice\n        for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {\n            this._frustumCenter[cascadeIndex].addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\n        }\n        this._frustumCenter[cascadeIndex].scaleInPlace(1 / this._frustumCornersWorldSpace[cascadeIndex].length);\n        if (this.stabilizeCascades) {\n            // Calculate the radius of a bounding sphere surrounding the frustum corners\n            let sphereRadius = 0;\n            for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {\n                const dist = this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].subtractToRef(this._frustumCenter[cascadeIndex], tmpv1).length();\n                sphereRadius = Math.max(sphereRadius, dist);\n            }\n            sphereRadius = Math.ceil(sphereRadius * 16) / 16;\n            this._cascadeMaxExtents[cascadeIndex].copyFromFloats(sphereRadius, sphereRadius, sphereRadius);\n            this._cascadeMinExtents[cascadeIndex].copyFromFloats(-sphereRadius, -sphereRadius, -sphereRadius);\n        }\n        else {\n            // Create a temporary view matrix for the light\n            const lightCameraPos = this._frustumCenter[cascadeIndex];\n            this._frustumCenter[cascadeIndex].addToRef(this._lightDirection, tmpv1); // tmpv1 = look at\n            Matrix.LookAtLHToRef(lightCameraPos, tmpv1, UpDir, tmpMatrix); // matrix = lightView\n            // Calculate an AABB around the frustum corners\n            for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {\n                Vector3.TransformCoordinatesToRef(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex], tmpMatrix, tmpv1);\n                this._cascadeMinExtents[cascadeIndex].minimizeInPlace(tmpv1);\n                this._cascadeMaxExtents[cascadeIndex].maximizeInPlace(tmpv1);\n            }\n        }\n    }\n    _recreateSceneUBOs() {\n        this._disposeSceneUBOs();\n        if (this._sceneUBOs) {\n            for (let i = 0; i < this._numCascades; ++i) {\n                this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light \"${this._light.name}\" cascade #${i})`));\n            }\n        }\n    }\n    /**\n     *  Support test.\n     */\n    static get IsSupported() {\n        const engine = EngineStore.LastCreatedEngine;\n        if (!engine) {\n            return false;\n        }\n        return engine._features.supportCSM;\n    }\n    /**\n     * Creates a Cascaded Shadow Generator object.\n     * A ShadowGenerator is the required tool to use the shadows.\n     * Each directional light casting shadows needs to use its own ShadowGenerator.\n     * Documentation : https://doc.babylonjs.com/babylon101/cascadedShadows\n     * @param mapSize The size of the texture what stores the shadows. Example : 1024.\n     * @param light The directional light object generating the shadows.\n     * @param usefulFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.\n     * @param camera Camera associated with this shadow generator (default: null). If null, takes the scene active camera at the time we need to access it\n     */\n    constructor(mapSize, light, usefulFloatFirst, camera) {\n        if (!CascadedShadowGenerator.IsSupported) {\n            Logger.Error(\"CascadedShadowMap is not supported by the current engine.\");\n            return;\n        }\n        super(mapSize, light, usefulFloatFirst, camera);\n        this.usePercentageCloserFiltering = true;\n    }\n    _initializeGenerator() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;\n        this.penumbraDarkness = (_a = this.penumbraDarkness) !== null && _a !== void 0 ? _a : 1.0;\n        this._numCascades = (_b = this._numCascades) !== null && _b !== void 0 ? _b : CascadedShadowGenerator.DEFAULT_CASCADES_COUNT;\n        this.stabilizeCascades = (_c = this.stabilizeCascades) !== null && _c !== void 0 ? _c : false;\n        this._freezeShadowCastersBoundingInfoObservable = (_d = this._freezeShadowCastersBoundingInfoObservable) !== null && _d !== void 0 ? _d : null;\n        this.freezeShadowCastersBoundingInfo = (_e = this.freezeShadowCastersBoundingInfo) !== null && _e !== void 0 ? _e : false;\n        this._scbiMin = (_f = this._scbiMin) !== null && _f !== void 0 ? _f : new Vector3(0, 0, 0);\n        this._scbiMax = (_g = this._scbiMax) !== null && _g !== void 0 ? _g : new Vector3(0, 0, 0);\n        this._shadowCastersBoundingInfo = (_h = this._shadowCastersBoundingInfo) !== null && _h !== void 0 ? _h : new BoundingInfo(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\n        this._breaksAreDirty = (_j = this._breaksAreDirty) !== null && _j !== void 0 ? _j : true;\n        this._minDistance = (_k = this._minDistance) !== null && _k !== void 0 ? _k : 0;\n        this._maxDistance = (_l = this._maxDistance) !== null && _l !== void 0 ? _l : 1;\n        this._currentLayer = (_m = this._currentLayer) !== null && _m !== void 0 ? _m : 0;\n        this._shadowMaxZ = (_q = (_o = this._shadowMaxZ) !== null && _o !== void 0 ? _o : (_p = this._getCamera()) === null || _p === void 0 ? void 0 : _p.maxZ) !== null && _q !== void 0 ? _q : 10000;\n        this._debug = (_r = this._debug) !== null && _r !== void 0 ? _r : false;\n        this._depthClamp = (_s = this._depthClamp) !== null && _s !== void 0 ? _s : true;\n        this._cascadeBlendPercentage = (_t = this._cascadeBlendPercentage) !== null && _t !== void 0 ? _t : 0.1;\n        this._lambda = (_u = this._lambda) !== null && _u !== void 0 ? _u : 0.5;\n        this._autoCalcDepthBounds = (_v = this._autoCalcDepthBounds) !== null && _v !== void 0 ? _v : false;\n        this._recreateSceneUBOs();\n        super._initializeGenerator();\n    }\n    _createTargetRenderTexture() {\n        const engine = this._scene.getEngine();\n        const size = { width: this._mapSize, height: this._mapSize, layers: this.numCascades };\n        this._shadowMap = new RenderTargetTexture(this._light.name + \"_CSMShadowMap\", size, this._scene, false, true, this._textureType, false, undefined, false, false, undefined /*, 6*/);\n        this._shadowMap.createDepthStencilTexture(engine.useReverseDepthBuffer ? 516 : 513, true);\n    }\n    _initializeShadowMap() {\n        super._initializeShadowMap();\n        if (this._shadowMap === null) {\n            return;\n        }\n        this._transformMatricesAsArray = new Float32Array(this._numCascades * 16);\n        this._viewSpaceFrustumsZ = new Array(this._numCascades);\n        this._frustumLengths = new Array(this._numCascades);\n        this._lightSizeUVCorrection = new Array(this._numCascades * 2);\n        this._depthCorrection = new Array(this._numCascades);\n        this._cascades = [];\n        this._viewMatrices = [];\n        this._projectionMatrices = [];\n        this._transformMatrices = [];\n        this._cascadeMinExtents = [];\n        this._cascadeMaxExtents = [];\n        this._frustumCenter = [];\n        this._shadowCameraPos = [];\n        this._frustumCornersWorldSpace = [];\n        for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {\n            this._cascades[cascadeIndex] = {\n                prevBreakDistance: 0,\n                breakDistance: 0,\n            };\n            this._viewMatrices[cascadeIndex] = Matrix.Zero();\n            this._projectionMatrices[cascadeIndex] = Matrix.Zero();\n            this._transformMatrices[cascadeIndex] = Matrix.Zero();\n            this._cascadeMinExtents[cascadeIndex] = new Vector3();\n            this._cascadeMaxExtents[cascadeIndex] = new Vector3();\n            this._frustumCenter[cascadeIndex] = new Vector3();\n            this._shadowCameraPos[cascadeIndex] = new Vector3();\n            this._frustumCornersWorldSpace[cascadeIndex] = new Array(CascadedShadowGenerator._FrustumCornersNDCSpace.length);\n            for (let i = 0; i < CascadedShadowGenerator._FrustumCornersNDCSpace.length; ++i) {\n                this._frustumCornersWorldSpace[cascadeIndex][i] = new Vector3();\n            }\n        }\n        const engine = this._scene.getEngine();\n        this._shadowMap.onBeforeBindObservable.clear();\n        this._shadowMap.onBeforeRenderObservable.clear();\n        this._shadowMap.onBeforeRenderObservable.add((layer) => {\n            if (this._sceneUBOs) {\n                this._scene.setSceneUniformBuffer(this._sceneUBOs[layer]);\n            }\n            this._currentLayer = layer;\n            if (this._filter === ShadowGenerator.FILTER_PCF) {\n                engine.setColorWrite(false);\n            }\n            this._scene.setTransformMatrix(this.getCascadeViewMatrix(layer), this.getCascadeProjectionMatrix(layer));\n            if (this._useUBO) {\n                this._scene.getSceneUniformBuffer().unbindEffect();\n                this._scene.finalizeSceneUbo();\n            }\n        });\n        this._shadowMap.onBeforeBindObservable.add(() => {\n            var _a;\n            this._currentSceneUBO = this._scene.getSceneUniformBuffer();\n            (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, `cascaded shadow map generation for pass id ${engine.currentRenderPassId}`, 1);\n            if (this._breaksAreDirty) {\n                this._splitFrustum();\n            }\n            this._computeMatrices();\n        });\n        this._splitFrustum();\n    }\n    _bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect) {\n        effect.setMatrix(\"viewProjection\", this.getCascadeTransformMatrix(this._currentLayer));\n    }\n    _isReadyCustomDefines(defines) {\n        defines.push(\"#define SM_DEPTHCLAMP \" + (this._depthClamp && this._filter !== ShadowGenerator.FILTER_PCSS ? \"1\" : \"0\"));\n    }\n    /**\n     * Prepare all the defines in a material relying on a shadow map at the specified light index.\n     * @param defines Defines of the material we want to update\n     * @param lightIndex Index of the light in the enabled light list of the material\n     */\n    prepareDefines(defines, lightIndex) {\n        super.prepareDefines(defines, lightIndex);\n        const scene = this._scene;\n        const light = this._light;\n        if (!scene.shadowsEnabled || !light.shadowEnabled) {\n            return;\n        }\n        defines[\"SHADOWCSM\" + lightIndex] = true;\n        defines[\"SHADOWCSMDEBUG\" + lightIndex] = this.debug;\n        defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = this.numCascades;\n        defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = scene.useRightHandedSystem;\n        const camera = this._getCamera();\n        if (camera && this._shadowMaxZ < camera.maxZ) {\n            defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = true;\n        }\n        if (this.cascadeBlendPercentage === 0) {\n            defines[\"SHADOWCSMNOBLEND\" + lightIndex] = true;\n        }\n    }\n    /**\n     * Binds the shadow related information inside of an effect (information like near, far, darkness...\n     * defined in the generator but impacting the effect).\n     * @param lightIndex Index of the light in the enabled light list of the material owning the effect\n     * @param effect The effect we are binfing the information for\n     */\n    bindShadowLight(lightIndex, effect) {\n        const light = this._light;\n        const scene = this._scene;\n        if (!scene.shadowsEnabled || !light.shadowEnabled) {\n            return;\n        }\n        const camera = this._getCamera();\n        if (!camera) {\n            return;\n        }\n        const shadowMap = this.getShadowMap();\n        if (!shadowMap) {\n            return;\n        }\n        const width = shadowMap.getSize().width;\n        effect.setMatrices(\"lightMatrix\" + lightIndex, this._transformMatricesAsArray);\n        effect.setArray(\"viewFrustumZ\" + lightIndex, this._viewSpaceFrustumsZ);\n        effect.setFloat(\"cascadeBlendFactor\" + lightIndex, this.cascadeBlendPercentage === 0 ? 10000 : 1 / this.cascadeBlendPercentage);\n        effect.setArray(\"frustumLengths\" + lightIndex, this._frustumLengths);\n        // Only PCF uses depth stencil texture.\n        if (this._filter === ShadowGenerator.FILTER_PCF) {\n            effect.setDepthStencilTexture(\"shadowSampler\" + lightIndex, shadowMap);\n            light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);\n        }\n        else if (this._filter === ShadowGenerator.FILTER_PCSS) {\n            for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {\n                this._lightSizeUVCorrection[cascadeIndex * 2 + 0] =\n                    cascadeIndex === 0\n                        ? 1\n                        : (this._cascadeMaxExtents[0].x - this._cascadeMinExtents[0].x) / (this._cascadeMaxExtents[cascadeIndex].x - this._cascadeMinExtents[cascadeIndex].x); // x correction\n                this._lightSizeUVCorrection[cascadeIndex * 2 + 1] =\n                    cascadeIndex === 0\n                        ? 1\n                        : (this._cascadeMaxExtents[0].y - this._cascadeMinExtents[0].y) / (this._cascadeMaxExtents[cascadeIndex].y - this._cascadeMinExtents[cascadeIndex].y); // y correction\n                this._depthCorrection[cascadeIndex] =\n                    cascadeIndex === 0\n                        ? 1\n                        : (this._cascadeMaxExtents[cascadeIndex].z - this._cascadeMinExtents[cascadeIndex].z) / (this._cascadeMaxExtents[0].z - this._cascadeMinExtents[0].z);\n            }\n            effect.setDepthStencilTexture(\"shadowSampler\" + lightIndex, shadowMap);\n            effect.setTexture(\"depthSampler\" + lightIndex, shadowMap);\n            effect.setArray2(\"lightSizeUVCorrection\" + lightIndex, this._lightSizeUVCorrection);\n            effect.setArray(\"depthCorrection\" + lightIndex, this._depthCorrection);\n            effect.setFloat(\"penumbraDarkness\" + lightIndex, this.penumbraDarkness);\n            light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), 1 / width, this._contactHardeningLightSizeUVRatio * width, this.frustumEdgeFalloff, lightIndex);\n        }\n        else {\n            effect.setTexture(\"shadowSampler\" + lightIndex, shadowMap);\n            light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);\n        }\n        light._uniformBuffer.updateFloat2(\"depthValues\", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera), lightIndex);\n    }\n    /**\n     * Gets the transformation matrix of the first cascade used to project the meshes into the map from the light point of view.\n     * (eq to view projection * shadow projection matrices)\n     * @returns The transform matrix used to create the shadow map\n     */\n    getTransformMatrix() {\n        return this.getCascadeTransformMatrix(0);\n    }\n    /**\n     * Disposes the ShadowGenerator.\n     * Returns nothing.\n     */\n    dispose() {\n        super.dispose();\n        if (this._freezeShadowCastersBoundingInfoObservable) {\n            this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);\n            this._freezeShadowCastersBoundingInfoObservable = null;\n        }\n        if (this._depthReducer) {\n            this._depthReducer.dispose();\n            this._depthReducer = null;\n        }\n    }\n    /**\n     * Serializes the shadow generator setup to a json object.\n     * @returns The serialized JSON object\n     */\n    serialize() {\n        const serializationObject = super.serialize();\n        const shadowMap = this.getShadowMap();\n        if (!shadowMap) {\n            return serializationObject;\n        }\n        serializationObject.numCascades = this._numCascades;\n        serializationObject.debug = this._debug;\n        serializationObject.stabilizeCascades = this.stabilizeCascades;\n        serializationObject.lambda = this._lambda;\n        serializationObject.cascadeBlendPercentage = this.cascadeBlendPercentage;\n        serializationObject.depthClamp = this._depthClamp;\n        serializationObject.autoCalcDepthBounds = this.autoCalcDepthBounds;\n        serializationObject.shadowMaxZ = this._shadowMaxZ;\n        serializationObject.penumbraDarkness = this.penumbraDarkness;\n        serializationObject.freezeShadowCastersBoundingInfo = this._freezeShadowCastersBoundingInfo;\n        serializationObject.minDistance = this.minDistance;\n        serializationObject.maxDistance = this.maxDistance;\n        serializationObject.renderList = [];\n        if (shadowMap.renderList) {\n            for (let meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {\n                const mesh = shadowMap.renderList[meshIndex];\n                serializationObject.renderList.push(mesh.id);\n            }\n        }\n        return serializationObject;\n    }\n    /**\n     * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.\n     * @param parsedShadowGenerator The JSON object to parse\n     * @param scene The scene to create the shadow map for\n     * @returns The parsed shadow generator\n     */\n    static Parse(parsedShadowGenerator, scene) {\n        const shadowGenerator = ShadowGenerator.Parse(parsedShadowGenerator, scene, (mapSize, light, camera) => new CascadedShadowGenerator(mapSize, light, undefined, camera));\n        if (parsedShadowGenerator.numCascades !== undefined) {\n            shadowGenerator.numCascades = parsedShadowGenerator.numCascades;\n        }\n        if (parsedShadowGenerator.debug !== undefined) {\n            shadowGenerator.debug = parsedShadowGenerator.debug;\n        }\n        if (parsedShadowGenerator.stabilizeCascades !== undefined) {\n            shadowGenerator.stabilizeCascades = parsedShadowGenerator.stabilizeCascades;\n        }\n        if (parsedShadowGenerator.lambda !== undefined) {\n            shadowGenerator.lambda = parsedShadowGenerator.lambda;\n        }\n        if (parsedShadowGenerator.cascadeBlendPercentage !== undefined) {\n            shadowGenerator.cascadeBlendPercentage = parsedShadowGenerator.cascadeBlendPercentage;\n        }\n        if (parsedShadowGenerator.depthClamp !== undefined) {\n            shadowGenerator.depthClamp = parsedShadowGenerator.depthClamp;\n        }\n        if (parsedShadowGenerator.autoCalcDepthBounds !== undefined) {\n            shadowGenerator.autoCalcDepthBounds = parsedShadowGenerator.autoCalcDepthBounds;\n        }\n        if (parsedShadowGenerator.shadowMaxZ !== undefined) {\n            shadowGenerator.shadowMaxZ = parsedShadowGenerator.shadowMaxZ;\n        }\n        if (parsedShadowGenerator.penumbraDarkness !== undefined) {\n            shadowGenerator.penumbraDarkness = parsedShadowGenerator.penumbraDarkness;\n        }\n        if (parsedShadowGenerator.freezeShadowCastersBoundingInfo !== undefined) {\n            shadowGenerator.freezeShadowCastersBoundingInfo = parsedShadowGenerator.freezeShadowCastersBoundingInfo;\n        }\n        if (parsedShadowGenerator.minDistance !== undefined && parsedShadowGenerator.maxDistance !== undefined) {\n            shadowGenerator.setMinMaxDistance(parsedShadowGenerator.minDistance, parsedShadowGenerator.maxDistance);\n        }\n        return shadowGenerator;\n    }\n}\nCascadedShadowGenerator._FrustumCornersNDCSpace = [\n    new Vector3(-1.0, +1.0, -1.0),\n    new Vector3(+1.0, +1.0, -1.0),\n    new Vector3(+1.0, -1.0, -1.0),\n    new Vector3(-1.0, -1.0, -1.0),\n    new Vector3(-1.0, +1.0, +1.0),\n    new Vector3(+1.0, +1.0, +1.0),\n    new Vector3(+1.0, -1.0, +1.0),\n    new Vector3(-1.0, -1.0, +1.0),\n];\n/**\n * Name of the CSM class\n */\nCascadedShadowGenerator.CLASSNAME = \"CascadedShadowGenerator\";\n/**\n * Defines the default number of cascades used by the CSM.\n */\nCascadedShadowGenerator.DEFAULT_CASCADES_COUNT = 4;\n/**\n * Defines the minimum number of cascades used by the CSM.\n */\nCascadedShadowGenerator.MIN_CASCADES_COUNT = 2;\n/**\n * Defines the maximum number of cascades used by the CSM.\n */\nCascadedShadowGenerator.MAX_CASCADES_COUNT = 4;\n/**\n * @internal\n */\nCascadedShadowGenerator._SceneComponentInitialization = (_) => {\n    throw _WarnImport(\"ShadowGeneratorSceneComponent\");\n};\n//# sourceMappingURL=cascadedShadowGenerator.js.map","import { ShadowGenerator } from \"./shadowGenerator.js\";\nimport { CascadedShadowGenerator } from \"./cascadedShadowGenerator.js\";\nimport { SceneComponentConstants } from \"../../sceneComponent.js\";\nimport { AbstractScene } from \"../../abstractScene.js\";\n// Adds the parser to the scene parsers.\nAbstractScene.AddParser(SceneComponentConstants.NAME_SHADOWGENERATOR, (parsedData, scene) => {\n    // Shadows\n    if (parsedData.shadowGenerators !== undefined && parsedData.shadowGenerators !== null) {\n        for (let index = 0, cache = parsedData.shadowGenerators.length; index < cache; index++) {\n            const parsedShadowGenerator = parsedData.shadowGenerators[index];\n            if (parsedShadowGenerator.className === CascadedShadowGenerator.CLASSNAME) {\n                CascadedShadowGenerator.Parse(parsedShadowGenerator, scene);\n            }\n            else {\n                ShadowGenerator.Parse(parsedShadowGenerator, scene);\n            }\n            // SG would be available on their associated lights\n        }\n    }\n});\n/**\n * Defines the shadow generator component responsible to manage any shadow generators\n * in a given scene.\n */\nexport class ShadowGeneratorSceneComponent {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    constructor(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_SHADOWGENERATOR;\n        this.scene = scene;\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    register() {\n        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    rebuild() {\n        // Nothing To Do Here.\n    }\n    /**\n     * Serializes the component data to the specified json object\n     * @param serializationObject The object to serialize to\n     */\n    serialize(serializationObject) {\n        // Shadows\n        serializationObject.shadowGenerators = [];\n        const lights = this.scene.lights;\n        for (const light of lights) {\n            const shadowGenerators = light.getShadowGenerators();\n            if (shadowGenerators) {\n                const iterator = shadowGenerators.values();\n                for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n                    const shadowGenerator = key.value;\n                    serializationObject.shadowGenerators.push(shadowGenerator.serialize());\n                }\n            }\n        }\n    }\n    /**\n     * Adds all the elements from the container to the scene\n     * @param container the container holding the elements\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    addFromContainer(container) {\n        // Nothing To Do Here. (directly attached to a light)\n    }\n    /**\n     * Removes all the elements in the container from the scene\n     * @param container contains the elements to remove\n     * @param dispose if the removed element should be disposed (default: false)\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    removeFromContainer(container, dispose) {\n        // Nothing To Do Here. (directly attached to a light)\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    dispose() {\n        // Nothing To Do Here.\n    }\n    _gatherRenderTargets(renderTargets) {\n        // Shadows\n        const scene = this.scene;\n        if (this.scene.shadowsEnabled) {\n            for (let lightIndex = 0; lightIndex < scene.lights.length; lightIndex++) {\n                const light = scene.lights[lightIndex];\n                const shadowGenerators = light.getShadowGenerators();\n                if (light.isEnabled() && light.shadowEnabled && shadowGenerators) {\n                    const iterator = shadowGenerators.values();\n                    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n                        const shadowGenerator = key.value;\n                        const shadowMap = shadowGenerator.getShadowMap();\n                        if (scene.textures.indexOf(shadowMap) !== -1) {\n                            renderTargets.push(shadowMap);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nShadowGenerator._SceneComponentInitialization = (scene) => {\n    let component = scene._getComponent(SceneComponentConstants.NAME_SHADOWGENERATOR);\n    if (!component) {\n        component = new ShadowGeneratorSceneComponent(scene);\n        scene._addComponent(component);\n    }\n};\n//# sourceMappingURL=shadowGeneratorSceneComponent.js.map","import { DirectionalLight } from '@babylonjs/core/Lights/directionalLight'\nimport { HemisphericLight } from '@babylonjs/core/Lights/hemisphericLight'\nimport { ShadowGenerator } from '@babylonjs/core/Lights/Shadows/shadowGenerator'\nimport { Vector3 } from '@babylonjs/core/Maths/math.vector'\nimport '@babylonjs/core/Lights/Shadows/shadowGeneratorSceneComponent'\n\nconst defaultOptions = {\n  enableShadows: true\n}\n\nfunction createLights(options = defaultOptions) {\n  const { enableShadows, shadowTransparency, intensity, scene } = options\n  const d_light = new DirectionalLight(\"DirectionalLight\", new Vector3(-0.3, -1, 0.4), scene)\n  d_light.position = new Vector3(-50,65,-50)\n  d_light.intensity = .65 * intensity\n  \n  const h_light = new HemisphericLight(\"HemisphericLight\", new Vector3(1, 1, 0), scene)\n  h_light.intensity = .4 * intensity\n  \n  if(enableShadows){\n    d_light.shadowMinZ = 1\n    d_light.shadowMaxZ = 70\n\t\t// d_light.autoCalcShadowZBounds = true\n    d_light.shadowGenerator = new ShadowGenerator(2048, d_light);\n    d_light.shadowGenerator.useCloseExponentialShadowMap = true; // best\n    d_light.shadowGenerator.darkness = shadowTransparency\n    // d_light.shadowGenerator.usePoissonSampling = true\n    // d_light.shadowGenerator.bias = .01\n  }\n\n  return {directional: d_light, hemispheric: h_light}\n}\n\nexport { createLights }","import { Vector4 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a box\n * @param options an object used to set the following optional parameters for the box, required but can be empty\n * * size sets the width, height and depth of the box to the value of size, optional default 1\n * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\n * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\n * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.depth\n * @param options.faceUV\n * @param options.faceColors\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.wrap\n * @param options.topBaseAt\n * @param options.bottomBaseAt\n * @returns the VertexData of the box\n */\nexport function CreateBoxVertexData(options) {\n    const nbFaces = 6;\n    let indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];\n    const normals = [\n        0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0,\n        1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,\n    ];\n    const uvs = [];\n    let positions = [];\n    const width = options.width || options.size || 1;\n    const height = options.height || options.size || 1;\n    const depth = options.depth || options.size || 1;\n    const wrap = options.wrap || false;\n    let topBaseAt = options.topBaseAt === void 0 ? 1 : options.topBaseAt;\n    let bottomBaseAt = options.bottomBaseAt === void 0 ? 0 : options.bottomBaseAt;\n    topBaseAt = (topBaseAt + 4) % 4; // places values as 0 to 3\n    bottomBaseAt = (bottomBaseAt + 4) % 4; // places values as 0 to 3\n    const topOrder = [2, 0, 3, 1];\n    const bottomOrder = [2, 0, 1, 3];\n    let topIndex = topOrder[topBaseAt];\n    let bottomIndex = bottomOrder[bottomBaseAt];\n    let basePositions = [\n        1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1,\n        1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1,\n    ];\n    if (wrap) {\n        indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];\n        basePositions = [\n            -1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1,\n        ];\n        let topFaceBase = [\n            [1, 1, 1],\n            [-1, 1, 1],\n            [-1, 1, -1],\n            [1, 1, -1],\n        ];\n        let bottomFaceBase = [\n            [-1, -1, 1],\n            [1, -1, 1],\n            [1, -1, -1],\n            [-1, -1, -1],\n        ];\n        const topFaceOrder = [17, 18, 19, 16];\n        const bottomFaceOrder = [22, 23, 20, 21];\n        while (topIndex > 0) {\n            topFaceBase.unshift(topFaceBase.pop());\n            topFaceOrder.unshift(topFaceOrder.pop());\n            topIndex--;\n        }\n        while (bottomIndex > 0) {\n            bottomFaceBase.unshift(bottomFaceBase.pop());\n            bottomFaceOrder.unshift(bottomFaceOrder.pop());\n            bottomIndex--;\n        }\n        topFaceBase = topFaceBase.flat();\n        bottomFaceBase = bottomFaceBase.flat();\n        basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);\n        indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);\n        indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);\n    }\n    const scaleArray = [width / 2, height / 2, depth / 2];\n    positions = basePositions.reduce((accumulator, currentValue, currentIndex) => accumulator.concat(currentValue * scaleArray[currentIndex % 3]), []);\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    const faceUV = options.faceUV || new Array(6);\n    const faceColors = options.faceColors;\n    const colors = [];\n    // default face colors and UV if undefined\n    for (let f = 0; f < 6; f++) {\n        if (faceUV[f] === undefined) {\n            faceUV[f] = new Vector4(0, 0, 1, 1);\n        }\n        if (faceColors && faceColors[f] === undefined) {\n            faceColors[f] = new Color4(1, 1, 1, 1);\n        }\n    }\n    // Create each face in turn.\n    for (let index = 0; index < nbFaces; index++) {\n        uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\n        uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\n        uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\n        uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\n        if (faceColors) {\n            for (let c = 0; c < 4; c++) {\n                colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);\n            }\n        }\n    }\n    // sides\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n    // Result\n    const vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    if (faceColors) {\n        const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n        vertexData.colors = totalColors;\n    }\n    return vertexData;\n}\n/**\n * Creates a box mesh\n * * The parameter `size` sets the size (float) of each box side (default 1)\n * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)\n * * Please read this tutorial : https://doc.babylonjs.com/features/featuresDeepDive/materials/using/texturePerBoxFace\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#box\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.depth\n * @param options.faceUV\n * @param options.faceColors\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.wrap\n * @param options.topBaseAt\n * @param options.bottomBaseAt\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the box mesh\n */\nexport function CreateBox(name, options = {}, scene = null) {\n    const box = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    box._originalBuilderSideOrientation = options.sideOrientation;\n    const vertexData = CreateBoxVertexData(options);\n    vertexData.applyToMesh(box, options.updatable);\n    return box;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated please use CreateBox directly\n */\nexport const BoxBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateBox,\n};\n// Side effects\nVertexData.CreateBox = CreateBoxVertexData;\nMesh.CreateBox = (name, size, scene = null, updatable, sideOrientation) => {\n    const options = {\n        size,\n        sideOrientation,\n        updatable,\n    };\n    return CreateBox(name, options, scene);\n};\n//# sourceMappingURL=boxBuilder.js.map","\n/**\n * Configuration needed for prepass-capable materials\n */\nexport class PrePassConfiguration {\n    constructor() {\n        /**\n         * Previous world matrices of meshes carrying this material\n         * Used for computing velocity\n         */\n        this.previousWorldMatrices = {};\n        /**\n         * Previous bones of meshes carrying this material\n         * Used for computing velocity\n         */\n        this.previousBones = {};\n    }\n    /**\n     * Add the required uniforms to the current list.\n     * @param uniforms defines the current uniform list.\n     */\n    static AddUniforms(uniforms) {\n        uniforms.push(\"previousWorld\", \"previousViewProjection\", \"mPreviousBones\");\n    }\n    /**\n     * Add the required samplers to the current list.\n     * @param samplers defines the current sampler list.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static AddSamplers(samplers) {\n        // pass\n    }\n    /**\n     * Binds the material data.\n     * @param effect defines the effect to update\n     * @param scene defines the scene the material belongs to.\n     * @param mesh The mesh\n     * @param world World matrix of this mesh\n     * @param isFrozen Is the material frozen\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    bindForSubMesh(effect, scene, mesh, world, isFrozen) {\n        if (scene.prePassRenderer && scene.prePassRenderer.enabled && scene.prePassRenderer.currentRTisSceneRT) {\n            if (scene.prePassRenderer.getIndex(2) !== -1) {\n                if (!this.previousWorldMatrices[mesh.uniqueId]) {\n                    this.previousWorldMatrices[mesh.uniqueId] = world.clone();\n                }\n                if (!this.previousViewProjection) {\n                    this.previousViewProjection = scene.getTransformMatrix().clone();\n                    this.currentViewProjection = scene.getTransformMatrix().clone();\n                }\n                const engine = scene.getEngine();\n                if (this.currentViewProjection.updateFlag !== scene.getTransformMatrix().updateFlag) {\n                    // First update of the prepass configuration for this rendering pass\n                    this._lastUpdateFrameId = engine.frameId;\n                    this.previousViewProjection.copyFrom(this.currentViewProjection);\n                    this.currentViewProjection.copyFrom(scene.getTransformMatrix());\n                }\n                else if (this._lastUpdateFrameId !== engine.frameId) {\n                    // The scene transformation did not change from the previous frame (so no camera motion), we must update previousViewProjection accordingly\n                    this._lastUpdateFrameId = engine.frameId;\n                    this.previousViewProjection.copyFrom(this.currentViewProjection);\n                }\n                effect.setMatrix(\"previousWorld\", this.previousWorldMatrices[mesh.uniqueId]);\n                effect.setMatrix(\"previousViewProjection\", this.previousViewProjection);\n                this.previousWorldMatrices[mesh.uniqueId] = world.clone();\n            }\n        }\n    }\n}\n//# sourceMappingURL=prePassConfiguration.js.map","import { Matrix } from \"../Maths/math.vector.js\";\nimport { Material } from \"../Materials/material.js\";\n/**\n * Base class of materials working in push mode in babylon JS\n * @internal\n */\nexport class PushMaterial extends Material {\n    constructor(name, scene, storeEffectOnSubMeshes = true) {\n        super(name, scene);\n        this._normalMatrix = new Matrix();\n        this._storeEffectOnSubMeshes = storeEffectOnSubMeshes;\n    }\n    getEffect() {\n        return this._storeEffectOnSubMeshes ? this._activeEffect : super.getEffect();\n    }\n    isReady(mesh, useInstances) {\n        if (!mesh) {\n            return false;\n        }\n        if (!this._storeEffectOnSubMeshes) {\n            return true;\n        }\n        if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\n            return true;\n        }\n        return this.isReadyForSubMesh(mesh, mesh.subMeshes[0], useInstances);\n    }\n    _isReadyForSubMesh(subMesh) {\n        const defines = subMesh.materialDefines;\n        if (!this.checkReadyOnEveryCall && subMesh.effect && defines) {\n            if (defines._renderId === this.getScene().getRenderId()) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Binds the given world matrix to the active effect\n     *\n     * @param world the matrix to bind\n     */\n    bindOnlyWorldMatrix(world) {\n        this._activeEffect.setMatrix(\"world\", world);\n    }\n    /**\n     * Binds the given normal matrix to the active effect\n     *\n     * @param normalMatrix the matrix to bind\n     */\n    bindOnlyNormalMatrix(normalMatrix) {\n        this._activeEffect.setMatrix(\"normalMatrix\", normalMatrix);\n    }\n    bind(world, mesh) {\n        if (!mesh) {\n            return;\n        }\n        this.bindForSubMesh(world, mesh, mesh.subMeshes[0]);\n    }\n    _afterBind(mesh, effect = null) {\n        super._afterBind(mesh, effect);\n        this.getScene()._cachedEffect = effect;\n        if (effect) {\n            effect._forceRebindOnNextCall = false;\n        }\n    }\n    _mustRebind(scene, effect, visibility = 1) {\n        return scene.isCachedMaterialInvalid(this, effect, visibility);\n    }\n    dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {\n        this._activeEffect = undefined;\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\n    }\n}\n//# sourceMappingURL=pushMaterial.js.map","import { Engine } from \"../Engines/engine.js\";\n\n/**\n * This groups all the flags used to control the materials channel.\n */\nexport class MaterialFlags {\n    /**\n     * Are diffuse textures enabled in the application.\n     */\n    static get DiffuseTextureEnabled() {\n        return this._DiffuseTextureEnabled;\n    }\n    static set DiffuseTextureEnabled(value) {\n        if (this._DiffuseTextureEnabled === value) {\n            return;\n        }\n        this._DiffuseTextureEnabled = value;\n        Engine.MarkAllMaterialsAsDirty(1);\n    }\n    /**\n     * Are detail textures enabled in the application.\n     */\n    static get DetailTextureEnabled() {\n        return this._DetailTextureEnabled;\n    }\n    static set DetailTextureEnabled(value) {\n        if (this._DetailTextureEnabled === value) {\n            return;\n        }\n        this._DetailTextureEnabled = value;\n        Engine.MarkAllMaterialsAsDirty(1);\n    }\n    /**\n     * Are decal maps enabled in the application.\n     */\n    static get DecalMapEnabled() {\n        return this._DecalMapEnabled;\n    }\n    static set DecalMapEnabled(value) {\n        if (this._DecalMapEnabled === value) {\n            return;\n        }\n        this._DecalMapEnabled = value;\n        Engine.MarkAllMaterialsAsDirty(1);\n    }\n    /**\n     * Are ambient textures enabled in the application.\n     */\n    static get AmbientTextureEnabled() {\n        return this._AmbientTextureEnabled;\n    }\n    static set AmbientTextureEnabled(value) {\n        if (this._AmbientTextureEnabled === value) {\n            return;\n        }\n        this._AmbientTextureEnabled = value;\n        Engine.MarkAllMaterialsAsDirty(1);\n    }\n    /**\n     * Are opacity textures enabled in the application.\n     */\n    static get OpacityTextureEnabled() {\n        return this._OpacityTextureEnabled;\n    }\n    static set OpacityTextureEnabled(value) {\n        if (this._OpacityTextureEnabled === value) {\n            return;\n        }\n        this._OpacityTextureEnabled = value;\n        Engine.MarkAllMaterialsAsDirty(1);\n    }\n    /**\n     * Are reflection textures enabled in the application.\n     */\n    static get ReflectionTextureEnabled() {\n        return this._ReflectionTextureEnabled;\n    }\n    static set ReflectionTextureEnabled(value) {\n        if (this._ReflectionTextureEnabled === value) {\n            return;\n        }\n        this._ReflectionTextureEnabled = value;\n        Engine.MarkAllMaterialsAsDirty(1);\n    }\n    /**\n     * Are emissive textures enabled in the application.\n     */\n    static get EmissiveTextureEnabled() {\n        return this._EmissiveTextureEnabled;\n    }\n    static set EmissiveTextureEnabled(value) {\n        if (this._EmissiveTextureEnabled === value) {\n            return;\n        }\n        this._EmissiveTextureEnabled = value;\n        Engine.MarkAllMaterialsAsDirty(1);\n    }\n    /**\n     * Are specular textures enabled in the application.\n     */\n    static get SpecularTextureEnabled() {\n        return this._SpecularTextureEnabled;\n    }\n    static set SpecularTextureEnabled(value) {\n        if (this._SpecularTextureEnabled === value) {\n            return;\n        }\n        this._SpecularTextureEnabled = value;\n        Engine.MarkAllMaterialsAsDirty(1);\n    }\n    /**\n     * Are bump textures enabled in the application.\n     */\n    static get BumpTextureEnabled() {\n        return this._BumpTextureEnabled;\n    }\n    static set BumpTextureEnabled(value) {\n        if (this._BumpTextureEnabled === value) {\n            return;\n        }\n        this._BumpTextureEnabled = value;\n        Engine.MarkAllMaterialsAsDirty(1);\n    }\n    /**\n     * Are lightmap textures enabled in the application.\n     */\n    static get LightmapTextureEnabled() {\n        return this._LightmapTextureEnabled;\n    }\n    static set LightmapTextureEnabled(value) {\n        if (this._LightmapTextureEnabled === value) {\n            return;\n        }\n        this._LightmapTextureEnabled = value;\n        Engine.MarkAllMaterialsAsDirty(1);\n    }\n    /**\n     * Are refraction textures enabled in the application.\n     */\n    static get RefractionTextureEnabled() {\n        return this._RefractionTextureEnabled;\n    }\n    static set RefractionTextureEnabled(value) {\n        if (this._RefractionTextureEnabled === value) {\n            return;\n        }\n        this._RefractionTextureEnabled = value;\n        Engine.MarkAllMaterialsAsDirty(1);\n    }\n    /**\n     * Are color grading textures enabled in the application.\n     */\n    static get ColorGradingTextureEnabled() {\n        return this._ColorGradingTextureEnabled;\n    }\n    static set ColorGradingTextureEnabled(value) {\n        if (this._ColorGradingTextureEnabled === value) {\n            return;\n        }\n        this._ColorGradingTextureEnabled = value;\n        Engine.MarkAllMaterialsAsDirty(1);\n    }\n    /**\n     * Are fresnels enabled in the application.\n     */\n    static get FresnelEnabled() {\n        return this._FresnelEnabled;\n    }\n    static set FresnelEnabled(value) {\n        if (this._FresnelEnabled === value) {\n            return;\n        }\n        this._FresnelEnabled = value;\n        Engine.MarkAllMaterialsAsDirty(4);\n    }\n    /**\n     * Are clear coat textures enabled in the application.\n     */\n    static get ClearCoatTextureEnabled() {\n        return this._ClearCoatTextureEnabled;\n    }\n    static set ClearCoatTextureEnabled(value) {\n        if (this._ClearCoatTextureEnabled === value) {\n            return;\n        }\n        this._ClearCoatTextureEnabled = value;\n        Engine.MarkAllMaterialsAsDirty(1);\n    }\n    /**\n     * Are clear coat bump textures enabled in the application.\n     */\n    static get ClearCoatBumpTextureEnabled() {\n        return this._ClearCoatBumpTextureEnabled;\n    }\n    static set ClearCoatBumpTextureEnabled(value) {\n        if (this._ClearCoatBumpTextureEnabled === value) {\n            return;\n        }\n        this._ClearCoatBumpTextureEnabled = value;\n        Engine.MarkAllMaterialsAsDirty(1);\n    }\n    /**\n     * Are clear coat tint textures enabled in the application.\n     */\n    static get ClearCoatTintTextureEnabled() {\n        return this._ClearCoatTintTextureEnabled;\n    }\n    static set ClearCoatTintTextureEnabled(value) {\n        if (this._ClearCoatTintTextureEnabled === value) {\n            return;\n        }\n        this._ClearCoatTintTextureEnabled = value;\n        Engine.MarkAllMaterialsAsDirty(1);\n    }\n    /**\n     * Are sheen textures enabled in the application.\n     */\n    static get SheenTextureEnabled() {\n        return this._SheenTextureEnabled;\n    }\n    static set SheenTextureEnabled(value) {\n        if (this._SheenTextureEnabled === value) {\n            return;\n        }\n        this._SheenTextureEnabled = value;\n        Engine.MarkAllMaterialsAsDirty(1);\n    }\n    /**\n     * Are anisotropic textures enabled in the application.\n     */\n    static get AnisotropicTextureEnabled() {\n        return this._AnisotropicTextureEnabled;\n    }\n    static set AnisotropicTextureEnabled(value) {\n        if (this._AnisotropicTextureEnabled === value) {\n            return;\n        }\n        this._AnisotropicTextureEnabled = value;\n        Engine.MarkAllMaterialsAsDirty(1);\n    }\n    /**\n     * Are thickness textures enabled in the application.\n     */\n    static get ThicknessTextureEnabled() {\n        return this._ThicknessTextureEnabled;\n    }\n    static set ThicknessTextureEnabled(value) {\n        if (this._ThicknessTextureEnabled === value) {\n            return;\n        }\n        this._ThicknessTextureEnabled = value;\n        Engine.MarkAllMaterialsAsDirty(1);\n    }\n    /**\n     * Are refraction intensity textures enabled in the application.\n     */\n    static get RefractionIntensityTextureEnabled() {\n        return this._ThicknessTextureEnabled;\n    }\n    static set RefractionIntensityTextureEnabled(value) {\n        if (this._RefractionIntensityTextureEnabled === value) {\n            return;\n        }\n        this._RefractionIntensityTextureEnabled = value;\n        Engine.MarkAllMaterialsAsDirty(1);\n    }\n    /**\n     * Are translucency intensity textures enabled in the application.\n     */\n    static get TranslucencyIntensityTextureEnabled() {\n        return this._ThicknessTextureEnabled;\n    }\n    static set TranslucencyIntensityTextureEnabled(value) {\n        if (this._TranslucencyIntensityTextureEnabled === value) {\n            return;\n        }\n        this._TranslucencyIntensityTextureEnabled = value;\n        Engine.MarkAllMaterialsAsDirty(1);\n    }\n    /**\n     * Are translucency intensity textures enabled in the application.\n     */\n    static get IridescenceTextureEnabled() {\n        return this._IridescenceTextureEnabled;\n    }\n    static set IridescenceTextureEnabled(value) {\n        if (this._IridescenceTextureEnabled === value) {\n            return;\n        }\n        this._IridescenceTextureEnabled = value;\n        Engine.MarkAllMaterialsAsDirty(1);\n    }\n}\n// Flags used to enable or disable a type of texture for all Standard Materials\nMaterialFlags._DiffuseTextureEnabled = true;\nMaterialFlags._DetailTextureEnabled = true;\nMaterialFlags._DecalMapEnabled = true;\nMaterialFlags._AmbientTextureEnabled = true;\nMaterialFlags._OpacityTextureEnabled = true;\nMaterialFlags._ReflectionTextureEnabled = true;\nMaterialFlags._EmissiveTextureEnabled = true;\nMaterialFlags._SpecularTextureEnabled = true;\nMaterialFlags._BumpTextureEnabled = true;\nMaterialFlags._LightmapTextureEnabled = true;\nMaterialFlags._RefractionTextureEnabled = true;\nMaterialFlags._ColorGradingTextureEnabled = true;\nMaterialFlags._FresnelEnabled = true;\nMaterialFlags._ClearCoatTextureEnabled = true;\nMaterialFlags._ClearCoatBumpTextureEnabled = true;\nMaterialFlags._ClearCoatTintTextureEnabled = true;\nMaterialFlags._SheenTextureEnabled = true;\nMaterialFlags._AnisotropicTextureEnabled = true;\nMaterialFlags._ThicknessTextureEnabled = true;\nMaterialFlags._RefractionIntensityTextureEnabled = true;\nMaterialFlags._TranslucencyIntensityTextureEnabled = true;\nMaterialFlags._IridescenceTextureEnabled = true;\n//# sourceMappingURL=materialFlags.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"decalFragmentDeclaration\";\nconst shader = `#ifdef DECAL\nuniform vec4 vDecalInfos;\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const decalFragmentDeclaration = { name, shader };\n//# sourceMappingURL=decalFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nimport \"./decalFragmentDeclaration.js\";\nconst name = \"defaultFragmentDeclaration\";\nconst shader = `uniform vec4 vEyePosition;\runiform vec4 vDiffuseColor;\r#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\r#endif\nuniform vec3 vEmissiveColor;\runiform vec3 vAmbientColor;\runiform float visibility;\r#ifdef DIFFUSE\nuniform vec2 vDiffuseInfos;\r#endif\n#ifdef AMBIENT\nuniform vec2 vAmbientInfos;\r#endif\n#ifdef OPACITY \nuniform vec2 vOpacityInfos;\r#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\r#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\r#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;\runiform vec2 vTangentSpaceParams;\r#endif\n#ifdef ALPHATEST\nuniform float alphaCutOff;\r#endif\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION) || defined(PREPASS)\nuniform mat4 view;\r#endif\n#ifdef REFRACTION\nuniform vec4 vRefractionInfos;\r#ifndef REFRACTIONMAP_3D\nuniform mat4 refractionMatrix;\r#endif\n#ifdef REFRACTIONFRESNEL\nuniform vec4 refractionLeftColor;\runiform vec4 refractionRightColor;\r#endif\n#if defined(USE_LOCAL_REFRACTIONMAP_CUBIC) && defined(REFRACTIONMAP_3D)\nuniform vec3 vRefractionPosition;\runiform vec3 vRefractionSize; \r#endif\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nuniform vec2 vSpecularInfos;\r#endif\n#ifdef DIFFUSEFRESNEL\nuniform vec4 diffuseLeftColor;\runiform vec4 diffuseRightColor;\r#endif\n#ifdef OPACITYFRESNEL\nuniform vec4 opacityParts;\r#endif\n#ifdef EMISSIVEFRESNEL\nuniform vec4 emissiveLeftColor;\runiform vec4 emissiveRightColor;\r#endif\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\r#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION) || defined(REFLECTIONMAP_EQUIRECTANGULAR) || defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_SKYBOX)\nuniform mat4 reflectionMatrix;\r#endif\n#ifndef REFLECTIONMAP_SKYBOX\n#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)\nuniform vec3 vReflectionPosition;\runiform vec3 vReflectionSize; \r#endif\n#endif\n#ifdef REFLECTIONFRESNEL\nuniform vec4 reflectionLeftColor;\runiform vec4 reflectionRightColor;\r#endif\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;\r#endif\n#include<decalFragmentDeclaration>\n#define ADDITIONAL_FRAGMENT_DECLARATION\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const defaultFragmentDeclaration = { name, shader };\n//# sourceMappingURL=defaultFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nimport \"./sceneUboDeclaration.js\";\nimport \"./meshUboDeclaration.js\";\nconst name = \"defaultUboDeclaration\";\nconst shader = `layout(std140,column_major) uniform;\runiform Material\r{\rvec4 diffuseLeftColor;\rvec4 diffuseRightColor;\rvec4 opacityParts;\rvec4 reflectionLeftColor;\rvec4 reflectionRightColor;\rvec4 refractionLeftColor;\rvec4 refractionRightColor;\rvec4 emissiveLeftColor;\rvec4 emissiveRightColor;\rvec2 vDiffuseInfos;\rvec2 vAmbientInfos;\rvec2 vOpacityInfos;\rvec2 vReflectionInfos;\rvec3 vReflectionPosition;\rvec3 vReflectionSize;\rvec2 vEmissiveInfos;\rvec2 vLightmapInfos;\rvec2 vSpecularInfos;\rvec3 vBumpInfos;\rmat4 diffuseMatrix;\rmat4 ambientMatrix;\rmat4 opacityMatrix;\rmat4 reflectionMatrix;\rmat4 emissiveMatrix;\rmat4 lightmapMatrix;\rmat4 specularMatrix;\rmat4 bumpMatrix;\rvec2 vTangentSpaceParams;\rfloat pointSize;\rfloat alphaCutOff;\rmat4 refractionMatrix;\rvec4 vRefractionInfos;\rvec3 vRefractionPosition;\rvec3 vRefractionSize;\rvec4 vSpecularColor;\rvec3 vEmissiveColor;\rvec4 vDiffuseColor;\rvec3 vAmbientColor;\r#define ADDITIONAL_UBO_DECLARATION\n};\r#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const defaultUboDeclaration = { name, shader };\n//# sourceMappingURL=defaultUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"oitDeclaration\";\nconst shader = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY\n#extension GL_EXT_draw_buffers : require\nlayout(location=0) out vec2 depth; \rlayout(location=1) out vec4 frontColor;\rlayout(location=2) out vec4 backColor;\r#define MAX_DEPTH 99999.0\nhighp vec4 gl_FragColor;\runiform sampler2D oitDepthSampler;\runiform sampler2D oitFrontColorSampler;\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const oitDeclaration = { name, shader };\n//# sourceMappingURL=oitDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"mainUVVaryingDeclaration\";\nconst shader = `#ifdef MAINUV{X}\nvarying vec2 vMainUV{X};\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const mainUVVaryingDeclaration = { name, shader };\n//# sourceMappingURL=mainUVVaryingDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"lightFragmentDeclaration\";\nconst shader = `#ifdef LIGHT{X}\nuniform vec4 vLightData{X};\runiform vec4 vLightDiffuse{X};\r#ifdef SPECULARTERM\nuniform vec4 vLightSpecular{X};\r#else\nvec4 vLightSpecular{X}=vec4(0.);\r#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\runiform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];\runiform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];\runiform float cascadeBlendFactor{X};\rvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\rvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\rvarying vec4 vPositionFromCamera{X};\r#if defined(SHADOWPCSS{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\runiform highp sampler2DArray depthSampler{X};\runiform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\runiform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\runiform float penumbraDarkness{X};\r#elif defined(SHADOWPCF{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\r#else\nuniform highp sampler2DArray shadowSampler{X};\r#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\r(\rvec3 ( 1.5,0.0,0.0 ),\rvec3 ( 0.0,1.5,0.0 ),\rvec3 ( 0.0,0.0,5.5 ),\rvec3 ( 1.5,0.0,5.5 ),\rvec3 ( 1.5,1.5,0.0 ),\rvec3 ( 1.0,1.0,1.0 ),\rvec3 ( 0.0,1.0,5.5 ),\rvec3 ( 0.5,3.5,0.75 )\r);\rvec3 shadowDebug{X};\r#endif\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nint index{X}=-1;\r#else\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\r#endif\nfloat diff{X}=0.;\r#elif defined(SHADOWCUBE{X})\nuniform samplerCube shadowSampler{X};\r#else\nvarying vec4 vPositionFromLight{X};\rvarying float vDepthMetric{X};\r#if defined(SHADOWPCSS{X})\nuniform highp sampler2DShadow shadowSampler{X};\runiform highp sampler2D depthSampler{X};\r#elif defined(SHADOWPCF{X})\nuniform highp sampler2DShadow shadowSampler{X};\r#else\nuniform sampler2D shadowSampler{X};\r#endif\nuniform mat4 lightMatrix{X};\r#endif\nuniform vec4 shadowsInfo{X};\runiform vec2 depthValues{X};\r#endif\n#ifdef SPOTLIGHT{X}\nuniform vec4 vLightDirection{X};\runiform vec4 vLightFalloff{X};\r#elif defined(POINTLIGHT{X})\nuniform vec4 vLightFalloff{X};\r#elif defined(HEMILIGHT{X})\nuniform vec3 vLightGround{X};\r#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform mat4 textureProjectionMatrix{X};\runiform sampler2D projectionLightSampler{X};\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const lightFragmentDeclaration = { name, shader };\n//# sourceMappingURL=lightFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"lightUboDeclaration\";\nconst shader = `#ifdef LIGHT{X}\nuniform Light{X}\r{\rvec4 vLightData;\rvec4 vLightDiffuse;\rvec4 vLightSpecular;\r#ifdef SPOTLIGHT{X}\nvec4 vLightDirection;\rvec4 vLightFalloff;\r#elif defined(POINTLIGHT{X})\nvec4 vLightFalloff;\r#elif defined(HEMILIGHT{X})\nvec3 vLightGround;\r#endif\nvec4 shadowsInfo;\rvec2 depthValues;\r} light{X};\r#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform mat4 textureProjectionMatrix{X};\runiform sampler2D projectionLightSampler{X};\r#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\runiform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];\runiform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];\runiform float cascadeBlendFactor{X};\rvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\rvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\rvarying vec4 vPositionFromCamera{X};\r#if defined(SHADOWPCSS{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\runiform highp sampler2DArray depthSampler{X};\runiform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\runiform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\runiform float penumbraDarkness{X};\r#elif defined(SHADOWPCF{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\r#else\nuniform highp sampler2DArray shadowSampler{X};\r#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\r(\rvec3 ( 1.5,0.0,0.0 ),\rvec3 ( 0.0,1.5,0.0 ),\rvec3 ( 0.0,0.0,5.5 ),\rvec3 ( 1.5,0.0,5.5 ),\rvec3 ( 1.5,1.5,0.0 ),\rvec3 ( 1.0,1.0,1.0 ),\rvec3 ( 0.0,1.0,5.5 ),\rvec3 ( 0.5,3.5,0.75 )\r);\rvec3 shadowDebug{X};\r#endif\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nint index{X}=-1;\r#else\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\r#endif\nfloat diff{X}=0.;\r#elif defined(SHADOWCUBE{X})\nuniform samplerCube shadowSampler{X}; \r#else\nvarying vec4 vPositionFromLight{X};\rvarying float vDepthMetric{X};\r#if defined(SHADOWPCSS{X})\nuniform highp sampler2DShadow shadowSampler{X};\runiform highp sampler2D depthSampler{X};\r#elif defined(SHADOWPCF{X})\nuniform highp sampler2DShadow shadowSampler{X};\r#else\nuniform sampler2D shadowSampler{X};\r#endif\nuniform mat4 lightMatrix{X};\r#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const lightUboDeclaration = { name, shader };\n//# sourceMappingURL=lightUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"lightsFragmentFunctions\";\nconst shader = `struct lightingInfo\r{\rvec3 diffuse;\r#ifdef SPECULARTERM\nvec3 specular;\r#endif\n#ifdef NDOTL\nfloat ndl;\r#endif\n};\rlightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\rlightingInfo result;\rvec3 lightVectorW;\rfloat attenuation=1.0;\rif (lightData.w==0.)\r{\rvec3 direction=lightData.xyz-vPositionW;\rattenuation=max(0.,1.0-length(direction)/range);\rlightVectorW=normalize(direction);\r}\relse\r{\rlightVectorW=normalize(-lightData.xyz);\r}\rfloat ndl=max(0.,dot(vNormal,lightVectorW));\r#ifdef NDOTL\nresult.ndl=ndl;\r#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\r#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightVectorW);\rfloat specComp=max(0.,dot(vNormal,angleW));\rspecComp=pow(specComp,max(1.,glossiness));\rresult.specular=specComp*specularColor*attenuation;\r#endif\nreturn result;\r}\rlightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\rlightingInfo result;\rvec3 direction=lightData.xyz-vPositionW;\rvec3 lightVectorW=normalize(direction);\rfloat attenuation=max(0.,1.0-length(direction)/range);\rfloat cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));\rif (cosAngle>=lightDirection.w)\r{\rcosAngle=max(0.,pow(cosAngle,lightData.w));\rattenuation*=cosAngle;\rfloat ndl=max(0.,dot(vNormal,lightVectorW));\r#ifdef NDOTL\nresult.ndl=ndl;\r#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\r#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightVectorW);\rfloat specComp=max(0.,dot(vNormal,angleW));\rspecComp=pow(specComp,max(1.,glossiness));\rresult.specular=specComp*specularColor*attenuation;\r#endif\nreturn result;\r}\rresult.diffuse=vec3(0.);\r#ifdef SPECULARTERM\nresult.specular=vec3(0.);\r#endif\n#ifdef NDOTL\nresult.ndl=0.;\r#endif\nreturn result;\r}\rlightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {\rlightingInfo result;\rfloat ndl=dot(vNormal,lightData.xyz)*0.5+0.5;\r#ifdef NDOTL\nresult.ndl=ndl;\r#endif\nresult.diffuse=mix(groundColor,diffuseColor,ndl);\r#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightData.xyz);\rfloat specComp=max(0.,dot(vNormal,angleW));\rspecComp=pow(specComp,max(1.,glossiness));\rresult.specular=specComp*specularColor;\r#endif\nreturn result;\r}\r#define inline\nvec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){\rvec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);\rstrq/=strq.w;\rvec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;\rreturn textureColor;\r}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const lightsFragmentFunctions = { name, shader };\n//# sourceMappingURL=lightsFragmentFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"shadowsFragmentFunctions\";\nconst shader = `#ifdef SHADOWS\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)\n#else\n#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)\n#endif\n#ifndef SHADOWFLOAT\nfloat unpack(vec4 color)\r{\rconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\rreturn dot(color,bit_shift);\r}\r#endif\nfloat computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)\r{\rfloat mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));\rreturn mix(value,1.0,mask);\r}\r#define inline\nfloat computeShadowCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)\r{\rvec3 directionToLight=vPositionW-lightPosition;\rfloat depth=length(directionToLight);\rdepth=(depth+depthValues.x)/(depthValues.y);\rdepth=clamp(depth,0.,1.0);\rdirectionToLight=normalize(directionToLight);\rdirectionToLight.y=-directionToLight.y;\r#ifndef SHADOWFLOAT\nfloat shadow=unpack(textureCube(shadowSampler,directionToLight));\r#else\nfloat shadow=textureCube(shadowSampler,directionToLight).x;\r#endif\nreturn depth>shadow ? darkness : 1.0;\r}\r#define inline\nfloat computeShadowWithPoissonSamplingCube(vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)\r{\rvec3 directionToLight=vPositionW-lightPosition;\rfloat depth=length(directionToLight);\rdepth=(depth+depthValues.x)/(depthValues.y);\rdepth=clamp(depth,0.,1.0);\rdirectionToLight=normalize(directionToLight);\rdirectionToLight.y=-directionToLight.y;\rfloat visibility=1.;\rvec3 poissonDisk[4];\rpoissonDisk[0]=vec3(-1.0,1.0,-1.0);\rpoissonDisk[1]=vec3(1.0,-1.0,-1.0);\rpoissonDisk[2]=vec3(-1.0,-1.0,-1.0);\rpoissonDisk[3]=vec3(1.0,-1.0,1.0);\r#ifndef SHADOWFLOAT\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;\rif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;\rif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;\rif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;\r#else\nif (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;\rif (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;\rif (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;\rif (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;\r#endif\nreturn min(1.0,visibility+darkness);\r}\r#define inline\nfloat computeShadowWithESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\r{\rvec3 directionToLight=vPositionW-lightPosition;\rfloat depth=length(directionToLight);\rdepth=(depth+depthValues.x)/(depthValues.y);\rfloat shadowPixelDepth=clamp(depth,0.,1.0);\rdirectionToLight=normalize(directionToLight);\rdirectionToLight.y=-directionToLight.y;\r#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\r#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\r#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness); \rreturn esm;\r}\r#define inline\nfloat computeShadowWithCloseESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\r{\rvec3 directionToLight=vPositionW-lightPosition;\rfloat depth=length(directionToLight);\rdepth=(depth+depthValues.x)/(depthValues.y);\rfloat shadowPixelDepth=clamp(depth,0.,1.0);\rdirectionToLight=normalize(directionToLight);\rdirectionToLight.y=-directionToLight.y;\r#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\r#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\r#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\rreturn esm;\r}\r#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define inline\nfloat computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec2 uv=0.5*clipSpace.xy+vec2(0.5);\rvec3 uvLayer=vec3(uv.x,uv.y,layer);\rfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\r#ifndef SHADOWFLOAT\nfloat shadow=unpack(texture2D(shadowSampler,uvLayer));\r#else\nfloat shadow=texture2D(shadowSampler,uvLayer).x;\r#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;\r}\r#endif\n#define inline\nfloat computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec2 uv=0.5*clipSpace.xy+vec2(0.5);\rif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\r{\rreturn 1.0;\r}\relse\r{\rfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\r#ifndef SHADOWFLOAT\nfloat shadow=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\r#else\nfloat shadow=TEXTUREFUNC(shadowSampler,uv,0.).x;\r#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;\r}\r}\r#define inline\nfloat computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec2 uv=0.5*clipSpace.xy+vec2(0.5);\rif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\r{\rreturn 1.0;\r}\relse\r{\rfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\rfloat visibility=1.;\rvec2 poissonDisk[4];\rpoissonDisk[0]=vec2(-0.94201624,-0.39906216);\rpoissonDisk[1]=vec2(0.94558609,-0.76890725);\rpoissonDisk[2]=vec2(-0.094184101,-0.92938870);\rpoissonDisk[3]=vec2(0.34495938,0.29387760);\r#ifndef SHADOWFLOAT\nif (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;\rif (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;\rif (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;\rif (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;\r#else\nif (TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;\rif (TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;\rif (TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;\rif (TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;\r#endif\nreturn computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);\r}\r}\r#define inline\nfloat computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec2 uv=0.5*clipSpace.xy+vec2(0.5);\rif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\r{\rreturn 1.0;\r}\relse\r{\rfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\r#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\r#else\nfloat shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;\r#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);\rreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\r}\r}\r#define inline\nfloat computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec2 uv=0.5*clipSpace.xy+vec2(0.5);\rif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\r{\rreturn 1.0;\r}\relse\r{\rfloat shadowPixelDepth=clamp(depthMetric,0.,1.0); \r#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\r#else\nfloat shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;\r#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\rreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\r}\r}\r#ifdef IS_NDC_HALF_ZRANGE\n#define ZINCLIP clipSpace.z\n#else\n#define ZINCLIP uvDepth.z\n#endif\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define GREATEST_LESS_THAN_ONE 0.99999994\n#define inline\nfloat computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\rvec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);\rfloat shadow=texture2D(shadowSampler,uvDepthLayer);\rshadow=mix(darkness,1.,shadow);\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r#define inline\nfloat computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\rvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \ruv+=0.5; \rvec2 st=fract(uv); \rvec2 base_uv=floor(uv)-0.5; \rbase_uv*=shadowMapSizeAndInverse.y; \rvec2 uvw0=3.-2.*st;\rvec2 uvw1=1.+2.*st;\rvec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;\rvec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;\rfloat shadow=0.;\rshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));\rshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));\rshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));\rshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));\rshadow=shadow/16.;\rshadow=mix(darkness,1.,shadow);\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r#define inline\nfloat computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\rvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \ruv+=0.5; \rvec2 st=fract(uv); \rvec2 base_uv=floor(uv)-0.5; \rbase_uv*=shadowMapSizeAndInverse.y; \rvec2 uvw0=4.-3.*st;\rvec2 uvw1=vec2(7.);\rvec2 uvw2=1.+3.*st;\rvec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;\rvec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;\rfloat shadow=0.;\rshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));\rshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));\rshadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));\rshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));\rshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));\rshadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));\rshadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));\rshadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));\rshadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));\rshadow=shadow/144.;\rshadow=mix(darkness,1.,shadow);\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r#define inline\nfloat computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)\r{\rif (depthMetric>1.0 || depthMetric<0.0) {\rreturn 1.0;\r}\relse\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=ZINCLIP;\rfloat shadow=TEXTUREFUNC(shadowSampler,uvDepth,0.);\rshadow=mix(darkness,1.,shadow);\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r}\r#define inline\nfloat computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\r{\rif (depthMetric>1.0 || depthMetric<0.0) {\rreturn 1.0;\r}\relse\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=ZINCLIP;\rvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \ruv+=0.5; \rvec2 st=fract(uv); \rvec2 base_uv=floor(uv)-0.5; \rbase_uv*=shadowMapSizeAndInverse.y; \rvec2 uvw0=3.-2.*st;\rvec2 uvw1=1.+2.*st;\rvec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;\rvec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;\rfloat shadow=0.;\rshadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);\rshadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);\rshadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);\rshadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);\rshadow=shadow/16.;\rshadow=mix(darkness,1.,shadow);\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r}\r#define inline\nfloat computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\r{\rif (depthMetric>1.0 || depthMetric<0.0) {\rreturn 1.0;\r}\relse\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=ZINCLIP;\rvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \ruv+=0.5; \rvec2 st=fract(uv); \rvec2 base_uv=floor(uv)-0.5; \rbase_uv*=shadowMapSizeAndInverse.y; \rvec2 uvw0=4.-3.*st;\rvec2 uvw1=vec2(7.);\rvec2 uvw2=1.+3.*st;\rvec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;\rvec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;\rfloat shadow=0.;\rshadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);\rshadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);\rshadow+=uvw2.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z),0.);\rshadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);\rshadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);\rshadow+=uvw2.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z),0.);\rshadow+=uvw0.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z),0.);\rshadow+=uvw1.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z),0.);\rshadow+=uvw2.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z),0.);\rshadow=shadow/144.;\rshadow=mix(darkness,1.,shadow);\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r}\rconst vec3 PoissonSamplers32[64]=vec3[64](\rvec3(0.06407013,0.05409927,0.),\rvec3(0.7366577,0.5789394,0.),\rvec3(-0.6270542,-0.5320278,0.),\rvec3(-0.4096107,0.8411095,0.),\rvec3(0.6849564,-0.4990818,0.),\rvec3(-0.874181,-0.04579735,0.),\rvec3(0.9989998,0.0009880066,0.),\rvec3(-0.004920578,-0.9151649,0.),\rvec3(0.1805763,0.9747483,0.),\rvec3(-0.2138451,0.2635818,0.),\rvec3(0.109845,0.3884785,0.),\rvec3(0.06876755,-0.3581074,0.),\rvec3(0.374073,-0.7661266,0.),\rvec3(0.3079132,-0.1216763,0.),\rvec3(-0.3794335,-0.8271583,0.),\rvec3(-0.203878,-0.07715034,0.),\rvec3(0.5912697,0.1469799,0.),\rvec3(-0.88069,0.3031784,0.),\rvec3(0.5040108,0.8283722,0.),\rvec3(-0.5844124,0.5494877,0.),\rvec3(0.6017799,-0.1726654,0.),\rvec3(-0.5554981,0.1559997,0.),\rvec3(-0.3016369,-0.3900928,0.),\rvec3(-0.5550632,-0.1723762,0.),\rvec3(0.925029,0.2995041,0.),\rvec3(-0.2473137,0.5538505,0.),\rvec3(0.9183037,-0.2862392,0.),\rvec3(0.2469421,0.6718712,0.),\rvec3(0.3916397,-0.4328209,0.),\rvec3(-0.03576927,-0.6220032,0.),\rvec3(-0.04661255,0.7995201,0.),\rvec3(0.4402924,0.3640312,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.)\r);\rconst vec3 PoissonSamplers64[64]=vec3[64](\rvec3(-0.613392,0.617481,0.),\rvec3(0.170019,-0.040254,0.),\rvec3(-0.299417,0.791925,0.),\rvec3(0.645680,0.493210,0.),\rvec3(-0.651784,0.717887,0.),\rvec3(0.421003,0.027070,0.),\rvec3(-0.817194,-0.271096,0.),\rvec3(-0.705374,-0.668203,0.),\rvec3(0.977050,-0.108615,0.),\rvec3(0.063326,0.142369,0.),\rvec3(0.203528,0.214331,0.),\rvec3(-0.667531,0.326090,0.),\rvec3(-0.098422,-0.295755,0.),\rvec3(-0.885922,0.215369,0.),\rvec3(0.566637,0.605213,0.),\rvec3(0.039766,-0.396100,0.),\rvec3(0.751946,0.453352,0.),\rvec3(0.078707,-0.715323,0.),\rvec3(-0.075838,-0.529344,0.),\rvec3(0.724479,-0.580798,0.),\rvec3(0.222999,-0.215125,0.),\rvec3(-0.467574,-0.405438,0.),\rvec3(-0.248268,-0.814753,0.),\rvec3(0.354411,-0.887570,0.),\rvec3(0.175817,0.382366,0.),\rvec3(0.487472,-0.063082,0.),\rvec3(-0.084078,0.898312,0.),\rvec3(0.488876,-0.783441,0.),\rvec3(0.470016,0.217933,0.),\rvec3(-0.696890,-0.549791,0.),\rvec3(-0.149693,0.605762,0.),\rvec3(0.034211,0.979980,0.),\rvec3(0.503098,-0.308878,0.),\rvec3(-0.016205,-0.872921,0.),\rvec3(0.385784,-0.393902,0.),\rvec3(-0.146886,-0.859249,0.),\rvec3(0.643361,0.164098,0.),\rvec3(0.634388,-0.049471,0.),\rvec3(-0.688894,0.007843,0.),\rvec3(0.464034,-0.188818,0.),\rvec3(-0.440840,0.137486,0.),\rvec3(0.364483,0.511704,0.),\rvec3(0.034028,0.325968,0.),\rvec3(0.099094,-0.308023,0.),\rvec3(0.693960,-0.366253,0.),\rvec3(0.678884,-0.204688,0.),\rvec3(0.001801,0.780328,0.),\rvec3(0.145177,-0.898984,0.),\rvec3(0.062655,-0.611866,0.),\rvec3(0.315226,-0.604297,0.),\rvec3(-0.780145,0.486251,0.),\rvec3(-0.371868,0.882138,0.),\rvec3(0.200476,0.494430,0.),\rvec3(-0.494552,-0.711051,0.),\rvec3(0.612476,0.705252,0.),\rvec3(-0.578845,-0.768792,0.),\rvec3(-0.772454,-0.090976,0.),\rvec3(0.504440,0.372295,0.),\rvec3(0.155736,0.065157,0.),\rvec3(0.391522,0.849605,0.),\rvec3(-0.620106,-0.328104,0.),\rvec3(0.789239,-0.419965,0.),\rvec3(-0.545396,0.538133,0.),\rvec3(-0.178564,-0.596057,0.)\r);\r#define inline\nfloat computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\rvec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);\rfloat blockerDepth=0.0;\rfloat sumBlockerDepth=0.0;\rfloat numBlocker=0.0;\rfor (int i=0; i<searchTapCount; i ++) {\rblockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;\rif (blockerDepth<depthMetric) {\rsumBlockerDepth+=blockerDepth;\rnumBlocker++;\r}\r}\rfloat avgBlockerDepth=sumBlockerDepth/numBlocker;\rfloat AAOffset=shadowMapSizeInverse*10.;\rfloat penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);\rvec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);\rfloat random=getRand(vPositionFromLight.xy);\rfloat rotationAngle=random*3.1415926;\rvec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));\rfloat shadow=0.;\rfor (int i=0; i<pcfTapCount; i++) {\rvec4 offset=vec4(poissonSamplers[i],0.);\roffset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);\rshadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);\r}\rshadow/=float(pcfTapCount);\rshadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));\rshadow=mix(darkness,1.,shadow);\rif (numBlocker<1.0) {\rreturn 1.0;\r}\relse\r{\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r}\r#define inline\nfloat computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)\r{\rif (depthMetric>1.0 || depthMetric<0.0) {\rreturn 1.0;\r}\relse\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=ZINCLIP;\rfloat blockerDepth=0.0;\rfloat sumBlockerDepth=0.0;\rfloat numBlocker=0.0;\rfor (int i=0; i<searchTapCount; i ++) {\rblockerDepth=TEXTUREFUNC(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy),0.).r;\rif (blockerDepth<depthMetric) {\rsumBlockerDepth+=blockerDepth;\rnumBlocker++;\r}\r}\rif (numBlocker<1.0) {\rreturn 1.0;\r}\relse\r{\rfloat avgBlockerDepth=sumBlockerDepth/numBlocker;\rfloat AAOffset=shadowMapSizeInverse*10.;\rfloat penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);\rfloat filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;\rfloat random=getRand(vPositionFromLight.xy);\rfloat rotationAngle=random*3.1415926;\rvec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));\rfloat shadow=0.;\rfor (int i=0; i<pcfTapCount; i++) {\rvec3 offset=poissonSamplers[i];\roffset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);\rshadow+=TEXTUREFUNC(shadowSampler,uvDepth+offset*filterRadius,0.);\r}\rshadow/=float(pcfTapCount);\rshadow=mix(shadow,1.,depthMetric-avgBlockerDepth);\rshadow=mix(darkness,1.,shadow);\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r}\r}\r#define inline\nfloat computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\r{\rreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);\r}\r#define inline\nfloat computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\r{\rreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);\r}\r#define inline\nfloat computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\r{\rreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);\r}\r#define inline\nfloat computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\r{\rreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\r}\r#define inline\nfloat computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\r{\rreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\r}\r#define inline\nfloat computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\r{\rreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\r}\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const shadowsFragmentFunctions = { name, shader };\n//# sourceMappingURL=shadowsFragmentFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"samplerFragmentDeclaration\";\nconst shader = `#ifdef _DEFINENAME_\n#if _DEFINENAME_DIRECTUV==1\n#define v_VARYINGNAME_UV vMainUV1\n#elif _DEFINENAME_DIRECTUV==2\n#define v_VARYINGNAME_UV vMainUV2\n#elif _DEFINENAME_DIRECTUV==3\n#define v_VARYINGNAME_UV vMainUV3\n#elif _DEFINENAME_DIRECTUV==4\n#define v_VARYINGNAME_UV vMainUV4\n#elif _DEFINENAME_DIRECTUV==5\n#define v_VARYINGNAME_UV vMainUV5\n#elif _DEFINENAME_DIRECTUV==6\n#define v_VARYINGNAME_UV vMainUV6\n#else\nvarying vec2 v_VARYINGNAME_UV;\r#endif\nuniform sampler2D _SAMPLERNAME_Sampler;\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const samplerFragmentDeclaration = { name, shader };\n//# sourceMappingURL=samplerFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"fresnelFunction\";\nconst shader = `#ifdef FRESNEL\nfloat computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)\r{\rfloat fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);\rreturn clamp(fresnelTerm,0.,1.);\r}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const fresnelFunction = { name, shader };\n//# sourceMappingURL=fresnelFunction.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"reflectionFunction\";\nconst shader = `vec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\r{\rfloat lon=atan(direction.z,direction.x);\rfloat lat=acos(direction.y);\rvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\rfloat s=sphereCoords.x*0.5+0.5;\rfloat t=sphereCoords.y;\rreturn vec3(s,t,0); \r}\rvec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\r{\rfloat lon=atan(direction.z,direction.x);\rfloat lat=acos(direction.y);\rvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\rfloat s=sphereCoords.x*0.5+0.5;\rfloat t=sphereCoords.y;\rreturn vec3(1.0-s,t,0); \r}\rvec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\r{\rvec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);\rvec3 r=normalize(reflect(cameraToVertex,worldNormal));\rr=vec3(reflectionMatrix*vec4(r,0));\rfloat lon=atan(r.z,r.x);\rfloat lat=acos(r.y);\rvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\rfloat s=sphereCoords.x*0.5+0.5;\rfloat t=sphereCoords.y;\rreturn vec3(s,t,0);\r}\rvec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)\r{\rvec3 viewDir=normalize(vec3(view*worldPos));\rvec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));\rvec3 r=reflect(viewDir,viewNormal);\rr=vec3(reflectionMatrix*vec4(r,0));\rr.z=r.z-1.0;\rfloat m=2.0*length(r);\rreturn vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);\r}\rvec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\r{\rvec3 viewDir=worldPos.xyz-eyePosition;\rvec3 coords=normalize(reflect(viewDir,worldNormal));\rreturn vec3(reflectionMatrix*vec4(coords,1));\r}\rvec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\r{\rvec3 viewDir=normalize(worldPos.xyz-eyePosition);\rvec3 coords=reflect(viewDir,worldNormal);\rcoords=vec3(reflectionMatrix*vec4(coords,0));\r#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\r#endif\nreturn coords;\r}\rvec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)\r{\rvec3 viewDir=normalize(worldPos.xyz-eyePosition);\rvec3 coords=reflect(viewDir,worldNormal);\rcoords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);\rcoords=vec3(reflectionMatrix*vec4(coords,0));\r#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\r#endif\nreturn coords;\r}\rvec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)\r{\rreturn vec3(reflectionMatrix*(view*worldPos));\r}\rvec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)\r{\rreturn vec3(reflectionMatrix*vec4(positionW,1.));\r}\r#ifdef REFLECTION\nvec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)\r{\r#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);\rreturn computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);\r#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);\rreturn computeFixedEquirectangularCoords(worldPos,worldNormal,direction);\r#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\nreturn computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\r#endif\n#ifdef REFLECTIONMAP_SPHERICAL\nreturn computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);\r#endif\n#ifdef REFLECTIONMAP_PLANAR\nreturn computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\r#endif\n#ifdef REFLECTIONMAP_CUBIC\n#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC\nreturn computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);\r#else\nreturn computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\r#endif\n#endif\n#ifdef REFLECTIONMAP_PROJECTION\nreturn computeProjectionCoords(worldPos,view,reflectionMatrix);\r#endif\n#ifdef REFLECTIONMAP_SKYBOX\nreturn computeSkyBoxCoords(vPositionUVW,reflectionMatrix);\r#endif\n#ifdef REFLECTIONMAP_EXPLICIT\nreturn vec3(0,0,0);\r#endif\n}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const reflectionFunction = { name, shader };\n//# sourceMappingURL=reflectionFunction.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"imageProcessingDeclaration\";\nconst shader = `#ifdef EXPOSURE\nuniform float exposureLinear;\r#endif\n#ifdef CONTRAST\nuniform float contrast;\r#endif\n#if defined(VIGNETTE) || defined(DITHER)\nuniform vec2 vInverseScreenSize;\r#endif\n#ifdef VIGNETTE\nuniform vec4 vignetteSettings1;\runiform vec4 vignetteSettings2;\r#endif\n#ifdef COLORCURVES\nuniform vec4 vCameraColorCurveNegative;\runiform vec4 vCameraColorCurveNeutral;\runiform vec4 vCameraColorCurvePositive;\r#endif\n#ifdef COLORGRADING\n#ifdef COLORGRADING3D\nuniform highp sampler3D txColorTransform;\r#else\nuniform sampler2D txColorTransform;\r#endif\nuniform vec4 colorTransformSettings;\r#endif\n#ifdef DITHER\nuniform float ditherIntensity;\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const imageProcessingDeclaration = { name, shader };\n//# sourceMappingURL=imageProcessingDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"imageProcessingFunctions\";\nconst shader = `#if defined(COLORGRADING) && !defined(COLORGRADING3D)\n/** \r* Polyfill for SAMPLE_TEXTURE_3D,which is unsupported in WebGL.\r* sampler3dSetting.x=textureOffset (0.5/textureSize).\r* sampler3dSetting.y=textureSize.\r*/\r#define inline\nvec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)\r{\rfloat sliceSize=2.0*sampler3dSetting.x; \r#ifdef SAMPLER3DGREENDEPTH\nfloat sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;\r#else\nfloat sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;\r#endif\nfloat sliceInteger=floor(sliceContinuous);\rfloat sliceFraction=sliceContinuous-sliceInteger;\r#ifdef SAMPLER3DGREENDEPTH\nvec2 sliceUV=color.rb;\r#else\nvec2 sliceUV=color.rg;\r#endif\nsliceUV.x*=sliceSize;\rsliceUV.x+=sliceInteger*sliceSize;\rsliceUV=saturate(sliceUV);\rvec4 slice0Color=texture2D(colorTransform,sliceUV);\rsliceUV.x+=sliceSize;\rsliceUV=saturate(sliceUV);\rvec4 slice1Color=texture2D(colorTransform,sliceUV);\rvec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);\r#ifdef SAMPLER3DBGRMAP\ncolor.rgb=result.rgb;\r#else\ncolor.rgb=result.bgr;\r#endif\nreturn color;\r}\r#endif\n#ifdef TONEMAPPING_ACES\nconst mat3 ACESInputMat=mat3(\rvec3(0.59719,0.07600,0.02840),\rvec3(0.35458,0.90834,0.13383),\rvec3(0.04823,0.01566,0.83777)\r);\rconst mat3 ACESOutputMat=mat3(\rvec3( 1.60475,-0.10208,-0.00327),\rvec3(-0.53108, 1.10813,-0.07276),\rvec3(-0.07367,-0.00605, 1.07602)\r);\rvec3 RRTAndODTFit(vec3 v)\r{\rvec3 a=v*(v+0.0245786)-0.000090537;\rvec3 b=v*(0.983729*v+0.4329510)+0.238081;\rreturn a/b;\r}\rvec3 ACESFitted(vec3 color)\r{\rcolor=ACESInputMat*color;\rcolor=RRTAndODTFit(color);\rcolor=ACESOutputMat*color;\rcolor=saturate(color);\rreturn color;\r}\r#endif\n#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_DEFINITIONS\nvec4 applyImageProcessing(vec4 result) {\r#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATSTART\n#ifdef EXPOSURE\nresult.rgb*=exposureLinear;\r#endif\n#ifdef VIGNETTE\nvec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;\rviewportXY=viewportXY*2.0-1.0;\rvec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);\rfloat vignetteTerm=dot(vignetteXY1,vignetteXY1);\rfloat vignette=pow(vignetteTerm,vignetteSettings2.w);\rvec3 vignetteColor=vignetteSettings2.rgb;\r#ifdef VIGNETTEBLENDMODEMULTIPLY\nvec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);\rresult.rgb*=vignetteColorMultiplier;\r#endif\n#ifdef VIGNETTEBLENDMODEOPAQUE\nresult.rgb=mix(vignetteColor,result.rgb,vignette);\r#endif\n#endif\n#ifdef TONEMAPPING\n#ifdef TONEMAPPING_ACES\nresult.rgb=ACESFitted(result.rgb);\r#else\nconst float tonemappingCalibration=1.590579;\rresult.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);\r#endif\n#endif\nresult.rgb=toGammaSpace(result.rgb);\rresult.rgb=saturate(result.rgb);\r#ifdef CONTRAST\nvec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);\rif (contrast<1.0) {\rresult.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);\r} else {\rresult.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);\r}\r#endif\n#ifdef COLORGRADING\nvec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;\r#ifdef COLORGRADING3D\nvec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;\r#else\nvec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;\r#endif\nresult.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);\r#endif\n#ifdef COLORCURVES\nfloat luma=getLuminance(result.rgb);\rvec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));\rvec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;\rresult.rgb*=colorCurve.rgb;\rresult.rgb=mix(vec3(luma),result.rgb,colorCurve.a);\r#endif\n#ifdef DITHER\nfloat rand=getRand(gl_FragCoord.xy*vInverseScreenSize);\rfloat dither=mix(-ditherIntensity,ditherIntensity,rand);\rresult.rgb=saturate(result.rgb+vec3(dither));\r#endif\n#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATEND\nreturn result;\r}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const imageProcessingFunctions = { name, shader };\n//# sourceMappingURL=imageProcessingFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"bumpFragmentMainFunctions\";\nconst shader = `#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)\n#if defined(TANGENT) && defined(NORMAL) \nvarying mat3 vTBN;\r#endif\n#ifdef OBJECTSPACE_NORMALMAP\nuniform mat4 normalMatrix;\r#if defined(WEBGL2) || defined(WEBGPU)\nmat4 toNormalMatrix(mat4 wMatrix)\r{\rmat4 ret=inverse(wMatrix);\rret=transpose(ret);\rret[0][3]=0.;\rret[1][3]=0.;\rret[2][3]=0.;\rret[3]=vec4(0.,0.,0.,1.);\rreturn ret;\r}\r#else\nmat4 toNormalMatrix(mat4 m)\r{\rfloat\ra00=m[0][0],a01=m[0][1],a02=m[0][2],a03=m[0][3],\ra10=m[1][0],a11=m[1][1],a12=m[1][2],a13=m[1][3],\ra20=m[2][0],a21=m[2][1],a22=m[2][2],a23=m[2][3],\ra30=m[3][0],a31=m[3][1],a32=m[3][2],a33=m[3][3],\rb00=a00*a11-a01*a10,\rb01=a00*a12-a02*a10,\rb02=a00*a13-a03*a10,\rb03=a01*a12-a02*a11,\rb04=a01*a13-a03*a11,\rb05=a02*a13-a03*a12,\rb06=a20*a31-a21*a30,\rb07=a20*a32-a22*a30,\rb08=a20*a33-a23*a30,\rb09=a21*a32-a22*a31,\rb10=a21*a33-a23*a31,\rb11=a22*a33-a23*a32,\rdet=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;\rmat4 mi=mat4(\ra11*b11-a12*b10+a13*b09,\ra02*b10-a01*b11-a03*b09,\ra31*b05-a32*b04+a33*b03,\ra22*b04-a21*b05-a23*b03,\ra12*b08-a10*b11-a13*b07,\ra00*b11-a02*b08+a03*b07,\ra32*b02-a30*b05-a33*b01,\ra20*b05-a22*b02+a23*b01,\ra10*b10-a11*b08+a13*b06,\ra01*b08-a00*b10-a03*b06,\ra30*b04-a31*b02+a33*b00,\ra21*b02-a20*b04-a23*b00,\ra11*b07-a10*b09-a12*b06,\ra00*b09-a01*b07+a02*b06,\ra31*b01-a30*b03-a32*b00,\ra20*b03-a21*b01+a22*b00)/det;\rreturn mat4(mi[0][0],mi[1][0],mi[2][0],mi[3][0],\rmi[0][1],mi[1][1],mi[2][1],mi[3][1],\rmi[0][2],mi[1][2],mi[2][2],mi[3][2],\rmi[0][3],mi[1][3],mi[2][3],mi[3][3]);\r}\r#endif\n#endif\nvec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)\r{\r#ifdef NORMALXYSCALE\nnormal=normalize(normal*vec3(scale,scale,1.0));\r#endif\nreturn normalize(cotangentFrame*normal);\r}\rvec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)\r{\rreturn perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);\r}\rmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)\r{\rvec3 dp1=dFdx(p);\rvec3 dp2=dFdy(p);\rvec2 duv1=dFdx(uv);\rvec2 duv2=dFdy(uv);\rvec3 dp2perp=cross(dp2,normal);\rvec3 dp1perp=cross(normal,dp1);\rvec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;\rvec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;\rtangent*=tangentSpaceParams.x;\rbitangent*=tangentSpaceParams.y;\rfloat det=max(dot(tangent,tangent),dot(bitangent,bitangent));\rfloat invmax=det==0.0 ? 0.0 : inversesqrt(det);\rreturn mat3(tangent*invmax,bitangent*invmax,normal);\r}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bumpFragmentMainFunctions = { name, shader };\n//# sourceMappingURL=bumpFragmentMainFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nimport \"./samplerFragmentDeclaration.js\";\nconst name = \"bumpFragmentFunctions\";\nconst shader = `#if defined(BUMP)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)\n#endif\n#if defined(DETAIL)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)\n#endif\n#if defined(BUMP) && defined(PARALLAX)\nconst float minSamples=4.;\rconst float maxSamples=15.;\rconst int iMaxSamples=15;\rvec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {\rfloat parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;\rparallaxLimit*=parallaxScale;\rvec2 vOffsetDir=normalize(vViewDirCoT.xy);\rvec2 vMaxOffset=vOffsetDir*parallaxLimit;\rfloat numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));\rfloat stepSize=1.0/numSamples;\rfloat currRayHeight=1.0;\rvec2 vCurrOffset=vec2(0,0);\rvec2 vLastOffset=vec2(0,0);\rfloat lastSampledHeight=1.0;\rfloat currSampledHeight=1.0;\rbool keepWorking=true;\rfor (int i=0; i<iMaxSamples; i++)\r{\rcurrSampledHeight=texture2D(bumpSampler,texCoord+vCurrOffset).w;\rif (!keepWorking)\r{\r}\relse if (currSampledHeight>currRayHeight)\r{\rfloat delta1=currSampledHeight-currRayHeight;\rfloat delta2=(currRayHeight+stepSize)-lastSampledHeight;\rfloat ratio=delta1/(delta1+delta2);\rvCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;\rkeepWorking=false;\r}\relse\r{\rcurrRayHeight-=stepSize;\rvLastOffset=vCurrOffset;\rvCurrOffset+=stepSize*vMaxOffset;\rlastSampledHeight=currSampledHeight;\r}\r}\rreturn vCurrOffset;\r}\rvec2 parallaxOffset(vec3 viewDir,float heightScale)\r{\rfloat height=texture2D(bumpSampler,vBumpUV).w;\rvec2 texCoordOffset=heightScale*viewDir.xy*height;\rreturn -texCoordOffset;\r}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bumpFragmentFunctions = { name, shader };\n//# sourceMappingURL=bumpFragmentFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"logDepthDeclaration\";\nconst shader = `#ifdef LOGARITHMICDEPTH\nuniform float logarithmicDepthConstant;\rvarying float vFragmentDepth;\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const logDepthDeclaration = { name, shader };\n//# sourceMappingURL=logDepthDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"fogFragmentDeclaration\";\nconst shader = `#ifdef FOG\n#define FOGMODE_NONE 0.\n#define FOGMODE_EXP 1.\n#define FOGMODE_EXP2 2.\n#define FOGMODE_LINEAR 3.\n#define E 2.71828\nuniform vec4 vFogInfos;\runiform vec3 vFogColor;\rvarying vec3 vFogDistance;\rfloat CalcFogFactor()\r{\rfloat fogCoeff=1.0;\rfloat fogStart=vFogInfos.y;\rfloat fogEnd=vFogInfos.z;\rfloat fogDensity=vFogInfos.w;\rfloat fogDistance=length(vFogDistance);\rif (FOGMODE_LINEAR==vFogInfos.x)\r{\rfogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);\r}\relse if (FOGMODE_EXP==vFogInfos.x)\r{\rfogCoeff=1.0/pow(E,fogDistance*fogDensity);\r}\relse if (FOGMODE_EXP2==vFogInfos.x)\r{\rfogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);\r}\rreturn clamp(fogCoeff,0.0,1.0);\r}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const fogFragmentDeclaration = { name, shader };\n//# sourceMappingURL=fogFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"bumpFragment\";\nconst shader = `vec2 uvOffset=vec2(0.0,0.0);\r#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\n#ifdef NORMALXYSCALE\nfloat normalScale=1.0;\r#elif defined(BUMP)\nfloat normalScale=vBumpInfos.y;\r#else\nfloat normalScale=1.0;\r#endif\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\r#elif defined(BUMP)\nvec2 TBNUV=gl_FrontFacing ? vBumpUV : -vBumpUV;\rmat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);\r#else\nvec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;\rmat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));\r#endif\n#elif defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\r#else\nvec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;\rmat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));\r#endif\n#endif\n#ifdef PARALLAX\nmat3 invTBN=transposeMat3(TBN);\r#ifdef PARALLAXOCCLUSION\nuvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);\r#else\nuvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);\r#endif\n#endif\n#ifdef DETAIL\nvec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);\rvec2 detailNormalRG=detailColor.wy*2.0-1.0;\rfloat detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));\rvec3 detailNormal=vec3(detailNormalRG,detailNormalB);\r#endif\n#ifdef BUMP\n#ifdef OBJECTSPACE_NORMALMAP\n#define CUSTOM_FRAGMENT_BUMP_FRAGMENT\nnormalW=normalize(texture2D(bumpSampler,vBumpUV).xyz *2.0-1.0);\rnormalW=normalize(mat3(normalMatrix)*normalW);\r#elif !defined(DETAIL)\nnormalW=perturbNormal(TBN,texture2D(bumpSampler,vBumpUV+uvOffset).xyz,vBumpInfos.y);\r#else\nvec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;\r#if DETAIL_NORMALBLENDMETHOD==0 \ndetailNormal.xy*=vDetailInfos.z;\rvec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));\r#elif DETAIL_NORMALBLENDMETHOD==1 \ndetailNormal.xy*=vDetailInfos.z;\rbumpNormal+=vec3(0.0,0.0,1.0);\rdetailNormal*=vec3(-1.0,-1.0,1.0);\rvec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;\r#endif\nnormalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);\r#endif\n#elif defined(DETAIL)\ndetailNormal.xy*=vDetailInfos.z;\rnormalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bumpFragment = { name, shader };\n//# sourceMappingURL=bumpFragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"decalFragment\";\nconst shader = `#ifdef DECAL\n#ifdef GAMMADECAL\ndecalColor.rgb=toLinearSpace(decalColor.rgb);\r#endif\n#ifdef DECAL_SMOOTHALPHA\ndecalColor.a*=decalColor.a;\r#endif\nsurfaceAlbedo.rgb=mix(surfaceAlbedo.rgb,decalColor.rgb,decalColor.a);\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const decalFragment = { name, shader };\n//# sourceMappingURL=decalFragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"depthPrePass\";\nconst shader = `#ifdef DEPTHPREPASS\ngl_FragColor=vec4(0.,0.,0.,1.0);\rreturn;\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const depthPrePass = { name, shader };\n//# sourceMappingURL=depthPrePass.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"lightFragment\";\nconst shader = `#ifdef LIGHT{X}\n#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n#else\n#ifdef PBR\n#ifdef SPOTLIGHT{X}\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\r#elif defined(POINTLIGHT{X})\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\r#elif defined(HEMILIGHT{X})\npreInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\r#elif defined(DIRLIGHT{X})\npreInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\r#endif\npreInfo.NdotV=NdotV;\r#ifdef SPOTLIGHT{X}\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\rpreInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\r#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\rpreInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);\r#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\rpreInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);\r#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\rpreInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\r#endif\n#elif defined(POINTLIGHT{X})\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\r#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\r#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\r#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\r#endif\n#else\npreInfo.attenuation=1.0;\r#endif\n#ifdef HEMILIGHT{X}\npreInfo.roughness=roughness;\r#else\npreInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\r#endif\n#ifdef IRIDESCENCE\npreInfo.iridescenceIntensity=iridescenceIntensity;\r#endif\n#ifdef HEMILIGHT{X}\ninfo.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);\r#elif defined(SS_TRANSLUCENCY)\ninfo.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);\r#else\ninfo.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);\r#endif\n#ifdef SPECULARTERM\n#ifdef ANISOTROPIC\ninfo.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\r#else\ninfo.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\r#endif\n#endif\n#ifdef SHEEN\n#ifdef SHEEN_LINKWITHALBEDO\npreInfo.roughness=sheenOut.sheenIntensity;\r#else\n#ifdef HEMILIGHT{X}\npreInfo.roughness=sheenOut.sheenRoughness;\r#else\npreInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\r#endif\n#endif\ninfo.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\r#endif\n#ifdef CLEARCOAT\n#ifdef HEMILIGHT{X}\npreInfo.roughness=clearcoatOut.clearCoatRoughness;\r#else\npreInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\r#endif\ninfo.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);\r#ifdef CLEARCOAT_TINT\nabsorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);\rinfo.diffuse*=absorption;\r#ifdef SPECULARTERM\ninfo.specular*=absorption;\r#endif\n#endif\ninfo.diffuse*=info.clearCoat.w;\r#ifdef SPECULARTERM\ninfo.specular*=info.clearCoat.w;\r#endif\n#ifdef SHEEN\ninfo.sheen*=info.clearCoat.w;\r#endif\n#endif\n#else\n#ifdef SPOTLIGHT{X}\ninfo=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\r#elif defined(HEMILIGHT{X})\ninfo=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);\r#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\ninfo=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\r#endif\n#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\ninfo.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});\r#endif\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) \r{\r#ifdef SHADOWCSM_RIGHTHANDED{X}\ndiff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;\r#else\ndiff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;\r#endif\nif (diff{X}>=0.) {\rindex{X}=i;\rbreak;\r}\r}\r#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nif (index{X}>=0)\r#endif\n{\r#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#else\nshadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\r#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\r#else\nshadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\r#endif\n#else\nshadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#endif\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];\r#endif\n#ifndef SHADOWCSMNOBLEND{X}\nfloat frustumLength=frustumLengths{X}[index{X}];\rfloat diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};\rif (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)\r{\rindex{X}+=1;\rfloat nextShadow=0.;\r#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#else\nnextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\r#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\r#else\nnextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\r#endif\n#else\nnextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#endif\nshadow=mix(nextShadow,shadow,diffRatio);\r#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);\r#endif\n}\r#endif\n}\r#elif defined(SHADOWCLOSEESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithCloseESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\r#else\nshadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\r#endif\n#elif defined(SHADOWESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\r#else\nshadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\r#endif\n#elif defined(SHADOWPOISSON{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);\r#else\nshadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#endif\n#elif defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#else\nshadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#else\nshadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#endif\n#else\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);\r#else\nshadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#endif\n#endif\n#ifdef SHADOWONLY\n#ifndef SHADOWINUSE\n#define SHADOWINUSE\n#endif\nglobalShadow+=shadow;\rshadowLightCount+=1.0;\r#endif\n#else\nshadow=1.;\r#endif\n#ifndef SHADOWONLY\n#ifdef CUSTOMUSERLIGHTING\ndiffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);\r#ifdef SPECULARTERM\nspecularBase+=computeCustomSpecularLighting(info,specularBase,shadow);\r#endif\n#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\ndiffuseBase+=lightmapColor.rgb*shadow;\r#ifdef SPECULARTERM\n#ifndef LIGHTMAPNOSPECULAR{X}\nspecularBase+=info.specular*shadow*lightmapColor.rgb;\r#endif\n#endif\n#ifdef CLEARCOAT\n#ifndef LIGHTMAPNOSPECULAR{X}\nclearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;\r#endif\n#endif\n#ifdef SHEEN\n#ifndef LIGHTMAPNOSPECULAR{X}\nsheenBase+=info.sheen.rgb*shadow;\r#endif\n#endif\n#else\n#ifdef SHADOWCSMDEBUG{X}\ndiffuseBase+=info.diffuse*shadowDebug{X};\r#else \ndiffuseBase+=info.diffuse*shadow;\r#endif\n#ifdef SPECULARTERM\nspecularBase+=info.specular*shadow;\r#endif\n#ifdef CLEARCOAT\nclearCoatBase+=info.clearCoat.rgb*shadow;\r#endif\n#ifdef SHEEN\nsheenBase+=info.sheen.rgb*shadow;\r#endif\n#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const lightFragment = { name, shader };\n//# sourceMappingURL=lightFragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"oitFragment\";\nconst shader = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY\nfloat fragDepth=gl_FragCoord.z; \r#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS\nuint halfFloat=packHalf2x16(vec2(fragDepth));\rvec2 full=unpackHalf2x16(halfFloat);\rfragDepth=full.x;\r#endif\nivec2 fragCoord=ivec2(gl_FragCoord.xy);\rvec2 lastDepth=texelFetch(oitDepthSampler,fragCoord,0).rg;\rvec4 lastFrontColor=texelFetch(oitFrontColorSampler,fragCoord,0);\rdepth.rg=vec2(-MAX_DEPTH);\rfrontColor=lastFrontColor;\rbackColor=vec4(0.0);\r#ifdef USE_REVERSE_DEPTHBUFFER\nfloat furthestDepth=-lastDepth.x;\rfloat nearestDepth=lastDepth.y;\r#else\nfloat nearestDepth=-lastDepth.x;\rfloat furthestDepth=lastDepth.y;\r#endif\nfloat alphaMultiplier=1.0-lastFrontColor.a;\r#ifdef USE_REVERSE_DEPTHBUFFER\nif (fragDepth>nearestDepth || fragDepth<furthestDepth) {\r#else\nif (fragDepth<nearestDepth || fragDepth>furthestDepth) {\r#endif\nreturn;\r}\r#ifdef USE_REVERSE_DEPTHBUFFER\nif (fragDepth<nearestDepth && fragDepth>furthestDepth) {\r#else\nif (fragDepth>nearestDepth && fragDepth<furthestDepth) {\r#endif\ndepth.rg=vec2(-fragDepth,fragDepth);\rreturn;\r}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const oitFragment = { name, shader };\n//# sourceMappingURL=oitFragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/defaultFragmentDeclaration.js\";\nimport \"./ShadersInclude/defaultUboDeclaration.js\";\nimport \"./ShadersInclude/prePassDeclaration.js\";\nimport \"./ShadersInclude/oitDeclaration.js\";\nimport \"./ShadersInclude/mainUVVaryingDeclaration.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/lightFragmentDeclaration.js\";\nimport \"./ShadersInclude/lightUboDeclaration.js\";\nimport \"./ShadersInclude/lightsFragmentFunctions.js\";\nimport \"./ShadersInclude/shadowsFragmentFunctions.js\";\nimport \"./ShadersInclude/samplerFragmentDeclaration.js\";\nimport \"./ShadersInclude/fresnelFunction.js\";\nimport \"./ShadersInclude/reflectionFunction.js\";\nimport \"./ShadersInclude/imageProcessingDeclaration.js\";\nimport \"./ShadersInclude/imageProcessingFunctions.js\";\nimport \"./ShadersInclude/bumpFragmentMainFunctions.js\";\nimport \"./ShadersInclude/bumpFragmentFunctions.js\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration.js\";\nimport \"./ShadersInclude/logDepthDeclaration.js\";\nimport \"./ShadersInclude/fogFragmentDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneFragment.js\";\nimport \"./ShadersInclude/bumpFragment.js\";\nimport \"./ShadersInclude/decalFragment.js\";\nimport \"./ShadersInclude/depthPrePass.js\";\nimport \"./ShadersInclude/lightFragment.js\";\nimport \"./ShadersInclude/logDepthFragment.js\";\nimport \"./ShadersInclude/fogFragment.js\";\nimport \"./ShadersInclude/oitFragment.js\";\nconst name = \"defaultPixelShader\";\nconst shader = `#include<__decl__defaultFragment>\n#if defined(BUMP) || !defined(NORMAL)\n#extension GL_OES_standard_derivatives : enable\n#endif\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\n#include<oitDeclaration>\n#define CUSTOM_FRAGMENT_BEGIN\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#define RECIPROCAL_PI2 0.15915494\nvarying vec3 vPositionW;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\r#endif\n#include<mainUVVaryingDeclaration>[1..7]\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_SAMPLERNAME_,decal)\n#ifdef REFRACTION\n#ifdef REFRACTIONMAP_3D\nuniform samplerCube refractionCubeSampler;\r#else\nuniform sampler2D refraction2DSampler;\r#endif\n#endif\n#if defined(SPECULARTERM)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)\n#endif\n#include<fresnelFunction>\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\nuniform samplerCube reflectionCubeSampler;\r#else\nuniform sampler2D reflection2DSampler;\r#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\r#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\r#endif\n#endif\n#include<reflectionFunction>\n#endif\n#include<imageProcessingDeclaration>\n#include<imageProcessingFunctions>\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\rvec4 baseColor=vec4(1.,1.,1.,1.);\rvec3 diffuseColor=vDiffuseColor.rgb;\rfloat alpha=vDiffuseColor.a;\r#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\r#else\nvec3 normalW=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));\r#endif\n#include<bumpFragment>\n#ifdef TWOSIDEDLIGHTING\nnormalW=gl_FrontFacing ? normalW : -normalW;\r#endif\n#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);\r#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)\nif (baseColor.a<alphaCutOff)\rdiscard;\r#endif\n#ifdef ALPHAFROMDIFFUSE\nalpha*=baseColor.a;\r#endif\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\nbaseColor.rgb*=vDiffuseInfos.y;\r#endif\n#ifdef DECAL\nvec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);\r#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)\n#endif\n#include<depthPrePass>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nbaseColor.rgb*=vColor.rgb;\r#endif\n#ifdef DETAIL\nbaseColor.rgb=baseColor.rgb*2.0*mix(0.5,detailColor.r,vDetailInfos.y);\r#endif\n#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE\nvec3 baseAmbientColor=vec3(1.,1.,1.);\r#ifdef AMBIENT\nbaseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;\r#endif\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;\rvec3 specularColor=vSpecularColor.rgb;\r#ifdef SPECULAR\nvec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);\rspecularColor=specularMapColor.rgb;\r#ifdef GLOSSINESS\nglossiness=glossiness*specularMapColor.a;\r#endif\n#endif\n#else\nfloat glossiness=0.;\r#endif\nvec3 diffuseBase=vec3(0.,0.,0.);\rlightingInfo info;\r#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\r#endif\nfloat shadow=1.;\r#ifdef LIGHTMAP\nvec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);\r#ifdef RGBDLIGHTMAP\nlightmapColor.rgb=fromRGBD(lightmapColor);\r#endif\nlightmapColor.rgb*=vLightmapInfos.y;\r#endif\n#include<lightFragment>[0..maxSimultaneousLights]\nvec4 refractionColor=vec4(0.,0.,0.,1.);\r#ifdef REFRACTION\nvec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));\r#ifdef REFRACTIONMAP_3D\n#ifdef USE_LOCAL_REFRACTIONMAP_CUBIC\nrefractionVector=parallaxCorrectNormal(vPositionW,refractionVector,vRefractionSize,vRefractionPosition);\r#endif\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;\rvec4 refractionLookup=textureCube(refractionCubeSampler,refractionVector);\rif (dot(refractionVector,viewDirectionW)<1.0) {\rrefractionColor=refractionLookup;\r}\r#else\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));\rvec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;\rrefractionCoords.y=1.0-refractionCoords.y;\rrefractionColor=texture2D(refraction2DSampler,refractionCoords);\r#endif\n#ifdef RGBDREFRACTION\nrefractionColor.rgb=fromRGBD(refractionColor);\r#endif\n#ifdef IS_REFRACTION_LINEAR\nrefractionColor.rgb=toGammaSpace(refractionColor.rgb);\r#endif\nrefractionColor.rgb*=vRefractionInfos.x;\r#endif\nvec4 reflectionColor=vec4(0.,0.,0.,1.);\r#ifdef REFLECTION\nvec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\r#ifdef REFLECTIONMAP_OPPOSITEZ\nvReflectionUVW.z*=-1.0;\r#endif\n#ifdef REFLECTIONMAP_3D\n#ifdef ROUGHNESS\nfloat bias=vReflectionInfos.y;\r#ifdef SPECULARTERM\n#ifdef SPECULAR\n#ifdef GLOSSINESS\nbias*=(1.0-specularMapColor.a);\r#endif\n#endif\n#endif\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias);\r#else\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW);\r#endif\n#else\nvec2 coords=vReflectionUVW.xy;\r#ifdef REFLECTIONMAP_PROJECTION\ncoords/=vReflectionUVW.z;\r#endif\ncoords.y=1.0-coords.y;\rreflectionColor=texture2D(reflection2DSampler,coords);\r#endif\n#ifdef RGBDREFLECTION\nreflectionColor.rgb=fromRGBD(reflectionColor);\r#endif\n#ifdef IS_REFLECTION_LINEAR\nreflectionColor.rgb=toGammaSpace(reflectionColor.rgb);\r#endif\nreflectionColor.rgb*=vReflectionInfos.x;\r#ifdef REFLECTIONFRESNEL\nfloat reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);\r#ifdef REFLECTIONFRESNELFROMSPECULAR\n#ifdef SPECULARTERM\nreflectionColor.rgb*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\r#else\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\r#endif\n#else\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\r#endif\n#endif\n#endif\n#ifdef REFRACTIONFRESNEL\nfloat refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);\rrefractionColor.rgb*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;\r#endif\n#ifdef OPACITY\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\r#ifdef OPACITYRGB\nopacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);\ralpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;\r#else\nalpha*=opacityMap.a*vOpacityInfos.y;\r#endif\n#endif\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\r#endif\n#ifdef OPACITYFRESNEL\nfloat opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);\ralpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;\r#endif\n#ifdef ALPHATEST\n#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS\nif (alpha<alphaCutOff)\rdiscard;\r#endif\n#ifndef ALPHABLEND\nalpha=1.0;\r#endif\n#endif\nvec3 emissiveColor=vEmissiveColor;\r#ifdef EMISSIVE\nemissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;\r#endif\n#ifdef EMISSIVEFRESNEL\nfloat emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);\remissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;\r#endif\n#ifdef DIFFUSEFRESNEL\nfloat diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);\rdiffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;\r#endif\n#ifdef EMISSIVEASILLUMINATION\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\r#else\n#ifdef LINKEMISSIVEWITHDIFFUSE\nvec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\r#else\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\r#endif\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\r#ifdef SPECULAROVERALPHA\nalpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);\r#endif\n#else\nvec3 finalSpecular=vec3(0.0);\r#endif\n#ifdef REFLECTIONOVERALPHA\nalpha=clamp(alpha+dot(reflectionColor.rgb,vec3(0.3,0.59,0.11)),0.,1.);\r#endif\n#ifdef EMISSIVEASILLUMINATION\nvec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);\r#else\nvec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);\r#endif\n#ifdef LIGHTMAP\n#ifndef LIGHTMAPEXCLUDED\n#ifdef USELIGHTMAPASSHADOWMAP\ncolor.rgb*=lightmapColor.rgb;\r#else\ncolor.rgb+=lightmapColor.rgb;\r#endif\n#endif\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FOG\ncolor.rgb=max(color.rgb,0.);\r#include<logDepthFragment>\n#include<fogFragment>\n#ifdef IMAGEPROCESSINGPOSTPROCESS\ncolor.rgb=toLinearSpace(color.rgb);\r#else\n#ifdef IMAGEPROCESSING\ncolor.rgb=toLinearSpace(color.rgb);\rcolor=applyImageProcessing(color);\r#endif\n#endif\ncolor.a*=visibility;\r#ifdef PREMULTIPLYALPHA\ncolor.rgb*=color.a;\r#endif\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\n#ifdef PREPASS\nfloat writeGeometryInfo=color.a>0.4 ? 1.0 : 0.0;\rgl_FragData[0]=color; \r#ifdef PREPASS_POSITION\ngl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);\r#endif\n#ifdef PREPASS_VELOCITY\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;\rvec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;\rvec2 velocity=abs(a-b);\rvelocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;\rgl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);\r#endif\n#ifdef PREPASS_IRRADIANCE\ngl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); \r#endif\n#ifdef PREPASS_DEPTH\ngl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); \r#endif\n#ifdef PREPASS_NORMAL\ngl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalize((view*vec4(normalW,0.0)).rgb),writeGeometryInfo); \r#endif\n#ifdef PREPASS_ALBEDO_SQRT\ngl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); \r#endif\n#ifdef PREPASS_REFLECTIVITY\n#if defined(SPECULARTERM)\n#if defined(SPECULAR)\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(toLinearSpace(specularMapColor))*writeGeometryInfo; \r#else\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(toLinearSpace(specularColor),1.0)*writeGeometryInfo;\r#endif\n#else\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(0.0,0.0,0.0,1.0)*writeGeometryInfo;\r#endif\n#endif\n#endif\n#if !defined(PREPASS) || defined(WEBGL2)\ngl_FragColor=color;\r#endif\n#include<oitFragment>\n#if ORDER_INDEPENDENT_TRANSPARENCY\nif (fragDepth==nearestDepth) {\rfrontColor.rgb+=color.rgb*color.a*alphaMultiplier;\rfrontColor.a=1.0-alphaMultiplier*(1.0-color.a);\r} else {\rbackColor+=color;\r}\r#endif\n#define CUSTOM_FRAGMENT_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const defaultPixelShader = { name, shader };\n//# sourceMappingURL=default.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"bumpVertexDeclaration\";\nconst shader = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL) \nvarying mat3 vTBN;\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bumpVertexDeclaration = { name, shader };\n//# sourceMappingURL=bumpVertexDeclaration.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { SerializationHelper, serialize } from \"../Misc/decorators.js\";\nimport { MaterialPluginManager } from \"./materialPluginManager.js\";\n\n/**\n * Base class for material plugins.\n * @since 5.0\n */\nexport class MaterialPluginBase {\n    _enable(enable) {\n        if (enable) {\n            this._pluginManager._activatePlugin(this);\n        }\n    }\n    /**\n     * Creates a new material plugin\n     * @param material parent material of the plugin\n     * @param name name of the plugin\n     * @param priority priority of the plugin\n     * @param defines list of defines used by the plugin. The value of the property is the default value for this property\n     * @param addToPluginList true to add the plugin to the list of plugins managed by the material plugin manager of the material (default: true)\n     * @param enable true to enable the plugin (it is handy if the plugin does not handle properties to switch its current activation)\n     */\n    constructor(material, name, priority, defines, addToPluginList = true, enable = false) {\n        /**\n         * Defines the priority of the plugin. Lower numbers run first.\n         */\n        this.priority = 500;\n        /**\n         * Indicates that this plugin should be notified for the extra events (HasRenderTargetTextures / FillRenderTargetTextures / HardBindForSubMesh)\n         */\n        this.registerForExtraEvents = false;\n        this._material = material;\n        this.name = name;\n        this.priority = priority;\n        if (!material.pluginManager) {\n            material.pluginManager = new MaterialPluginManager(material);\n            material.onDisposeObservable.add(() => {\n                material.pluginManager = undefined;\n            });\n        }\n        this._pluginDefineNames = defines;\n        this._pluginManager = material.pluginManager;\n        if (addToPluginList) {\n            this._pluginManager._addPlugin(this);\n        }\n        if (enable) {\n            this._enable(true);\n        }\n        this.markAllDefinesAsDirty = material._dirtyCallbacks[63];\n    }\n    /**\n     * Gets the current class name useful for serialization or dynamic coding.\n     * @returns The class name.\n     */\n    getClassName() {\n        return \"MaterialPluginBase\";\n    }\n    /**\n     * Specifies that the submesh is ready to be used.\n     * @param defines the list of \"defines\" to update.\n     * @param scene defines the scene the material belongs to.\n     * @param engine the engine this scene belongs to.\n     * @param subMesh the submesh to check for readiness\n     * @returns - boolean indicating that the submesh is ready or not.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    isReadyForSubMesh(defines, scene, engine, subMesh) {\n        return true;\n    }\n    /**\n     * Binds the material data (this function is called even if mustRebind() returns false)\n     * @param uniformBuffer defines the Uniform buffer to fill in.\n     * @param scene defines the scene the material belongs to.\n     * @param engine defines the engine the material belongs to.\n     * @param subMesh the submesh to bind data for\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    hardBindForSubMesh(uniformBuffer, scene, engine, subMesh) { }\n    /**\n     * Binds the material data.\n     * @param uniformBuffer defines the Uniform buffer to fill in.\n     * @param scene defines the scene the material belongs to.\n     * @param engine the engine this scene belongs to.\n     * @param subMesh the submesh to bind data for\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    bindForSubMesh(uniformBuffer, scene, engine, subMesh) { }\n    /**\n     * Disposes the resources of the material.\n     * @param forceDisposeTextures - Forces the disposal of all textures.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    dispose(forceDisposeTextures) { }\n    /**\n     * Returns a list of custom shader code fragments to customize the shader.\n     * @param shaderType \"vertex\" or \"fragment\"\n     * @returns null if no code to be added, or a list of pointName => code.\n     * Note that `pointName` can also be a regular expression if it starts with a `!`.\n     * In that case, the string found by the regular expression (if any) will be\n     * replaced by the code provided.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getCustomCode(shaderType) {\n        return null;\n    }\n    /**\n     * Collects all defines.\n     * @param defines The object to append to.\n     */\n    collectDefines(defines) {\n        if (!this._pluginDefineNames) {\n            return;\n        }\n        for (const key of Object.keys(this._pluginDefineNames)) {\n            if (key[0] === \"_\") {\n                continue;\n            }\n            const type = typeof this._pluginDefineNames[key];\n            defines[key] = {\n                type: type === \"number\" ? \"number\" : type === \"string\" ? \"string\" : type === \"boolean\" ? \"boolean\" : \"object\",\n                default: this._pluginDefineNames[key],\n            };\n        }\n    }\n    /**\n     * Sets the defines for the next rendering. Called before MaterialHelper.PrepareDefinesForAttributes is called.\n     * @param defines the list of \"defines\" to update.\n     * @param scene defines the scene to the material belongs to.\n     * @param mesh the mesh being rendered\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    prepareDefinesBeforeAttributes(defines, scene, mesh) { }\n    /**\n     * Sets the defines for the next rendering\n     * @param defines the list of \"defines\" to update.\n     * @param scene defines the scene to the material belongs to.\n     * @param mesh the mesh being rendered\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    prepareDefines(defines, scene, mesh) { }\n    /**\n     * Checks to see if a texture is used in the material.\n     * @param texture - Base texture to use.\n     * @returns - Boolean specifying if a texture is used in the material.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    hasTexture(texture) {\n        return false;\n    }\n    /**\n     * Gets a boolean indicating that current material needs to register RTT\n     * @returns true if this uses a render target otherwise false.\n     */\n    hasRenderTargetTextures() {\n        return false;\n    }\n    /**\n     * Fills the list of render target textures.\n     * @param renderTargets the list of render targets to update\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    fillRenderTargetTextures(renderTargets) { }\n    /**\n     * Returns an array of the actively used textures.\n     * @param activeTextures Array of BaseTextures\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getActiveTextures(activeTextures) { }\n    /**\n     * Returns the animatable textures.\n     * @param animatables Array of animatable textures.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getAnimatables(animatables) { }\n    /**\n     * Add fallbacks to the effect fallbacks list.\n     * @param defines defines the Base texture to use.\n     * @param fallbacks defines the current fallback list.\n     * @param currentRank defines the current fallback rank.\n     * @returns the new fallback rank.\n     */\n    addFallbacks(defines, fallbacks, currentRank) {\n        return currentRank;\n    }\n    /**\n     * Gets the samplers used by the plugin.\n     * @param samplers list that the sampler names should be added to.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getSamplers(samplers) { }\n    /**\n     * Gets the attributes used by the plugin.\n     * @param attributes list that the attribute names should be added to.\n     * @param scene the scene that the material belongs to.\n     * @param mesh the mesh being rendered.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getAttributes(attributes, scene, mesh) { }\n    /**\n     * Gets the uniform buffers names added by the plugin.\n     * @param ubos list that the ubo names should be added to.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getUniformBuffersNames(ubos) { }\n    /**\n     * Gets the description of the uniforms to add to the ubo (if engine supports ubos) or to inject directly in the vertex/fragment shaders (if engine does not support ubos)\n     * @returns the description of the uniforms\n     */\n    getUniforms() {\n        return {};\n    }\n    /**\n     * Makes a duplicate of the current configuration into another one.\n     * @param plugin define the config where to copy the info\n     */\n    copyTo(plugin) {\n        SerializationHelper.Clone(() => plugin, this);\n    }\n    /**\n     * Serializes this clear coat configuration.\n     * @returns - An object with the serialized config.\n     */\n    serialize() {\n        return SerializationHelper.Serialize(this);\n    }\n    /**\n     * Parses a anisotropy Configuration from a serialized object.\n     * @param source - Serialized object.\n     * @param scene Defines the scene we are parsing for\n     * @param rootUrl Defines the rootUrl to load from\n     */\n    parse(source, scene, rootUrl) {\n        SerializationHelper.Parse(() => this, source, scene, rootUrl);\n    }\n}\n__decorate([\n    serialize()\n], MaterialPluginBase.prototype, \"name\", void 0);\n__decorate([\n    serialize()\n], MaterialPluginBase.prototype, \"priority\", void 0);\n__decorate([\n    serialize()\n], MaterialPluginBase.prototype, \"registerForExtraEvents\", void 0);\n//# sourceMappingURL=materialPluginBase.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { Material } from \"./material.js\";\nimport { serialize, expandToProperty, serializeAsTexture } from \"../Misc/decorators.js\";\nimport { MaterialFlags } from \"./materialFlags.js\";\nimport { MaterialHelper } from \"./materialHelper.js\";\nimport { MaterialDefines } from \"./materialDefines.js\";\nimport { MaterialPluginBase } from \"./materialPluginBase.js\";\n\n/**\n * @internal\n */\nexport class MaterialDetailMapDefines extends MaterialDefines {\n    constructor() {\n        super(...arguments);\n        this.DETAIL = false;\n        this.DETAILDIRECTUV = 0;\n        this.DETAIL_NORMALBLENDMETHOD = 0;\n    }\n}\n/**\n * Plugin that implements the detail map component of a material\n *\n * Inspired from:\n *   Unity: https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@9.0/manual/Mask-Map-and-Detail-Map.html and https://docs.unity3d.com/Manual/StandardShaderMaterialParameterDetail.html\n *   Unreal: https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/HowTo/DetailTexturing/index.html\n *   Cryengine: https://docs.cryengine.com/display/SDKDOC2/Detail+Maps\n */\nexport class DetailMapConfiguration extends MaterialPluginBase {\n    /** @internal */\n    _markAllSubMeshesAsTexturesDirty() {\n        this._enable(this._isEnabled);\n        this._internalMarkAllSubMeshesAsTexturesDirty();\n    }\n    constructor(material, addToPluginList = true) {\n        super(material, \"DetailMap\", 140, new MaterialDetailMapDefines(), addToPluginList);\n        this._texture = null;\n        /**\n         * Defines how strongly the detail diffuse/albedo channel is blended with the regular diffuse/albedo texture\n         * Bigger values mean stronger blending\n         */\n        this.diffuseBlendLevel = 1;\n        /**\n         * Defines how strongly the detail roughness channel is blended with the regular roughness value\n         * Bigger values mean stronger blending. Only used with PBR materials\n         */\n        this.roughnessBlendLevel = 1;\n        /**\n         * Defines how strong the bump effect from the detail map is\n         * Bigger values mean stronger effect\n         */\n        this.bumpLevel = 1;\n        this._normalBlendMethod = Material.MATERIAL_NORMALBLENDMETHOD_WHITEOUT;\n        this._isEnabled = false;\n        /**\n         * Enable or disable the detail map on this material\n         */\n        this.isEnabled = false;\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];\n    }\n    isReadyForSubMesh(defines, scene, engine) {\n        if (!this._isEnabled) {\n            return true;\n        }\n        if (defines._areTexturesDirty && scene.texturesEnabled) {\n            if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled) {\n                // Detail texture cannot be not blocking.\n                if (!this._texture.isReady()) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    prepareDefines(defines, scene) {\n        if (this._isEnabled) {\n            defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;\n            const engine = scene.getEngine();\n            if (defines._areTexturesDirty) {\n                if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled && this._isEnabled) {\n                    MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"DETAIL\");\n                    defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;\n                }\n                else {\n                    defines.DETAIL = false;\n                }\n            }\n        }\n        else {\n            defines.DETAIL = false;\n        }\n    }\n    bindForSubMesh(uniformBuffer, scene) {\n        if (!this._isEnabled) {\n            return;\n        }\n        const isFrozen = this._material.isFrozen;\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\n            if (this._texture && MaterialFlags.DetailTextureEnabled) {\n                uniformBuffer.updateFloat4(\"vDetailInfos\", this._texture.coordinatesIndex, this.diffuseBlendLevel, this.bumpLevel, this.roughnessBlendLevel);\n                MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"detail\");\n            }\n        }\n        // Textures\n        if (scene.texturesEnabled) {\n            if (this._texture && MaterialFlags.DetailTextureEnabled) {\n                uniformBuffer.setTexture(\"detailSampler\", this._texture);\n            }\n        }\n    }\n    hasTexture(texture) {\n        if (this._texture === texture) {\n            return true;\n        }\n        return false;\n    }\n    getActiveTextures(activeTextures) {\n        if (this._texture) {\n            activeTextures.push(this._texture);\n        }\n    }\n    getAnimatables(animatables) {\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\n            animatables.push(this._texture);\n        }\n    }\n    dispose(forceDisposeTextures) {\n        var _a;\n        if (forceDisposeTextures) {\n            (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();\n        }\n    }\n    getClassName() {\n        return \"DetailMapConfiguration\";\n    }\n    getSamplers(samplers) {\n        samplers.push(\"detailSampler\");\n    }\n    getUniforms() {\n        return {\n            ubo: [\n                { name: \"vDetailInfos\", size: 4, type: \"vec4\" },\n                { name: \"detailMatrix\", size: 16, type: \"mat4\" },\n            ],\n        };\n    }\n}\n__decorate([\n    serializeAsTexture(\"detailTexture\"),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], DetailMapConfiguration.prototype, \"texture\", void 0);\n__decorate([\n    serialize()\n], DetailMapConfiguration.prototype, \"diffuseBlendLevel\", void 0);\n__decorate([\n    serialize()\n], DetailMapConfiguration.prototype, \"roughnessBlendLevel\", void 0);\n__decorate([\n    serialize()\n], DetailMapConfiguration.prototype, \"bumpLevel\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], DetailMapConfiguration.prototype, \"normalBlendMethod\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], DetailMapConfiguration.prototype, \"isEnabled\", void 0);\n//# sourceMappingURL=material.detailMapConfiguration.js.map","import { __decorate } from \"../tslib.es6.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { serialize, SerializationHelper, serializeAsColor3, expandToProperty, serializeAsFresnelParameters, serializeAsTexture } from \"../Misc/decorators.js\";\nimport { SmartArray } from \"../Misc/smartArray.js\";\nimport { Scene } from \"../scene.js\";\nimport { Matrix } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { PrePassConfiguration } from \"./prePassConfiguration.js\";\nimport { ImageProcessingConfiguration } from \"./imageProcessingConfiguration.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { MaterialPluginEvent } from \"./materialPluginEvent.js\";\nimport { MaterialDefines } from \"../Materials/materialDefines.js\";\nimport { PushMaterial } from \"./pushMaterial.js\";\nimport { MaterialHelper } from \"./materialHelper.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { MaterialFlags } from \"./materialFlags.js\";\nimport \"../Shaders/default.fragment.js\";\nimport \"../Shaders/default.vertex.js\";\n\nimport { EffectFallbacks } from \"./effectFallbacks.js\";\nimport { DetailMapConfiguration } from \"./material.detailMapConfiguration.js\";\nimport { addClipPlaneUniforms, bindClipPlane } from \"./clipPlaneMaterialHelper.js\";\nconst onCreatedEffectParameters = { effect: null, subMesh: null };\n/** @internal */\nexport class StandardMaterialDefines extends MaterialDefines {\n    /**\n     * Initializes the Standard Material defines.\n     * @param externalProperties The external properties\n     */\n    constructor(externalProperties) {\n        super(externalProperties);\n        this.MAINUV1 = false;\n        this.MAINUV2 = false;\n        this.MAINUV3 = false;\n        this.MAINUV4 = false;\n        this.MAINUV5 = false;\n        this.MAINUV6 = false;\n        this.DIFFUSE = false;\n        this.DIFFUSEDIRECTUV = 0;\n        this.BAKED_VERTEX_ANIMATION_TEXTURE = false;\n        this.AMBIENT = false;\n        this.AMBIENTDIRECTUV = 0;\n        this.OPACITY = false;\n        this.OPACITYDIRECTUV = 0;\n        this.OPACITYRGB = false;\n        this.REFLECTION = false;\n        this.EMISSIVE = false;\n        this.EMISSIVEDIRECTUV = 0;\n        this.SPECULAR = false;\n        this.SPECULARDIRECTUV = 0;\n        this.BUMP = false;\n        this.BUMPDIRECTUV = 0;\n        this.PARALLAX = false;\n        this.PARALLAXOCCLUSION = false;\n        this.SPECULAROVERALPHA = false;\n        this.CLIPPLANE = false;\n        this.CLIPPLANE2 = false;\n        this.CLIPPLANE3 = false;\n        this.CLIPPLANE4 = false;\n        this.CLIPPLANE5 = false;\n        this.CLIPPLANE6 = false;\n        this.ALPHATEST = false;\n        this.DEPTHPREPASS = false;\n        this.ALPHAFROMDIFFUSE = false;\n        this.POINTSIZE = false;\n        this.FOG = false;\n        this.SPECULARTERM = false;\n        this.DIFFUSEFRESNEL = false;\n        this.OPACITYFRESNEL = false;\n        this.REFLECTIONFRESNEL = false;\n        this.REFRACTIONFRESNEL = false;\n        this.EMISSIVEFRESNEL = false;\n        this.FRESNEL = false;\n        this.NORMAL = false;\n        this.TANGENT = false;\n        this.UV1 = false;\n        this.UV2 = false;\n        this.UV3 = false;\n        this.UV4 = false;\n        this.UV5 = false;\n        this.UV6 = false;\n        this.VERTEXCOLOR = false;\n        this.VERTEXALPHA = false;\n        this.NUM_BONE_INFLUENCERS = 0;\n        this.BonesPerMesh = 0;\n        this.BONETEXTURE = false;\n        this.BONES_VELOCITY_ENABLED = false;\n        this.INSTANCES = false;\n        this.THIN_INSTANCES = false;\n        this.INSTANCESCOLOR = false;\n        this.GLOSSINESS = false;\n        this.ROUGHNESS = false;\n        this.EMISSIVEASILLUMINATION = false;\n        this.LINKEMISSIVEWITHDIFFUSE = false;\n        this.REFLECTIONFRESNELFROMSPECULAR = false;\n        this.LIGHTMAP = false;\n        this.LIGHTMAPDIRECTUV = 0;\n        this.OBJECTSPACE_NORMALMAP = false;\n        this.USELIGHTMAPASSHADOWMAP = false;\n        this.REFLECTIONMAP_3D = false;\n        this.REFLECTIONMAP_SPHERICAL = false;\n        this.REFLECTIONMAP_PLANAR = false;\n        this.REFLECTIONMAP_CUBIC = false;\n        this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;\n        this.USE_LOCAL_REFRACTIONMAP_CUBIC = false;\n        this.REFLECTIONMAP_PROJECTION = false;\n        this.REFLECTIONMAP_SKYBOX = false;\n        this.REFLECTIONMAP_EXPLICIT = false;\n        this.REFLECTIONMAP_EQUIRECTANGULAR = false;\n        this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\n        this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\n        this.REFLECTIONMAP_OPPOSITEZ = false;\n        this.INVERTCUBICMAP = false;\n        this.LOGARITHMICDEPTH = false;\n        this.REFRACTION = false;\n        this.REFRACTIONMAP_3D = false;\n        this.REFLECTIONOVERALPHA = false;\n        this.TWOSIDEDLIGHTING = false;\n        this.SHADOWFLOAT = false;\n        this.MORPHTARGETS = false;\n        this.MORPHTARGETS_NORMAL = false;\n        this.MORPHTARGETS_TANGENT = false;\n        this.MORPHTARGETS_UV = false;\n        this.NUM_MORPH_INFLUENCERS = 0;\n        this.MORPHTARGETS_TEXTURE = false;\n        this.NONUNIFORMSCALING = false; // https://playground.babylonjs.com#V6DWIH\n        this.PREMULTIPLYALPHA = false; // https://playground.babylonjs.com#LNVJJ7\n        this.ALPHATEST_AFTERALLALPHACOMPUTATIONS = false;\n        this.ALPHABLEND = true;\n        this.PREPASS = false;\n        this.PREPASS_IRRADIANCE = false;\n        this.PREPASS_IRRADIANCE_INDEX = -1;\n        this.PREPASS_ALBEDO_SQRT = false;\n        this.PREPASS_ALBEDO_SQRT_INDEX = -1;\n        this.PREPASS_DEPTH = false;\n        this.PREPASS_DEPTH_INDEX = -1;\n        this.PREPASS_NORMAL = false;\n        this.PREPASS_NORMAL_INDEX = -1;\n        this.PREPASS_POSITION = false;\n        this.PREPASS_POSITION_INDEX = -1;\n        this.PREPASS_VELOCITY = false;\n        this.PREPASS_VELOCITY_INDEX = -1;\n        this.PREPASS_REFLECTIVITY = false;\n        this.PREPASS_REFLECTIVITY_INDEX = -1;\n        this.SCENE_MRT_COUNT = 0;\n        this.RGBDLIGHTMAP = false;\n        this.RGBDREFLECTION = false;\n        this.RGBDREFRACTION = false;\n        this.IMAGEPROCESSING = false;\n        this.VIGNETTE = false;\n        this.VIGNETTEBLENDMODEMULTIPLY = false;\n        this.VIGNETTEBLENDMODEOPAQUE = false;\n        this.TONEMAPPING = false;\n        this.TONEMAPPING_ACES = false;\n        this.CONTRAST = false;\n        this.COLORCURVES = false;\n        this.COLORGRADING = false;\n        this.COLORGRADING3D = false;\n        this.SAMPLER3DGREENDEPTH = false;\n        this.SAMPLER3DBGRMAP = false;\n        this.DITHER = false;\n        this.IMAGEPROCESSINGPOSTPROCESS = false;\n        this.SKIPFINALCOLORCLAMP = false;\n        this.MULTIVIEW = false;\n        this.ORDER_INDEPENDENT_TRANSPARENCY = false;\n        this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = false;\n        this.CAMERA_ORTHOGRAPHIC = false;\n        this.CAMERA_PERSPECTIVE = false;\n        /**\n         * If the reflection texture on this material is in linear color space\n         * @internal\n         */\n        this.IS_REFLECTION_LINEAR = false;\n        /**\n         * If the refraction texture on this material is in linear color space\n         * @internal\n         */\n        this.IS_REFRACTION_LINEAR = false;\n        this.EXPOSURE = false;\n        this.rebuild();\n    }\n    setReflectionMode(modeToEnable) {\n        const modes = [\n            \"REFLECTIONMAP_CUBIC\",\n            \"REFLECTIONMAP_EXPLICIT\",\n            \"REFLECTIONMAP_PLANAR\",\n            \"REFLECTIONMAP_PROJECTION\",\n            \"REFLECTIONMAP_PROJECTION\",\n            \"REFLECTIONMAP_SKYBOX\",\n            \"REFLECTIONMAP_SPHERICAL\",\n            \"REFLECTIONMAP_EQUIRECTANGULAR\",\n            \"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\",\n            \"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\",\n        ];\n        for (const mode of modes) {\n            this[mode] = mode === modeToEnable;\n        }\n    }\n}\n/**\n * This is the default material used in Babylon. It is the best trade off between quality\n * and performances.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction\n */\nexport class StandardMaterial extends PushMaterial {\n    /**\n     * Gets the image processing configuration used either in this material.\n     */\n    get imageProcessingConfiguration() {\n        return this._imageProcessingConfiguration;\n    }\n    /**\n     * Sets the Default image processing configuration used either in the this material.\n     *\n     * If sets to null, the scene one is in use.\n     */\n    set imageProcessingConfiguration(value) {\n        this._attachImageProcessingConfiguration(value);\n        // Ensure the effect will be rebuilt.\n        this._markAllSubMeshesAsTexturesDirty();\n    }\n    /**\n     * Attaches a new image processing configuration to the Standard Material.\n     * @param configuration\n     */\n    _attachImageProcessingConfiguration(configuration) {\n        if (configuration === this._imageProcessingConfiguration) {\n            return;\n        }\n        // Detaches observer\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n        }\n        // Pick the scene configuration if needed\n        if (!configuration) {\n            this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\n        }\n        else {\n            this._imageProcessingConfiguration = configuration;\n        }\n        // Attaches observer\n        if (this._imageProcessingConfiguration) {\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\n                this._markAllSubMeshesAsImageProcessingDirty();\n            });\n        }\n    }\n    /**\n     * Can this material render to prepass\n     */\n    get isPrePassCapable() {\n        return !this.disableDepthWrite;\n    }\n    /**\n     * Gets whether the color curves effect is enabled.\n     */\n    get cameraColorCurvesEnabled() {\n        return this.imageProcessingConfiguration.colorCurvesEnabled;\n    }\n    /**\n     * Sets whether the color curves effect is enabled.\n     */\n    set cameraColorCurvesEnabled(value) {\n        this.imageProcessingConfiguration.colorCurvesEnabled = value;\n    }\n    /**\n     * Gets whether the color grading effect is enabled.\n     */\n    get cameraColorGradingEnabled() {\n        return this.imageProcessingConfiguration.colorGradingEnabled;\n    }\n    /**\n     * Gets whether the color grading effect is enabled.\n     */\n    set cameraColorGradingEnabled(value) {\n        this.imageProcessingConfiguration.colorGradingEnabled = value;\n    }\n    /**\n     * Gets whether tonemapping is enabled or not.\n     */\n    get cameraToneMappingEnabled() {\n        return this._imageProcessingConfiguration.toneMappingEnabled;\n    }\n    /**\n     * Sets whether tonemapping is enabled or not\n     */\n    set cameraToneMappingEnabled(value) {\n        this._imageProcessingConfiguration.toneMappingEnabled = value;\n    }\n    /**\n     * The camera exposure used on this material.\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\n     * This corresponds to a photographic exposure.\n     */\n    get cameraExposure() {\n        return this._imageProcessingConfiguration.exposure;\n    }\n    /**\n     * The camera exposure used on this material.\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\n     * This corresponds to a photographic exposure.\n     */\n    set cameraExposure(value) {\n        this._imageProcessingConfiguration.exposure = value;\n    }\n    /**\n     * Gets The camera contrast used on this material.\n     */\n    get cameraContrast() {\n        return this._imageProcessingConfiguration.contrast;\n    }\n    /**\n     * Sets The camera contrast used on this material.\n     */\n    set cameraContrast(value) {\n        this._imageProcessingConfiguration.contrast = value;\n    }\n    /**\n     * Gets the Color Grading 2D Lookup Texture.\n     */\n    get cameraColorGradingTexture() {\n        return this._imageProcessingConfiguration.colorGradingTexture;\n    }\n    /**\n     * Sets the Color Grading 2D Lookup Texture.\n     */\n    set cameraColorGradingTexture(value) {\n        this._imageProcessingConfiguration.colorGradingTexture = value;\n    }\n    /**\n     * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\n     */\n    get cameraColorCurves() {\n        return this._imageProcessingConfiguration.colorCurves;\n    }\n    /**\n     * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\n     */\n    set cameraColorCurves(value) {\n        this._imageProcessingConfiguration.colorCurves = value;\n    }\n    /**\n     * Can this material render to several textures at once\n     */\n    get canRenderToMRT() {\n        return true;\n    }\n    /**\n     * Instantiates a new standard material.\n     * This is the default material used in Babylon. It is the best trade off between quality\n     * and performances.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction\n     * @param name Define the name of the material in the scene\n     * @param scene Define the scene the material belong to\n     */\n    constructor(name, scene) {\n        super(name, scene);\n        this._diffuseTexture = null;\n        this._ambientTexture = null;\n        this._opacityTexture = null;\n        this._reflectionTexture = null;\n        this._emissiveTexture = null;\n        this._specularTexture = null;\n        this._bumpTexture = null;\n        this._lightmapTexture = null;\n        this._refractionTexture = null;\n        /**\n         * The color of the material lit by the environmental background lighting.\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#ambient-color-example\n         */\n        this.ambientColor = new Color3(0, 0, 0);\n        /**\n         * The basic color of the material as viewed under a light.\n         */\n        this.diffuseColor = new Color3(1, 1, 1);\n        /**\n         * Define how the color and intensity of the highlight given by the light in the material.\n         */\n        this.specularColor = new Color3(1, 1, 1);\n        /**\n         * Define the color of the material as if self lit.\n         * This will be mixed in the final result even in the absence of light.\n         */\n        this.emissiveColor = new Color3(0, 0, 0);\n        /**\n         * Defines how sharp are the highlights in the material.\n         * The bigger the value the sharper giving a more glossy feeling to the result.\n         * Reversely, the smaller the value the blurrier giving a more rough feeling to the result.\n         */\n        this.specularPower = 64;\n        this._useAlphaFromDiffuseTexture = false;\n        this._useEmissiveAsIllumination = false;\n        this._linkEmissiveWithDiffuse = false;\n        this._useSpecularOverAlpha = false;\n        this._useReflectionOverAlpha = false;\n        this._disableLighting = false;\n        this._useObjectSpaceNormalMap = false;\n        this._useParallax = false;\n        this._useParallaxOcclusion = false;\n        /**\n         * Apply a scaling factor that determine which \"depth\" the height map should reprensent. A value between 0.05 and 0.1 is reasonnable in Parallax, you can reach 0.2 using Parallax Occlusion.\n         */\n        this.parallaxScaleBias = 0.05;\n        this._roughness = 0;\n        /**\n         * In case of refraction, define the value of the index of refraction.\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#how-to-obtain-reflections-and-refractions\n         */\n        this.indexOfRefraction = 0.98;\n        /**\n         * Invert the refraction texture alongside the y axis.\n         * It can be useful with procedural textures or probe for instance.\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#how-to-obtain-reflections-and-refractions\n         */\n        this.invertRefractionY = true;\n        /**\n         * Defines the alpha limits in alpha test mode.\n         */\n        this.alphaCutOff = 0.4;\n        this._useLightmapAsShadowmap = false;\n        this._useReflectionFresnelFromSpecular = false;\n        this._useGlossinessFromSpecularMapAlpha = false;\n        this._maxSimultaneousLights = 4;\n        this._invertNormalMapX = false;\n        this._invertNormalMapY = false;\n        this._twoSidedLighting = false;\n        this._renderTargets = new SmartArray(16);\n        this._worldViewProjectionMatrix = Matrix.Zero();\n        this._globalAmbientColor = new Color3(0, 0, 0);\n        this._cacheHasRenderTargetTextures = false;\n        this.detailMap = new DetailMapConfiguration(this);\n        // Setup the default processing configuration to the scene.\n        this._attachImageProcessingConfiguration(null);\n        this.prePassConfiguration = new PrePassConfiguration();\n        this.getRenderTargetTextures = () => {\n            this._renderTargets.reset();\n            if (StandardMaterial.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\n                this._renderTargets.push(this._reflectionTexture);\n            }\n            if (StandardMaterial.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\n                this._renderTargets.push(this._refractionTexture);\n            }\n            this._eventInfo.renderTargets = this._renderTargets;\n            this._callbackPluginEventFillRenderTargetTextures(this._eventInfo);\n            return this._renderTargets;\n        };\n    }\n    /**\n     * Gets a boolean indicating that current material needs to register RTT\n     */\n    get hasRenderTargetTextures() {\n        if (StandardMaterial.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\n            return true;\n        }\n        if (StandardMaterial.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\n            return true;\n        }\n        return this._cacheHasRenderTargetTextures;\n    }\n    /**\n     * Gets the current class name of the material e.g. \"StandardMaterial\"\n     * Mainly use in serialization.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"StandardMaterial\";\n    }\n    /**\n     * In case the depth buffer does not allow enough depth precision for your scene (might be the case in large scenes)\n     * You can try switching to logarithmic depth.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/logarithmicDepthBuffer\n     */\n    get useLogarithmicDepth() {\n        return this._useLogarithmicDepth;\n    }\n    set useLogarithmicDepth(value) {\n        this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;\n        this._markAllSubMeshesAsMiscDirty();\n    }\n    /**\n     * Specifies if the material will require alpha blending\n     * @returns a boolean specifying if alpha blending is needed\n     */\n    needAlphaBlending() {\n        if (this._disableAlphaBlending) {\n            return false;\n        }\n        return (this.alpha < 1.0 ||\n            this._opacityTexture != null ||\n            this._shouldUseAlphaFromDiffuseTexture() ||\n            (this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled));\n    }\n    /**\n     * Specifies if this material should be rendered in alpha test mode\n     * @returns a boolean specifying if an alpha test is needed.\n     */\n    needAlphaTesting() {\n        if (this._forceAlphaTest) {\n            return true;\n        }\n        return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === Material.MATERIAL_ALPHATEST);\n    }\n    /**\n     * Specifies whether or not the alpha value of the diffuse texture should be used for alpha blending.\n     */\n    _shouldUseAlphaFromDiffuseTexture() {\n        return this._diffuseTexture != null && this._diffuseTexture.hasAlpha && this._useAlphaFromDiffuseTexture && this._transparencyMode !== Material.MATERIAL_OPAQUE;\n    }\n    /**\n     * Specifies whether or not there is a usable alpha channel for transparency.\n     */\n    _hasAlphaChannel() {\n        return (this._diffuseTexture != null && this._diffuseTexture.hasAlpha) || this._opacityTexture != null;\n    }\n    /**\n     * Get the texture used for alpha test purpose.\n     * @returns the diffuse texture in case of the standard material.\n     */\n    getAlphaTestTexture() {\n        return this._diffuseTexture;\n    }\n    /**\n     * Get if the submesh is ready to be used and all its information available.\n     * Child classes can use it to update shaders\n     * @param mesh defines the mesh to check\n     * @param subMesh defines which submesh to check\n     * @param useInstances specifies that instances should be used\n     * @returns a boolean indicating that the submesh is ready or not\n     */\n    isReadyForSubMesh(mesh, subMesh, useInstances = false) {\n        if (!this._uniformBufferLayoutBuilt) {\n            this.buildUniformLayout();\n        }\n        if (subMesh.effect && this.isFrozen) {\n            if (subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\n                return true;\n            }\n        }\n        if (!subMesh.materialDefines) {\n            this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);\n            subMesh.materialDefines = new StandardMaterialDefines(this._eventInfo.defineNames);\n        }\n        const scene = this.getScene();\n        const defines = subMesh.materialDefines;\n        if (this._isReadyForSubMesh(subMesh)) {\n            return true;\n        }\n        const engine = scene.getEngine();\n        // Lights\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);\n        // Multiview\n        MaterialHelper.PrepareDefinesForMultiview(scene, defines);\n        // PrePass\n        const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;\n        MaterialHelper.PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);\n        // Order independant transparency\n        MaterialHelper.PrepareDefinesForOIT(scene, defines, oit);\n        // Textures\n        if (defines._areTexturesDirty) {\n            this._eventInfo.hasRenderTargetTextures = false;\n            this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);\n            this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;\n            defines._needUVs = false;\n            for (let i = 1; i <= 6; ++i) {\n                defines[\"MAINUV\" + i] = false;\n            }\n            if (scene.texturesEnabled) {\n                defines.DIFFUSEDIRECTUV = 0;\n                defines.BUMPDIRECTUV = 0;\n                defines.AMBIENTDIRECTUV = 0;\n                defines.OPACITYDIRECTUV = 0;\n                defines.EMISSIVEDIRECTUV = 0;\n                defines.SPECULARDIRECTUV = 0;\n                defines.LIGHTMAPDIRECTUV = 0;\n                if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\n                    if (!this._diffuseTexture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                    else {\n                        MaterialHelper.PrepareDefinesForMergedUV(this._diffuseTexture, defines, \"DIFFUSE\");\n                    }\n                }\n                else {\n                    defines.DIFFUSE = false;\n                }\n                if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\n                    if (!this._ambientTexture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                    else {\n                        MaterialHelper.PrepareDefinesForMergedUV(this._ambientTexture, defines, \"AMBIENT\");\n                    }\n                }\n                else {\n                    defines.AMBIENT = false;\n                }\n                if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\n                    if (!this._opacityTexture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                    else {\n                        MaterialHelper.PrepareDefinesForMergedUV(this._opacityTexture, defines, \"OPACITY\");\n                        defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;\n                    }\n                }\n                else {\n                    defines.OPACITY = false;\n                }\n                if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\n                    if (!this._reflectionTexture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                    else {\n                        defines._needNormals = true;\n                        defines.REFLECTION = true;\n                        defines.ROUGHNESS = this._roughness > 0;\n                        defines.REFLECTIONOVERALPHA = this._useReflectionOverAlpha;\n                        defines.INVERTCUBICMAP = this._reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE;\n                        defines.REFLECTIONMAP_3D = this._reflectionTexture.isCube;\n                        defines.REFLECTIONMAP_OPPOSITEZ =\n                            defines.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !this._reflectionTexture.invertZ : this._reflectionTexture.invertZ;\n                        defines.RGBDREFLECTION = this._reflectionTexture.isRGBD;\n                        switch (this._reflectionTexture.coordinatesMode) {\n                            case Texture.EXPLICIT_MODE:\n                                defines.setReflectionMode(\"REFLECTIONMAP_EXPLICIT\");\n                                break;\n                            case Texture.PLANAR_MODE:\n                                defines.setReflectionMode(\"REFLECTIONMAP_PLANAR\");\n                                break;\n                            case Texture.PROJECTION_MODE:\n                                defines.setReflectionMode(\"REFLECTIONMAP_PROJECTION\");\n                                break;\n                            case Texture.SKYBOX_MODE:\n                                defines.setReflectionMode(\"REFLECTIONMAP_SKYBOX\");\n                                break;\n                            case Texture.SPHERICAL_MODE:\n                                defines.setReflectionMode(\"REFLECTIONMAP_SPHERICAL\");\n                                break;\n                            case Texture.EQUIRECTANGULAR_MODE:\n                                defines.setReflectionMode(\"REFLECTIONMAP_EQUIRECTANGULAR\");\n                                break;\n                            case Texture.FIXED_EQUIRECTANGULAR_MODE:\n                                defines.setReflectionMode(\"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\");\n                                break;\n                            case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:\n                                defines.setReflectionMode(\"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\");\n                                break;\n                            case Texture.CUBIC_MODE:\n                            case Texture.INVCUBIC_MODE:\n                            default:\n                                defines.setReflectionMode(\"REFLECTIONMAP_CUBIC\");\n                                break;\n                        }\n                        defines.USE_LOCAL_REFLECTIONMAP_CUBIC = this._reflectionTexture.boundingBoxSize ? true : false;\n                    }\n                }\n                else {\n                    defines.REFLECTION = false;\n                    defines.REFLECTIONMAP_OPPOSITEZ = false;\n                }\n                if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\n                    if (!this._emissiveTexture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                    else {\n                        MaterialHelper.PrepareDefinesForMergedUV(this._emissiveTexture, defines, \"EMISSIVE\");\n                    }\n                }\n                else {\n                    defines.EMISSIVE = false;\n                }\n                if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\n                    if (!this._lightmapTexture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                    else {\n                        MaterialHelper.PrepareDefinesForMergedUV(this._lightmapTexture, defines, \"LIGHTMAP\");\n                        defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;\n                        defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;\n                    }\n                }\n                else {\n                    defines.LIGHTMAP = false;\n                }\n                if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\n                    if (!this._specularTexture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                    else {\n                        MaterialHelper.PrepareDefinesForMergedUV(this._specularTexture, defines, \"SPECULAR\");\n                        defines.GLOSSINESS = this._useGlossinessFromSpecularMapAlpha;\n                    }\n                }\n                else {\n                    defines.SPECULAR = false;\n                }\n                if (scene.getEngine().getCaps().standardDerivatives && this._bumpTexture && StandardMaterial.BumpTextureEnabled) {\n                    // Bump texture can not be not blocking.\n                    if (!this._bumpTexture.isReady()) {\n                        return false;\n                    }\n                    else {\n                        MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, \"BUMP\");\n                        defines.PARALLAX = this._useParallax;\n                        defines.PARALLAXOCCLUSION = this._useParallaxOcclusion;\n                    }\n                    defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;\n                }\n                else {\n                    defines.BUMP = false;\n                    defines.PARALLAX = false;\n                    defines.PARALLAXOCCLUSION = false;\n                }\n                if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\n                    if (!this._refractionTexture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                    else {\n                        defines._needUVs = true;\n                        defines.REFRACTION = true;\n                        defines.REFRACTIONMAP_3D = this._refractionTexture.isCube;\n                        defines.RGBDREFRACTION = this._refractionTexture.isRGBD;\n                        defines.USE_LOCAL_REFRACTIONMAP_CUBIC = this._refractionTexture.boundingBoxSize ? true : false;\n                    }\n                }\n                else {\n                    defines.REFRACTION = false;\n                }\n                defines.TWOSIDEDLIGHTING = !this._backFaceCulling && this._twoSidedLighting;\n            }\n            else {\n                defines.DIFFUSE = false;\n                defines.AMBIENT = false;\n                defines.OPACITY = false;\n                defines.REFLECTION = false;\n                defines.EMISSIVE = false;\n                defines.LIGHTMAP = false;\n                defines.BUMP = false;\n                defines.REFRACTION = false;\n            }\n            defines.ALPHAFROMDIFFUSE = this._shouldUseAlphaFromDiffuseTexture();\n            defines.EMISSIVEASILLUMINATION = this._useEmissiveAsIllumination;\n            defines.LINKEMISSIVEWITHDIFFUSE = this._linkEmissiveWithDiffuse;\n            defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;\n            defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;\n            defines.ALPHATEST_AFTERALLALPHACOMPUTATIONS = this.transparencyMode !== null;\n            defines.ALPHABLEND = this.transparencyMode === null || this.needAlphaBlendingForMesh(mesh); // check on null for backward compatibility\n        }\n        this._eventInfo.isReadyForSubMesh = true;\n        this._eventInfo.defines = defines;\n        this._eventInfo.subMesh = subMesh;\n        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);\n        if (!this._eventInfo.isReadyForSubMesh) {\n            return false;\n        }\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\n            if (!this._imageProcessingConfiguration.isReady()) {\n                return false;\n            }\n            this._imageProcessingConfiguration.prepareDefines(defines);\n            defines.IS_REFLECTION_LINEAR = this.reflectionTexture != null && !this.reflectionTexture.gammaSpace;\n            defines.IS_REFRACTION_LINEAR = this.refractionTexture != null && !this.refractionTexture.gammaSpace;\n        }\n        if (defines._areFresnelDirty) {\n            if (StandardMaterial.FresnelEnabled) {\n                // Fresnel\n                if (this._diffuseFresnelParameters ||\n                    this._opacityFresnelParameters ||\n                    this._emissiveFresnelParameters ||\n                    this._refractionFresnelParameters ||\n                    this._reflectionFresnelParameters) {\n                    defines.DIFFUSEFRESNEL = this._diffuseFresnelParameters && this._diffuseFresnelParameters.isEnabled;\n                    defines.OPACITYFRESNEL = this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;\n                    defines.REFLECTIONFRESNEL = this._reflectionFresnelParameters && this._reflectionFresnelParameters.isEnabled;\n                    defines.REFLECTIONFRESNELFROMSPECULAR = this._useReflectionFresnelFromSpecular;\n                    defines.REFRACTIONFRESNEL = this._refractionFresnelParameters && this._refractionFresnelParameters.isEnabled;\n                    defines.EMISSIVEFRESNEL = this._emissiveFresnelParameters && this._emissiveFresnelParameters.isEnabled;\n                    defines._needNormals = true;\n                    defines.FRESNEL = true;\n                }\n            }\n            else {\n                defines.FRESNEL = false;\n            }\n        }\n        // Misc.\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh) || this._forceAlphaTest, defines);\n        // Values that need to be evaluated on every frame\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);\n        // External config\n        this._eventInfo.defines = defines;\n        this._eventInfo.mesh = mesh;\n        this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo);\n        // Attribs\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true, true);\n        // External config\n        this._callbackPluginEventPrepareDefines(this._eventInfo);\n        // Get correct effect\n        let forceWasNotReadyPreviously = false;\n        if (defines.isDirty) {\n            const lightDisposed = defines._areLightsDisposed;\n            defines.markAsProcessed();\n            // Fallbacks\n            const fallbacks = new EffectFallbacks();\n            if (defines.REFLECTION) {\n                fallbacks.addFallback(0, \"REFLECTION\");\n            }\n            if (defines.SPECULAR) {\n                fallbacks.addFallback(0, \"SPECULAR\");\n            }\n            if (defines.BUMP) {\n                fallbacks.addFallback(0, \"BUMP\");\n            }\n            if (defines.PARALLAX) {\n                fallbacks.addFallback(1, \"PARALLAX\");\n            }\n            if (defines.PARALLAXOCCLUSION) {\n                fallbacks.addFallback(0, \"PARALLAXOCCLUSION\");\n            }\n            if (defines.SPECULAROVERALPHA) {\n                fallbacks.addFallback(0, \"SPECULAROVERALPHA\");\n            }\n            if (defines.FOG) {\n                fallbacks.addFallback(1, \"FOG\");\n            }\n            if (defines.POINTSIZE) {\n                fallbacks.addFallback(0, \"POINTSIZE\");\n            }\n            if (defines.LOGARITHMICDEPTH) {\n                fallbacks.addFallback(0, \"LOGARITHMICDEPTH\");\n            }\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);\n            if (defines.SPECULARTERM) {\n                fallbacks.addFallback(0, \"SPECULARTERM\");\n            }\n            if (defines.DIFFUSEFRESNEL) {\n                fallbacks.addFallback(1, \"DIFFUSEFRESNEL\");\n            }\n            if (defines.OPACITYFRESNEL) {\n                fallbacks.addFallback(2, \"OPACITYFRESNEL\");\n            }\n            if (defines.REFLECTIONFRESNEL) {\n                fallbacks.addFallback(3, \"REFLECTIONFRESNEL\");\n            }\n            if (defines.EMISSIVEFRESNEL) {\n                fallbacks.addFallback(4, \"EMISSIVEFRESNEL\");\n            }\n            if (defines.FRESNEL) {\n                fallbacks.addFallback(4, \"FRESNEL\");\n            }\n            if (defines.MULTIVIEW) {\n                fallbacks.addFallback(0, \"MULTIVIEW\");\n            }\n            //Attributes\n            const attribs = [VertexBuffer.PositionKind];\n            if (defines.NORMAL) {\n                attribs.push(VertexBuffer.NormalKind);\n            }\n            if (defines.TANGENT) {\n                attribs.push(VertexBuffer.TangentKind);\n            }\n            for (let i = 1; i <= 6; ++i) {\n                if (defines[\"UV\" + i]) {\n                    attribs.push(`uv${i === 1 ? \"\" : i}`);\n                }\n            }\n            if (defines.VERTEXCOLOR) {\n                attribs.push(VertexBuffer.ColorKind);\n            }\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\n            MaterialHelper.PrepareAttributesForMorphTargets(attribs, mesh, defines);\n            MaterialHelper.PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\n            let shaderName = \"default\";\n            const uniforms = [\n                \"world\",\n                \"view\",\n                \"viewProjection\",\n                \"vEyePosition\",\n                \"vLightsType\",\n                \"vAmbientColor\",\n                \"vDiffuseColor\",\n                \"vSpecularColor\",\n                \"vEmissiveColor\",\n                \"visibility\",\n                \"vFogInfos\",\n                \"vFogColor\",\n                \"pointSize\",\n                \"vDiffuseInfos\",\n                \"vAmbientInfos\",\n                \"vOpacityInfos\",\n                \"vReflectionInfos\",\n                \"vEmissiveInfos\",\n                \"vSpecularInfos\",\n                \"vBumpInfos\",\n                \"vLightmapInfos\",\n                \"vRefractionInfos\",\n                \"mBones\",\n                \"diffuseMatrix\",\n                \"ambientMatrix\",\n                \"opacityMatrix\",\n                \"reflectionMatrix\",\n                \"emissiveMatrix\",\n                \"specularMatrix\",\n                \"bumpMatrix\",\n                \"normalMatrix\",\n                \"lightmapMatrix\",\n                \"refractionMatrix\",\n                \"diffuseLeftColor\",\n                \"diffuseRightColor\",\n                \"opacityParts\",\n                \"reflectionLeftColor\",\n                \"reflectionRightColor\",\n                \"emissiveLeftColor\",\n                \"emissiveRightColor\",\n                \"refractionLeftColor\",\n                \"refractionRightColor\",\n                \"vReflectionPosition\",\n                \"vReflectionSize\",\n                \"vRefractionPosition\",\n                \"vRefractionSize\",\n                \"logarithmicDepthConstant\",\n                \"vTangentSpaceParams\",\n                \"alphaCutOff\",\n                \"boneTextureWidth\",\n                \"morphTargetTextureInfo\",\n                \"morphTargetTextureIndices\",\n            ];\n            const samplers = [\n                \"diffuseSampler\",\n                \"ambientSampler\",\n                \"opacitySampler\",\n                \"reflectionCubeSampler\",\n                \"reflection2DSampler\",\n                \"emissiveSampler\",\n                \"specularSampler\",\n                \"bumpSampler\",\n                \"lightmapSampler\",\n                \"refractionCubeSampler\",\n                \"refraction2DSampler\",\n                \"boneSampler\",\n                \"morphTargets\",\n                \"oitDepthSampler\",\n                \"oitFrontColorSampler\",\n            ];\n            const uniformBuffers = [\"Material\", \"Scene\", \"Mesh\"];\n            this._eventInfo.fallbacks = fallbacks;\n            this._eventInfo.fallbackRank = 0;\n            this._eventInfo.defines = defines;\n            this._eventInfo.uniforms = uniforms;\n            this._eventInfo.attributes = attribs;\n            this._eventInfo.samplers = samplers;\n            this._eventInfo.uniformBuffersNames = uniformBuffers;\n            this._eventInfo.customCode = undefined;\n            this._eventInfo.mesh = mesh;\n            this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareEffect, this._eventInfo);\n            PrePassConfiguration.AddUniforms(uniforms);\n            PrePassConfiguration.AddSamplers(samplers);\n            if (ImageProcessingConfiguration) {\n                ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\n                ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\n            }\n            MaterialHelper.PrepareUniformsAndSamplersList({\n                uniformsNames: uniforms,\n                uniformBuffersNames: uniformBuffers,\n                samplers: samplers,\n                defines: defines,\n                maxSimultaneousLights: this._maxSimultaneousLights,\n            });\n            addClipPlaneUniforms(uniforms);\n            const csnrOptions = {};\n            if (this.customShaderNameResolve) {\n                shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);\n            }\n            const join = defines.toString();\n            const previousEffect = subMesh.effect;\n            let effect = scene.getEngine().createEffect(shaderName, {\n                attributes: attribs,\n                uniformsNames: uniforms,\n                uniformBuffersNames: uniformBuffers,\n                samplers: samplers,\n                defines: join,\n                fallbacks: fallbacks,\n                onCompiled: this.onCompiled,\n                onError: this.onError,\n                indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS },\n                processFinalCode: csnrOptions.processFinalCode,\n                processCodeAfterIncludes: this._eventInfo.customCode,\n                multiTarget: defines.PREPASS,\n            }, engine);\n            this._eventInfo.customCode = undefined;\n            if (effect) {\n                if (this._onEffectCreatedObservable) {\n                    onCreatedEffectParameters.effect = effect;\n                    onCreatedEffectParameters.subMesh = subMesh;\n                    this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\n                }\n                // Use previous effect while new one is compiling\n                if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\n                    effect = previousEffect;\n                    defines.markAsUnprocessed();\n                    forceWasNotReadyPreviously = this.isFrozen;\n                    if (lightDisposed) {\n                        // re register in case it takes more than one frame.\n                        defines._areLightsDisposed = true;\n                        return false;\n                    }\n                }\n                else {\n                    scene.resetCachedMaterial();\n                    subMesh.setEffect(effect, defines, this._materialContext);\n                }\n            }\n        }\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\n            return false;\n        }\n        defines._renderId = scene.getRenderId();\n        subMesh.effect._wasPreviouslyReady = forceWasNotReadyPreviously ? false : true;\n        subMesh.effect._wasPreviouslyUsingInstances = useInstances;\n        this._checkScenePerformancePriority();\n        return true;\n    }\n    /**\n     * Builds the material UBO layouts.\n     * Used internally during the effect preparation.\n     */\n    buildUniformLayout() {\n        // Order is important !\n        const ubo = this._uniformBuffer;\n        ubo.addUniform(\"diffuseLeftColor\", 4);\n        ubo.addUniform(\"diffuseRightColor\", 4);\n        ubo.addUniform(\"opacityParts\", 4);\n        ubo.addUniform(\"reflectionLeftColor\", 4);\n        ubo.addUniform(\"reflectionRightColor\", 4);\n        ubo.addUniform(\"refractionLeftColor\", 4);\n        ubo.addUniform(\"refractionRightColor\", 4);\n        ubo.addUniform(\"emissiveLeftColor\", 4);\n        ubo.addUniform(\"emissiveRightColor\", 4);\n        ubo.addUniform(\"vDiffuseInfos\", 2);\n        ubo.addUniform(\"vAmbientInfos\", 2);\n        ubo.addUniform(\"vOpacityInfos\", 2);\n        ubo.addUniform(\"vReflectionInfos\", 2);\n        ubo.addUniform(\"vReflectionPosition\", 3);\n        ubo.addUniform(\"vReflectionSize\", 3);\n        ubo.addUniform(\"vEmissiveInfos\", 2);\n        ubo.addUniform(\"vLightmapInfos\", 2);\n        ubo.addUniform(\"vSpecularInfos\", 2);\n        ubo.addUniform(\"vBumpInfos\", 3);\n        ubo.addUniform(\"diffuseMatrix\", 16);\n        ubo.addUniform(\"ambientMatrix\", 16);\n        ubo.addUniform(\"opacityMatrix\", 16);\n        ubo.addUniform(\"reflectionMatrix\", 16);\n        ubo.addUniform(\"emissiveMatrix\", 16);\n        ubo.addUniform(\"lightmapMatrix\", 16);\n        ubo.addUniform(\"specularMatrix\", 16);\n        ubo.addUniform(\"bumpMatrix\", 16);\n        ubo.addUniform(\"vTangentSpaceParams\", 2);\n        ubo.addUniform(\"pointSize\", 1);\n        ubo.addUniform(\"alphaCutOff\", 1);\n        ubo.addUniform(\"refractionMatrix\", 16);\n        ubo.addUniform(\"vRefractionInfos\", 4);\n        ubo.addUniform(\"vRefractionPosition\", 3);\n        ubo.addUniform(\"vRefractionSize\", 3);\n        ubo.addUniform(\"vSpecularColor\", 4);\n        ubo.addUniform(\"vEmissiveColor\", 3);\n        ubo.addUniform(\"vDiffuseColor\", 4);\n        ubo.addUniform(\"vAmbientColor\", 3);\n        super.buildUniformLayout();\n    }\n    /**\n     * Binds the submesh to this material by preparing the effect and shader to draw\n     * @param world defines the world transformation matrix\n     * @param mesh defines the mesh containing the submesh\n     * @param subMesh defines the submesh to bind the material to\n     */\n    bindForSubMesh(world, mesh, subMesh) {\n        var _a;\n        const scene = this.getScene();\n        const defines = subMesh.materialDefines;\n        if (!defines) {\n            return;\n        }\n        const effect = subMesh.effect;\n        if (!effect) {\n            return;\n        }\n        this._activeEffect = effect;\n        // Matrices Mesh.\n        mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\n        mesh.transferToEffect(world);\n        // Binding unconditionally\n        this._uniformBuffer.bindToEffect(effect, \"Material\");\n        this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);\n        this._eventInfo.subMesh = subMesh;\n        this._callbackPluginEventHardBindForSubMesh(this._eventInfo);\n        // Normal Matrix\n        if (defines.OBJECTSPACE_NORMALMAP) {\n            world.toNormalMatrix(this._normalMatrix);\n            this.bindOnlyNormalMatrix(this._normalMatrix);\n        }\n        const mustRebind = effect._forceRebindOnNextCall || this._mustRebind(scene, effect, mesh.visibility);\n        // Bones\n        MaterialHelper.BindBonesParameters(mesh, effect);\n        const ubo = this._uniformBuffer;\n        if (mustRebind) {\n            this.bindViewProjection(effect);\n            if (!ubo.useUbo || !this.isFrozen || !ubo.isSync || effect._forceRebindOnNextCall) {\n                if (StandardMaterial.FresnelEnabled && defines.FRESNEL) {\n                    // Fresnel\n                    if (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled) {\n                        ubo.updateColor4(\"diffuseLeftColor\", this.diffuseFresnelParameters.leftColor, this.diffuseFresnelParameters.power);\n                        ubo.updateColor4(\"diffuseRightColor\", this.diffuseFresnelParameters.rightColor, this.diffuseFresnelParameters.bias);\n                    }\n                    if (this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled) {\n                        ubo.updateColor4(\"opacityParts\", new Color3(this.opacityFresnelParameters.leftColor.toLuminance(), this.opacityFresnelParameters.rightColor.toLuminance(), this.opacityFresnelParameters.bias), this.opacityFresnelParameters.power);\n                    }\n                    if (this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled) {\n                        ubo.updateColor4(\"reflectionLeftColor\", this.reflectionFresnelParameters.leftColor, this.reflectionFresnelParameters.power);\n                        ubo.updateColor4(\"reflectionRightColor\", this.reflectionFresnelParameters.rightColor, this.reflectionFresnelParameters.bias);\n                    }\n                    if (this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled) {\n                        ubo.updateColor4(\"refractionLeftColor\", this.refractionFresnelParameters.leftColor, this.refractionFresnelParameters.power);\n                        ubo.updateColor4(\"refractionRightColor\", this.refractionFresnelParameters.rightColor, this.refractionFresnelParameters.bias);\n                    }\n                    if (this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled) {\n                        ubo.updateColor4(\"emissiveLeftColor\", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power);\n                        ubo.updateColor4(\"emissiveRightColor\", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias);\n                    }\n                }\n                // Textures\n                if (scene.texturesEnabled) {\n                    if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\n                        ubo.updateFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\n                        MaterialHelper.BindTextureMatrix(this._diffuseTexture, ubo, \"diffuse\");\n                    }\n                    if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\n                        ubo.updateFloat2(\"vAmbientInfos\", this._ambientTexture.coordinatesIndex, this._ambientTexture.level);\n                        MaterialHelper.BindTextureMatrix(this._ambientTexture, ubo, \"ambient\");\n                    }\n                    if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\n                        ubo.updateFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);\n                        MaterialHelper.BindTextureMatrix(this._opacityTexture, ubo, \"opacity\");\n                    }\n                    if (this._hasAlphaChannel()) {\n                        ubo.updateFloat(\"alphaCutOff\", this.alphaCutOff);\n                    }\n                    if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\n                        ubo.updateFloat2(\"vReflectionInfos\", this._reflectionTexture.level, this.roughness);\n                        ubo.updateMatrix(\"reflectionMatrix\", this._reflectionTexture.getReflectionTextureMatrix());\n                        if (this._reflectionTexture.boundingBoxSize) {\n                            const cubeTexture = this._reflectionTexture;\n                            ubo.updateVector3(\"vReflectionPosition\", cubeTexture.boundingBoxPosition);\n                            ubo.updateVector3(\"vReflectionSize\", cubeTexture.boundingBoxSize);\n                        }\n                    }\n                    if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\n                        ubo.updateFloat2(\"vEmissiveInfos\", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);\n                        MaterialHelper.BindTextureMatrix(this._emissiveTexture, ubo, \"emissive\");\n                    }\n                    if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\n                        ubo.updateFloat2(\"vLightmapInfos\", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);\n                        MaterialHelper.BindTextureMatrix(this._lightmapTexture, ubo, \"lightmap\");\n                    }\n                    if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\n                        ubo.updateFloat2(\"vSpecularInfos\", this._specularTexture.coordinatesIndex, this._specularTexture.level);\n                        MaterialHelper.BindTextureMatrix(this._specularTexture, ubo, \"specular\");\n                    }\n                    if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {\n                        ubo.updateFloat3(\"vBumpInfos\", this._bumpTexture.coordinatesIndex, 1.0 / this._bumpTexture.level, this.parallaxScaleBias);\n                        MaterialHelper.BindTextureMatrix(this._bumpTexture, ubo, \"bump\");\n                        if (scene._mirroredCameraPosition) {\n                            ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? 1.0 : -1.0, this._invertNormalMapY ? 1.0 : -1.0);\n                        }\n                        else {\n                            ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? -1.0 : 1.0, this._invertNormalMapY ? -1.0 : 1.0);\n                        }\n                    }\n                    if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\n                        let depth = 1.0;\n                        if (!this._refractionTexture.isCube) {\n                            ubo.updateMatrix(\"refractionMatrix\", this._refractionTexture.getReflectionTextureMatrix());\n                            if (this._refractionTexture.depth) {\n                                depth = this._refractionTexture.depth;\n                            }\n                        }\n                        ubo.updateFloat4(\"vRefractionInfos\", this._refractionTexture.level, this.indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);\n                        if (this._refractionTexture.boundingBoxSize) {\n                            const cubeTexture = this._refractionTexture;\n                            ubo.updateVector3(\"vRefractionPosition\", cubeTexture.boundingBoxPosition);\n                            ubo.updateVector3(\"vRefractionSize\", cubeTexture.boundingBoxSize);\n                        }\n                    }\n                }\n                // Point size\n                if (this.pointsCloud) {\n                    ubo.updateFloat(\"pointSize\", this.pointSize);\n                }\n                if (defines.SPECULARTERM) {\n                    ubo.updateColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\n                }\n                ubo.updateColor3(\"vEmissiveColor\", StandardMaterial.EmissiveTextureEnabled ? this.emissiveColor : Color3.BlackReadOnly);\n                ubo.updateColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha);\n                scene.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor);\n                ubo.updateColor3(\"vAmbientColor\", this._globalAmbientColor);\n            }\n            // Textures\n            if (scene.texturesEnabled) {\n                if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\n                    effect.setTexture(\"diffuseSampler\", this._diffuseTexture);\n                }\n                if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\n                    effect.setTexture(\"ambientSampler\", this._ambientTexture);\n                }\n                if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\n                    effect.setTexture(\"opacitySampler\", this._opacityTexture);\n                }\n                if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\n                    if (this._reflectionTexture.isCube) {\n                        effect.setTexture(\"reflectionCubeSampler\", this._reflectionTexture);\n                    }\n                    else {\n                        effect.setTexture(\"reflection2DSampler\", this._reflectionTexture);\n                    }\n                }\n                if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\n                    effect.setTexture(\"emissiveSampler\", this._emissiveTexture);\n                }\n                if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\n                    effect.setTexture(\"lightmapSampler\", this._lightmapTexture);\n                }\n                if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\n                    effect.setTexture(\"specularSampler\", this._specularTexture);\n                }\n                if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {\n                    effect.setTexture(\"bumpSampler\", this._bumpTexture);\n                }\n                if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\n                    if (this._refractionTexture.isCube) {\n                        effect.setTexture(\"refractionCubeSampler\", this._refractionTexture);\n                    }\n                    else {\n                        effect.setTexture(\"refraction2DSampler\", this._refractionTexture);\n                    }\n                }\n            }\n            // OIT with depth peeling\n            if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {\n                this.getScene().depthPeelingRenderer.bind(effect);\n            }\n            this._eventInfo.subMesh = subMesh;\n            this._callbackPluginEventBindForSubMesh(this._eventInfo);\n            // Clip plane\n            bindClipPlane(effect, this, scene);\n            // Colors\n            this.bindEyePosition(effect);\n        }\n        else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {\n            this._needToBindSceneUbo = true;\n        }\n        if (mustRebind || !this.isFrozen) {\n            // Lights\n            if (scene.lightsEnabled && !this._disableLighting) {\n                MaterialHelper.BindLights(scene, mesh, effect, defines, this._maxSimultaneousLights);\n            }\n            // View\n            if ((scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) ||\n                this._reflectionTexture ||\n                this._refractionTexture ||\n                mesh.receiveShadows ||\n                defines.PREPASS) {\n                this.bindView(effect);\n            }\n            // Fog\n            MaterialHelper.BindFogParameters(scene, mesh, effect);\n            // Morph targets\n            if (defines.NUM_MORPH_INFLUENCERS) {\n                MaterialHelper.BindMorphTargetParameters(mesh, effect);\n            }\n            if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {\n                (_a = mesh.bakedVertexAnimationManager) === null || _a === void 0 ? void 0 : _a.bind(effect, defines.INSTANCES);\n            }\n            // Log. depth\n            if (this.useLogarithmicDepth) {\n                MaterialHelper.BindLogDepth(defines, effect, scene);\n            }\n            // image processing\n            if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\n                this._imageProcessingConfiguration.bind(this._activeEffect);\n            }\n        }\n        this._afterBind(mesh, this._activeEffect);\n        ubo.update();\n    }\n    /**\n     * Get the list of animatables in the material.\n     * @returns the list of animatables object used in the material\n     */\n    getAnimatables() {\n        const results = super.getAnimatables();\n        if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {\n            results.push(this._diffuseTexture);\n        }\n        if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {\n            results.push(this._ambientTexture);\n        }\n        if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {\n            results.push(this._opacityTexture);\n        }\n        if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {\n            results.push(this._reflectionTexture);\n        }\n        if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {\n            results.push(this._emissiveTexture);\n        }\n        if (this._specularTexture && this._specularTexture.animations && this._specularTexture.animations.length > 0) {\n            results.push(this._specularTexture);\n        }\n        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {\n            results.push(this._bumpTexture);\n        }\n        if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {\n            results.push(this._lightmapTexture);\n        }\n        if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\n            results.push(this._refractionTexture);\n        }\n        return results;\n    }\n    /**\n     * Gets the active textures from the material\n     * @returns an array of textures\n     */\n    getActiveTextures() {\n        const activeTextures = super.getActiveTextures();\n        if (this._diffuseTexture) {\n            activeTextures.push(this._diffuseTexture);\n        }\n        if (this._ambientTexture) {\n            activeTextures.push(this._ambientTexture);\n        }\n        if (this._opacityTexture) {\n            activeTextures.push(this._opacityTexture);\n        }\n        if (this._reflectionTexture) {\n            activeTextures.push(this._reflectionTexture);\n        }\n        if (this._emissiveTexture) {\n            activeTextures.push(this._emissiveTexture);\n        }\n        if (this._specularTexture) {\n            activeTextures.push(this._specularTexture);\n        }\n        if (this._bumpTexture) {\n            activeTextures.push(this._bumpTexture);\n        }\n        if (this._lightmapTexture) {\n            activeTextures.push(this._lightmapTexture);\n        }\n        if (this._refractionTexture) {\n            activeTextures.push(this._refractionTexture);\n        }\n        return activeTextures;\n    }\n    /**\n     * Specifies if the material uses a texture\n     * @param texture defines the texture to check against the material\n     * @returns a boolean specifying if the material uses the texture\n     */\n    hasTexture(texture) {\n        if (super.hasTexture(texture)) {\n            return true;\n        }\n        if (this._diffuseTexture === texture) {\n            return true;\n        }\n        if (this._ambientTexture === texture) {\n            return true;\n        }\n        if (this._opacityTexture === texture) {\n            return true;\n        }\n        if (this._reflectionTexture === texture) {\n            return true;\n        }\n        if (this._emissiveTexture === texture) {\n            return true;\n        }\n        if (this._specularTexture === texture) {\n            return true;\n        }\n        if (this._bumpTexture === texture) {\n            return true;\n        }\n        if (this._lightmapTexture === texture) {\n            return true;\n        }\n        if (this._refractionTexture === texture) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Disposes the material\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\n     */\n    dispose(forceDisposeEffect, forceDisposeTextures) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (forceDisposeTextures) {\n            (_a = this._diffuseTexture) === null || _a === void 0 ? void 0 : _a.dispose();\n            (_b = this._ambientTexture) === null || _b === void 0 ? void 0 : _b.dispose();\n            (_c = this._opacityTexture) === null || _c === void 0 ? void 0 : _c.dispose();\n            (_d = this._reflectionTexture) === null || _d === void 0 ? void 0 : _d.dispose();\n            (_e = this._emissiveTexture) === null || _e === void 0 ? void 0 : _e.dispose();\n            (_f = this._specularTexture) === null || _f === void 0 ? void 0 : _f.dispose();\n            (_g = this._bumpTexture) === null || _g === void 0 ? void 0 : _g.dispose();\n            (_h = this._lightmapTexture) === null || _h === void 0 ? void 0 : _h.dispose();\n            (_j = this._refractionTexture) === null || _j === void 0 ? void 0 : _j.dispose();\n        }\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n        }\n        super.dispose(forceDisposeEffect, forceDisposeTextures);\n    }\n    /**\n     * Makes a duplicate of the material, and gives it a new name\n     * @param name defines the new name for the duplicated material\n     * @returns the cloned material\n     */\n    clone(name) {\n        const result = SerializationHelper.Clone(() => new StandardMaterial(name, this.getScene()), this);\n        result.name = name;\n        result.id = name;\n        this.stencil.copyTo(result.stencil);\n        return result;\n    }\n    /**\n     * Creates a standard material from parsed material data\n     * @param source defines the JSON representation of the material\n     * @param scene defines the hosting scene\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\n     * @returns a new standard material\n     */\n    static Parse(source, scene, rootUrl) {\n        const material = SerializationHelper.Parse(() => new StandardMaterial(source.name, scene), source, scene, rootUrl);\n        if (source.stencil) {\n            material.stencil.parse(source.stencil, scene, rootUrl);\n        }\n        return material;\n    }\n    // Flags used to enable or disable a type of texture for all Standard Materials\n    /**\n     * Are diffuse textures enabled in the application.\n     */\n    static get DiffuseTextureEnabled() {\n        return MaterialFlags.DiffuseTextureEnabled;\n    }\n    static set DiffuseTextureEnabled(value) {\n        MaterialFlags.DiffuseTextureEnabled = value;\n    }\n    /**\n     * Are detail textures enabled in the application.\n     */\n    static get DetailTextureEnabled() {\n        return MaterialFlags.DetailTextureEnabled;\n    }\n    static set DetailTextureEnabled(value) {\n        MaterialFlags.DetailTextureEnabled = value;\n    }\n    /**\n     * Are ambient textures enabled in the application.\n     */\n    static get AmbientTextureEnabled() {\n        return MaterialFlags.AmbientTextureEnabled;\n    }\n    static set AmbientTextureEnabled(value) {\n        MaterialFlags.AmbientTextureEnabled = value;\n    }\n    /**\n     * Are opacity textures enabled in the application.\n     */\n    static get OpacityTextureEnabled() {\n        return MaterialFlags.OpacityTextureEnabled;\n    }\n    static set OpacityTextureEnabled(value) {\n        MaterialFlags.OpacityTextureEnabled = value;\n    }\n    /**\n     * Are reflection textures enabled in the application.\n     */\n    static get ReflectionTextureEnabled() {\n        return MaterialFlags.ReflectionTextureEnabled;\n    }\n    static set ReflectionTextureEnabled(value) {\n        MaterialFlags.ReflectionTextureEnabled = value;\n    }\n    /**\n     * Are emissive textures enabled in the application.\n     */\n    static get EmissiveTextureEnabled() {\n        return MaterialFlags.EmissiveTextureEnabled;\n    }\n    static set EmissiveTextureEnabled(value) {\n        MaterialFlags.EmissiveTextureEnabled = value;\n    }\n    /**\n     * Are specular textures enabled in the application.\n     */\n    static get SpecularTextureEnabled() {\n        return MaterialFlags.SpecularTextureEnabled;\n    }\n    static set SpecularTextureEnabled(value) {\n        MaterialFlags.SpecularTextureEnabled = value;\n    }\n    /**\n     * Are bump textures enabled in the application.\n     */\n    static get BumpTextureEnabled() {\n        return MaterialFlags.BumpTextureEnabled;\n    }\n    static set BumpTextureEnabled(value) {\n        MaterialFlags.BumpTextureEnabled = value;\n    }\n    /**\n     * Are lightmap textures enabled in the application.\n     */\n    static get LightmapTextureEnabled() {\n        return MaterialFlags.LightmapTextureEnabled;\n    }\n    static set LightmapTextureEnabled(value) {\n        MaterialFlags.LightmapTextureEnabled = value;\n    }\n    /**\n     * Are refraction textures enabled in the application.\n     */\n    static get RefractionTextureEnabled() {\n        return MaterialFlags.RefractionTextureEnabled;\n    }\n    static set RefractionTextureEnabled(value) {\n        MaterialFlags.RefractionTextureEnabled = value;\n    }\n    /**\n     * Are color grading textures enabled in the application.\n     */\n    static get ColorGradingTextureEnabled() {\n        return MaterialFlags.ColorGradingTextureEnabled;\n    }\n    static set ColorGradingTextureEnabled(value) {\n        MaterialFlags.ColorGradingTextureEnabled = value;\n    }\n    /**\n     * Are fresnels enabled in the application.\n     */\n    static get FresnelEnabled() {\n        return MaterialFlags.FresnelEnabled;\n    }\n    static set FresnelEnabled(value) {\n        MaterialFlags.FresnelEnabled = value;\n    }\n}\n__decorate([\n    serializeAsTexture(\"diffuseTexture\")\n], StandardMaterial.prototype, \"_diffuseTexture\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\n], StandardMaterial.prototype, \"diffuseTexture\", void 0);\n__decorate([\n    serializeAsTexture(\"ambientTexture\")\n], StandardMaterial.prototype, \"_ambientTexture\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], StandardMaterial.prototype, \"ambientTexture\", void 0);\n__decorate([\n    serializeAsTexture(\"opacityTexture\")\n], StandardMaterial.prototype, \"_opacityTexture\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\n], StandardMaterial.prototype, \"opacityTexture\", void 0);\n__decorate([\n    serializeAsTexture(\"reflectionTexture\")\n], StandardMaterial.prototype, \"_reflectionTexture\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], StandardMaterial.prototype, \"reflectionTexture\", void 0);\n__decorate([\n    serializeAsTexture(\"emissiveTexture\")\n], StandardMaterial.prototype, \"_emissiveTexture\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], StandardMaterial.prototype, \"emissiveTexture\", void 0);\n__decorate([\n    serializeAsTexture(\"specularTexture\")\n], StandardMaterial.prototype, \"_specularTexture\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], StandardMaterial.prototype, \"specularTexture\", void 0);\n__decorate([\n    serializeAsTexture(\"bumpTexture\")\n], StandardMaterial.prototype, \"_bumpTexture\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], StandardMaterial.prototype, \"bumpTexture\", void 0);\n__decorate([\n    serializeAsTexture(\"lightmapTexture\")\n], StandardMaterial.prototype, \"_lightmapTexture\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], StandardMaterial.prototype, \"lightmapTexture\", void 0);\n__decorate([\n    serializeAsTexture(\"refractionTexture\")\n], StandardMaterial.prototype, \"_refractionTexture\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], StandardMaterial.prototype, \"refractionTexture\", void 0);\n__decorate([\n    serializeAsColor3(\"ambient\")\n], StandardMaterial.prototype, \"ambientColor\", void 0);\n__decorate([\n    serializeAsColor3(\"diffuse\")\n], StandardMaterial.prototype, \"diffuseColor\", void 0);\n__decorate([\n    serializeAsColor3(\"specular\")\n], StandardMaterial.prototype, \"specularColor\", void 0);\n__decorate([\n    serializeAsColor3(\"emissive\")\n], StandardMaterial.prototype, \"emissiveColor\", void 0);\n__decorate([\n    serialize()\n], StandardMaterial.prototype, \"specularPower\", void 0);\n__decorate([\n    serialize(\"useAlphaFromDiffuseTexture\")\n], StandardMaterial.prototype, \"_useAlphaFromDiffuseTexture\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\n], StandardMaterial.prototype, \"useAlphaFromDiffuseTexture\", void 0);\n__decorate([\n    serialize(\"useEmissiveAsIllumination\")\n], StandardMaterial.prototype, \"_useEmissiveAsIllumination\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], StandardMaterial.prototype, \"useEmissiveAsIllumination\", void 0);\n__decorate([\n    serialize(\"linkEmissiveWithDiffuse\")\n], StandardMaterial.prototype, \"_linkEmissiveWithDiffuse\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], StandardMaterial.prototype, \"linkEmissiveWithDiffuse\", void 0);\n__decorate([\n    serialize(\"useSpecularOverAlpha\")\n], StandardMaterial.prototype, \"_useSpecularOverAlpha\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], StandardMaterial.prototype, \"useSpecularOverAlpha\", void 0);\n__decorate([\n    serialize(\"useReflectionOverAlpha\")\n], StandardMaterial.prototype, \"_useReflectionOverAlpha\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], StandardMaterial.prototype, \"useReflectionOverAlpha\", void 0);\n__decorate([\n    serialize(\"disableLighting\")\n], StandardMaterial.prototype, \"_disableLighting\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n], StandardMaterial.prototype, \"disableLighting\", void 0);\n__decorate([\n    serialize(\"useObjectSpaceNormalMap\")\n], StandardMaterial.prototype, \"_useObjectSpaceNormalMap\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], StandardMaterial.prototype, \"useObjectSpaceNormalMap\", void 0);\n__decorate([\n    serialize(\"useParallax\")\n], StandardMaterial.prototype, \"_useParallax\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], StandardMaterial.prototype, \"useParallax\", void 0);\n__decorate([\n    serialize(\"useParallaxOcclusion\")\n], StandardMaterial.prototype, \"_useParallaxOcclusion\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], StandardMaterial.prototype, \"useParallaxOcclusion\", void 0);\n__decorate([\n    serialize()\n], StandardMaterial.prototype, \"parallaxScaleBias\", void 0);\n__decorate([\n    serialize(\"roughness\")\n], StandardMaterial.prototype, \"_roughness\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], StandardMaterial.prototype, \"roughness\", void 0);\n__decorate([\n    serialize()\n], StandardMaterial.prototype, \"indexOfRefraction\", void 0);\n__decorate([\n    serialize()\n], StandardMaterial.prototype, \"invertRefractionY\", void 0);\n__decorate([\n    serialize()\n], StandardMaterial.prototype, \"alphaCutOff\", void 0);\n__decorate([\n    serialize(\"useLightmapAsShadowmap\")\n], StandardMaterial.prototype, \"_useLightmapAsShadowmap\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], StandardMaterial.prototype, \"useLightmapAsShadowmap\", void 0);\n__decorate([\n    serializeAsFresnelParameters(\"diffuseFresnelParameters\")\n], StandardMaterial.prototype, \"_diffuseFresnelParameters\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\n], StandardMaterial.prototype, \"diffuseFresnelParameters\", void 0);\n__decorate([\n    serializeAsFresnelParameters(\"opacityFresnelParameters\")\n], StandardMaterial.prototype, \"_opacityFresnelParameters\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsFresnelAndMiscDirty\")\n], StandardMaterial.prototype, \"opacityFresnelParameters\", void 0);\n__decorate([\n    serializeAsFresnelParameters(\"reflectionFresnelParameters\")\n], StandardMaterial.prototype, \"_reflectionFresnelParameters\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\n], StandardMaterial.prototype, \"reflectionFresnelParameters\", void 0);\n__decorate([\n    serializeAsFresnelParameters(\"refractionFresnelParameters\")\n], StandardMaterial.prototype, \"_refractionFresnelParameters\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\n], StandardMaterial.prototype, \"refractionFresnelParameters\", void 0);\n__decorate([\n    serializeAsFresnelParameters(\"emissiveFresnelParameters\")\n], StandardMaterial.prototype, \"_emissiveFresnelParameters\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\n], StandardMaterial.prototype, \"emissiveFresnelParameters\", void 0);\n__decorate([\n    serialize(\"useReflectionFresnelFromSpecular\")\n], StandardMaterial.prototype, \"_useReflectionFresnelFromSpecular\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\n], StandardMaterial.prototype, \"useReflectionFresnelFromSpecular\", void 0);\n__decorate([\n    serialize(\"useGlossinessFromSpecularMapAlpha\")\n], StandardMaterial.prototype, \"_useGlossinessFromSpecularMapAlpha\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], StandardMaterial.prototype, \"useGlossinessFromSpecularMapAlpha\", void 0);\n__decorate([\n    serialize(\"maxSimultaneousLights\")\n], StandardMaterial.prototype, \"_maxSimultaneousLights\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n], StandardMaterial.prototype, \"maxSimultaneousLights\", void 0);\n__decorate([\n    serialize(\"invertNormalMapX\")\n], StandardMaterial.prototype, \"_invertNormalMapX\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], StandardMaterial.prototype, \"invertNormalMapX\", void 0);\n__decorate([\n    serialize(\"invertNormalMapY\")\n], StandardMaterial.prototype, \"_invertNormalMapY\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], StandardMaterial.prototype, \"invertNormalMapY\", void 0);\n__decorate([\n    serialize(\"twoSidedLighting\")\n], StandardMaterial.prototype, \"_twoSidedLighting\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], StandardMaterial.prototype, \"twoSidedLighting\", void 0);\n__decorate([\n    serialize()\n], StandardMaterial.prototype, \"useLogarithmicDepth\", null);\nRegisterClass(\"BABYLON.StandardMaterial\", StandardMaterial);\nScene.DefaultMaterialFactory = (scene) => {\n    return new StandardMaterial(\"default material\", scene);\n};\n//# sourceMappingURL=standardMaterial.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"imageProcessingCompatibility\";\nconst shader = `#ifdef IMAGEPROCESSINGPOSTPROCESS\ngl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(2.2));\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const imageProcessingCompatibility = { name, shader };\n//# sourceMappingURL=imageProcessingCompatibility.js.map","// Do not edit.\nimport { ShaderStore } from \"@babylonjs/core/Engines/shaderStore.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/helperFunctions.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragment.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragment.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/imageProcessingCompatibility.js\";\nconst name = \"shadowOnlyPixelShader\";\nconst shader = `precision highp float;\runiform vec4 vEyePosition;\runiform float alpha;\runiform vec3 shadowColor;\rvarying vec3 vPositionW;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\r#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\r#else\nvec3 normalW=vec3(1.0,1.0,1.0);\r#endif\nvec3 diffuseBase=vec3(0.,0.,0.);\rlightingInfo info;\rfloat shadow=1.;\rfloat glossiness=0.;\r#include<lightFragment>[0..1]\nvec4 color=vec4(shadowColor,(1.0-clamp(shadow,0.,1.))*alpha);\r#include<fogFragment>\ngl_FragColor=color;\r#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const shadowOnlyPixelShader = { name, shader };\n//# sourceMappingURL=shadowOnly.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"@babylonjs/core/Engines/shaderStore.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesVertex.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesVertex.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimation.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertex.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsVertex.js\";\nconst name = \"shadowOnlyVertexShader\";\nconst shader = `precision highp float;\rattribute vec3 position;\r#ifdef NORMAL\nattribute vec3 normal;\r#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;\runiform mat4 viewProjection;\r#ifdef POINTSIZE\nuniform float pointSize;\r#endif\nvarying vec3 vPositionW;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\r#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);\rgl_Position=viewProjection*worldPos;\rvPositionW=vec3(worldPos);\r#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\r#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\r#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const shadowOnlyVertexShader = { name, shader };\n//# sourceMappingURL=shadowOnly.vertex.js.map","import { SerializationHelper } from \"@babylonjs/core/Misc/decorators.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { MaterialDefines } from \"@babylonjs/core/Materials/materialDefines.js\";\nimport { MaterialHelper } from \"@babylonjs/core/Materials/materialHelper.js\";\nimport { PushMaterial } from \"@babylonjs/core/Materials/pushMaterial.js\";\nimport { VertexBuffer } from \"@babylonjs/core/Buffers/buffer.js\";\nimport { Scene } from \"@babylonjs/core/scene.js\";\nimport { RegisterClass } from \"@babylonjs/core/Misc/typeStore.js\";\nimport \"./shadowOnly.fragment.js\";\nimport \"./shadowOnly.vertex.js\";\nimport { EffectFallbacks } from \"@babylonjs/core/Materials/effectFallbacks.js\";\nimport { addClipPlaneUniforms, bindClipPlane } from \"@babylonjs/core/Materials/clipPlaneMaterialHelper.js\";\nclass ShadowOnlyMaterialDefines extends MaterialDefines {\n    constructor() {\n        super();\n        this.CLIPPLANE = false;\n        this.CLIPPLANE2 = false;\n        this.CLIPPLANE3 = false;\n        this.CLIPPLANE4 = false;\n        this.CLIPPLANE5 = false;\n        this.CLIPPLANE6 = false;\n        this.POINTSIZE = false;\n        this.FOG = false;\n        this.NORMAL = false;\n        this.NUM_BONE_INFLUENCERS = 0;\n        this.BonesPerMesh = 0;\n        this.INSTANCES = false;\n        this.IMAGEPROCESSINGPOSTPROCESS = false;\n        this.SKIPFINALCOLORCLAMP = false;\n        this.rebuild();\n    }\n}\nexport class ShadowOnlyMaterial extends PushMaterial {\n    constructor(name, scene) {\n        super(name, scene);\n        this._needAlphaBlending = true;\n        this.shadowColor = Color3.Black();\n    }\n    needAlphaBlending() {\n        return this._needAlphaBlending;\n    }\n    needAlphaTesting() {\n        return false;\n    }\n    getAlphaTestTexture() {\n        return null;\n    }\n    get activeLight() {\n        return this._activeLight;\n    }\n    set activeLight(light) {\n        this._activeLight = light;\n    }\n    _getFirstShadowLightForMesh(mesh) {\n        for (const light of mesh.lightSources) {\n            if (light.shadowEnabled) {\n                return light;\n            }\n        }\n        return null;\n    }\n    // Methods\n    isReadyForSubMesh(mesh, subMesh, useInstances) {\n        var _a;\n        if (this.isFrozen) {\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\n                return true;\n            }\n        }\n        if (!subMesh.materialDefines) {\n            subMesh.materialDefines = new ShadowOnlyMaterialDefines();\n        }\n        const defines = subMesh.materialDefines;\n        const scene = this.getScene();\n        if (this._isReadyForSubMesh(subMesh)) {\n            return true;\n        }\n        const engine = scene.getEngine();\n        // Ensure that active light is the first shadow light\n        if (this._activeLight) {\n            for (const light of mesh.lightSources) {\n                if (light.shadowEnabled) {\n                    if (this._activeLight === light) {\n                        break; // We are good\n                    }\n                    const lightPosition = mesh.lightSources.indexOf(this._activeLight);\n                    if (lightPosition !== -1) {\n                        mesh.lightSources.splice(lightPosition, 1);\n                        mesh.lightSources.splice(0, 0, this._activeLight);\n                    }\n                    break;\n                }\n            }\n        }\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, 1);\n        const shadowGenerator = (_a = this._getFirstShadowLightForMesh(mesh)) === null || _a === void 0 ? void 0 : _a.getShadowGenerator();\n        this._needAlphaBlending = true;\n        if (shadowGenerator && shadowGenerator.getClassName && shadowGenerator.getClassName() === \"CascadedShadowGenerator\") {\n            const csg = shadowGenerator;\n            this._needAlphaBlending = !csg.autoCalcDepthBounds;\n        }\n        // Attribs\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, false, true);\n        // Get correct effect\n        if (defines.isDirty) {\n            defines.markAsProcessed();\n            scene.resetCachedMaterial();\n            // Fallbacks\n            const fallbacks = new EffectFallbacks();\n            if (defines.FOG) {\n                fallbacks.addFallback(1, \"FOG\");\n            }\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, 1);\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\n                fallbacks.addCPUSkinningFallback(0, mesh);\n            }\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\n            //Attributes\n            const attribs = [VertexBuffer.PositionKind];\n            if (defines.NORMAL) {\n                attribs.push(VertexBuffer.NormalKind);\n            }\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\n            const shaderName = \"shadowOnly\";\n            const join = defines.toString();\n            const uniforms = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\", \"vFogInfos\", \"vFogColor\", \"pointSize\", \"alpha\", \"shadowColor\", \"mBones\"];\n            const samplers = new Array();\n            const uniformBuffers = new Array();\n            addClipPlaneUniforms(uniforms);\n            MaterialHelper.PrepareUniformsAndSamplersList({\n                uniformsNames: uniforms,\n                uniformBuffersNames: uniformBuffers,\n                samplers: samplers,\n                defines: defines,\n                maxSimultaneousLights: 1,\n            });\n            subMesh.setEffect(scene.getEngine().createEffect(shaderName, {\n                attributes: attribs,\n                uniformsNames: uniforms,\n                uniformBuffersNames: uniformBuffers,\n                samplers: samplers,\n                defines: join,\n                fallbacks: fallbacks,\n                onCompiled: this.onCompiled,\n                onError: this.onError,\n                indexParameters: { maxSimultaneousLights: 1 },\n            }, engine), defines, this._materialContext);\n        }\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\n            return false;\n        }\n        defines._renderId = scene.getRenderId();\n        subMesh.effect._wasPreviouslyReady = true;\n        subMesh.effect._wasPreviouslyUsingInstances = !!useInstances;\n        return true;\n    }\n    bindForSubMesh(world, mesh, subMesh) {\n        const scene = this.getScene();\n        const defines = subMesh.materialDefines;\n        if (!defines) {\n            return;\n        }\n        const effect = subMesh.effect;\n        if (!effect) {\n            return;\n        }\n        this._activeEffect = effect;\n        // Matrices\n        this.bindOnlyWorldMatrix(world);\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n        // Bones\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\n        if (this._mustRebind(scene, effect)) {\n            // Clip plane\n            bindClipPlane(effect, this, scene);\n            // Point size\n            if (this.pointsCloud) {\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\n            }\n            this._activeEffect.setFloat(\"alpha\", this.alpha);\n            this._activeEffect.setColor3(\"shadowColor\", this.shadowColor);\n            scene.bindEyePosition(effect);\n        }\n        // Lights\n        if (scene.lightsEnabled) {\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, 1);\n            const light = this._getFirstShadowLightForMesh(mesh);\n            if (light) {\n                // Make sure the uniforms for this light will be rebound for other materials using this light when rendering the current frame.\n                // Indeed, there is an optimization in Light that binds the light uniforms only once per frame for a given light (if using ubo).\n                // Doing this way assumes that all uses of this light are the same, meaning all parameters passed to Light._bindLlight\n                // are the same, notably useSpecular. However, isReadyForSubMesh (see above) is passing false for this parameter, which may not be\n                // the value the other materials may pass.\n                light._renderId = -1;\n            }\n        }\n        // View\n        if ((scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) || defines[\"SHADOWCSM0\"]) {\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\n        }\n        // Fog\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\n        this._afterBind(mesh, this._activeEffect);\n    }\n    clone(name) {\n        return SerializationHelper.Clone(() => new ShadowOnlyMaterial(name, this.getScene()), this);\n    }\n    serialize() {\n        const serializationObject = super.serialize();\n        serializationObject.customType = \"BABYLON.ShadowOnlyMaterial\";\n        return serializationObject;\n    }\n    getClassName() {\n        return \"ShadowOnlyMaterial\";\n    }\n    // Statics\n    static Parse(source, scene, rootUrl) {\n        return SerializationHelper.Parse(() => new ShadowOnlyMaterial(source.name, scene), source, scene, rootUrl);\n    }\n}\nRegisterClass(\"BABYLON.ShadowOnlyMaterial\", ShadowOnlyMaterial);\n//# sourceMappingURL=shadowOnlyMaterial.js.map","import { Color3 } from '@babylonjs/core/Maths/math.color'\nimport { CreateBox } from '@babylonjs/core/Meshes/Builders/boxBuilder'\nimport { StandardMaterial } from '@babylonjs/core/Materials/standardMaterial'\nimport { TransformNode } from '@babylonjs/core/Meshes/transformNode'\nimport { Vector3 } from '@babylonjs/core/Maths/math.vector'\nimport { ShadowOnlyMaterial } from '@babylonjs/materials/shadowOnly/shadowOnlyMaterial'\n\nconst defaultOptions = {\n  aspect: 300 / 150,\n  enableDebugging: false,\n  enableShadows: true,\n}\n\nclass Container{\n\tsize = 9.5\n\tconstructor(options){\n\t\tthis.config = {...defaultOptions, ...options}\n\t\tthis.create()\n\t}\n\tcreate(options){\n\t\t// remove any previously existing boxes\n\t\tthis.destroy()\n\t\t// extend config with options on create\n\t\tObject.assign(this.config,options)\n\t\tconst { aspect, enableDebugging, enableShadows } = this.config\n\t\tconst wallHeight = 30\n\n\t\tthis.box = new TransformNode(\"diceBox\");\n\t\tlet boxMaterial = new ShadowOnlyMaterial('shadowOnly',this.config.scene)\n\t\tboxMaterial.alpha = enableShadows? 1 : 0\n\n\n\t\tif(enableDebugging) {\n\t\t\tboxMaterial = new StandardMaterial(\"diceBox_material\")\n\t\t\tboxMaterial.alpha = .7\n\t\t\tboxMaterial.diffuseColor = new Color3(1, 1, 0);\n\t\t}\n\n\t\t// Bottom of the Box\n\t\tconst ground = CreateBox(\"ground\",{\n\t\t\twidth: this.size * 2, \n\t\t\theight: 1,\n\t\t\tdepth: this.size * 2\n\t\t}, this.config.scene)\n\t\tground.scaling = new Vector3(aspect, 1, 1)\n\t\tground.material = boxMaterial\n\t\tground.receiveShadows = true\n\t\tground.setParent(this.box)\n\n\t\tif(enableDebugging) {\n\t\t\t// North Wall\n\t\t\tconst wallTop = CreateBox(\"wallTop\",{\n\t\t\t\twidth: this.size,\n\t\t\t\theight: wallHeight,\n\t\t\t\tdepth: 1\n\t\t\t}, this.config.scene)\n\t\t\twallTop.position.y = wallHeight / 2\n\t\t\twallTop.position.z = this.size / -2\n\t\t\twallTop.scaling = new Vector3(aspect, 1, 1)\n\t\t\twallTop.material = boxMaterial\n\t\t\t// wallTop.receiveShadows = true\n\t\t\twallTop.setParent(this.box)\n\n\t\t\t// Right Wall\n\t\t\tconst wallRight = CreateBox(\"wallRight\",{\n\t\t\t\twidth: 1, \n\t\t\t\theight: wallHeight,\n\t\t\t\tdepth: this.size\n\t\t\t}, this.config.scene )\n\t\t\twallRight.position.x = this.size * aspect / 2\n\t\t\twallRight.position.y = wallHeight / 2\n\t\t\twallRight.material = boxMaterial\n\t\t\t// wallRight.receiveShadows = true\n\t\t\twallRight.setParent(this.box)\n\n\t\t\t// South Wall\n\t\t\tconst wallBottom = CreateBox(\"wallBottom\",{\n\t\t\t\twidth: this.size, \n\t\t\t\theight: wallHeight,\n\t\t\t\tdepth: 1\n\t\t\t}, this.config.scene)\n\t\t\twallBottom.position.y = wallHeight / 2\n\t\t\twallBottom.position.z = this.size / 2\n\t\t\twallBottom.scaling = new Vector3(aspect, 1, 1)\n\t\t\twallBottom.material = boxMaterial\n\t\t\t// wallBottom.receiveShadows = true\n\t\t\twallBottom.setParent(this.box)\n\n\t\t\t// Left Wall\n\t\t\tconst wallLeft = CreateBox(\"wallLeft\",{\n\t\t\t\twidth: 1, \n\t\t\t\theight: wallHeight,\n\t\t\t\tdepth: this.size\n\t\t\t}, this.config.scene)\n\t\t\twallLeft.position.x = this.size * aspect / -2\n\t\t\twallLeft.position.y = wallHeight / 2\n\t\t\twallLeft.material = boxMaterial\n\t\t\t// wallLeft.receiveShadows = true\n\t\t\twallLeft.setParent(this.box)\n\t\t}\n\n\t}\n\tdestroy(){\n\t\tif(this.box) {\n\t\t\tthis.box.dispose()\n\t\t}\n\t}\n}\n\nexport default Container","import { Effect } from \"@babylonjs/core/Materials/effect.js\";\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial.js\";\nimport { RegisterClass } from \"@babylonjs/core/Misc/typeStore.js\";\nexport class CustomShaderStructure {\n    constructor() { }\n}\nexport class ShaderSpecialParts {\n    constructor() { }\n}\nexport class CustomMaterial extends StandardMaterial {\n    AttachAfterBind(mesh, effect) {\n        if (this._newUniformInstances) {\n            for (const el in this._newUniformInstances) {\n                const ea = el.toString().split(\"-\");\n                if (ea[0] == \"vec2\") {\n                    effect.setVector2(ea[1], this._newUniformInstances[el]);\n                }\n                else if (ea[0] == \"vec3\") {\n                    effect.setVector3(ea[1], this._newUniformInstances[el]);\n                }\n                else if (ea[0] == \"vec4\") {\n                    effect.setVector4(ea[1], this._newUniformInstances[el]);\n                }\n                else if (ea[0] == \"mat4\") {\n                    effect.setMatrix(ea[1], this._newUniformInstances[el]);\n                }\n                else if (ea[0] == \"float\") {\n                    effect.setFloat(ea[1], this._newUniformInstances[el]);\n                }\n            }\n        }\n        if (this._newSamplerInstances) {\n            for (const el in this._newSamplerInstances) {\n                const ea = el.toString().split(\"-\");\n                if (ea[0] == \"sampler2D\" && this._newSamplerInstances[el].isReady && this._newSamplerInstances[el].isReady()) {\n                    effect.setTexture(ea[1], this._newSamplerInstances[el]);\n                }\n            }\n        }\n    }\n    ReviewUniform(name, arr) {\n        if (name == \"uniform\" && this._newUniforms) {\n            for (let ind = 0; ind < this._newUniforms.length; ind++) {\n                if (this._customUniform[ind].indexOf(\"sampler\") == -1) {\n                    arr.push(this._newUniforms[ind].replace(/\\[\\d*\\]/g, \"\"));\n                }\n            }\n        }\n        if (name == \"sampler\" && this._newUniforms) {\n            for (let ind = 0; ind < this._newUniforms.length; ind++) {\n                if (this._customUniform[ind].indexOf(\"sampler\") != -1) {\n                    arr.push(this._newUniforms[ind].replace(/\\[\\d*\\]/g, \"\"));\n                }\n            }\n        }\n        return arr;\n    }\n    Builder(shaderName, uniforms, uniformBuffers, samplers, defines, attributes) {\n        if (attributes && this._customAttributes && this._customAttributes.length > 0) {\n            attributes.push(...this._customAttributes);\n        }\n        this.ReviewUniform(\"uniform\", uniforms);\n        this.ReviewUniform(\"sampler\", samplers);\n        if (this._isCreatedShader) {\n            return this._createdShaderName;\n        }\n        this._isCreatedShader = false;\n        CustomMaterial.ShaderIndexer++;\n        const name = \"custom_\" + CustomMaterial.ShaderIndexer;\n        const fn_afterBind = this._afterBind.bind(this);\n        this._afterBind = (m, e) => {\n            if (!e) {\n                return;\n            }\n            this.AttachAfterBind(m, e);\n            try {\n                fn_afterBind(m, e);\n            }\n            catch (e) { }\n        };\n        Effect.ShadersStore[name + \"VertexShader\"] = this.VertexShader.replace(\"#define CUSTOM_VERTEX_BEGIN\", this.CustomParts.Vertex_Begin ? this.CustomParts.Vertex_Begin : \"\")\n            .replace(\"#define CUSTOM_VERTEX_DEFINITIONS\", (this._customUniform ? this._customUniform.join(\"\\n\") : \"\") + (this.CustomParts.Vertex_Definitions ? this.CustomParts.Vertex_Definitions : \"\"))\n            .replace(\"#define CUSTOM_VERTEX_MAIN_BEGIN\", this.CustomParts.Vertex_MainBegin ? this.CustomParts.Vertex_MainBegin : \"\")\n            .replace(\"#define CUSTOM_VERTEX_UPDATE_POSITION\", this.CustomParts.Vertex_Before_PositionUpdated ? this.CustomParts.Vertex_Before_PositionUpdated : \"\")\n            .replace(\"#define CUSTOM_VERTEX_UPDATE_NORMAL\", this.CustomParts.Vertex_Before_NormalUpdated ? this.CustomParts.Vertex_Before_NormalUpdated : \"\")\n            .replace(\"#define CUSTOM_VERTEX_MAIN_END\", this.CustomParts.Vertex_MainEnd ? this.CustomParts.Vertex_MainEnd : \"\");\n        if (this.CustomParts.Vertex_After_WorldPosComputed) {\n            Effect.ShadersStore[name + \"VertexShader\"] = Effect.ShadersStore[name + \"VertexShader\"].replace(\"#define CUSTOM_VERTEX_UPDATE_WORLDPOS\", this.CustomParts.Vertex_After_WorldPosComputed);\n        }\n        Effect.ShadersStore[name + \"PixelShader\"] = this.FragmentShader.replace(\"#define CUSTOM_FRAGMENT_BEGIN\", this.CustomParts.Fragment_Begin ? this.CustomParts.Fragment_Begin : \"\")\n            .replace(\"#define CUSTOM_FRAGMENT_MAIN_BEGIN\", this.CustomParts.Fragment_MainBegin ? this.CustomParts.Fragment_MainBegin : \"\")\n            .replace(\"#define CUSTOM_FRAGMENT_DEFINITIONS\", (this._customUniform ? this._customUniform.join(\"\\n\") : \"\") + (this.CustomParts.Fragment_Definitions ? this.CustomParts.Fragment_Definitions : \"\"))\n            .replace(\"#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE\", this.CustomParts.Fragment_Custom_Diffuse ? this.CustomParts.Fragment_Custom_Diffuse : \"\")\n            .replace(\"#define CUSTOM_FRAGMENT_UPDATE_ALPHA\", this.CustomParts.Fragment_Custom_Alpha ? this.CustomParts.Fragment_Custom_Alpha : \"\")\n            .replace(\"#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\", this.CustomParts.Fragment_Before_Lights ? this.CustomParts.Fragment_Before_Lights : \"\")\n            .replace(\"#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\", this.CustomParts.Fragment_Before_FragColor ? this.CustomParts.Fragment_Before_FragColor : \"\")\n            .replace(\"#define CUSTOM_FRAGMENT_MAIN_END\", this.CustomParts.Fragment_MainEnd ? this.CustomParts.Fragment_MainEnd : \"\");\n        if (this.CustomParts.Fragment_Before_Fog) {\n            Effect.ShadersStore[name + \"PixelShader\"] = Effect.ShadersStore[name + \"PixelShader\"].replace(\"#define CUSTOM_FRAGMENT_BEFORE_FOG\", this.CustomParts.Fragment_Before_Fog);\n        }\n        this._isCreatedShader = true;\n        this._createdShaderName = name;\n        return name;\n    }\n    constructor(name, scene) {\n        super(name, scene);\n        this.CustomParts = new ShaderSpecialParts();\n        this.customShaderNameResolve = this.Builder;\n        this.FragmentShader = Effect.ShadersStore[\"defaultPixelShader\"];\n        this.VertexShader = Effect.ShadersStore[\"defaultVertexShader\"];\n    }\n    AddUniform(name, kind, param) {\n        if (!this._customUniform) {\n            this._customUniform = new Array();\n            this._newUniforms = new Array();\n            this._newSamplerInstances = {};\n            this._newUniformInstances = {};\n        }\n        if (param) {\n            if (kind.indexOf(\"sampler\") != -1) {\n                this._newSamplerInstances[kind + \"-\" + name] = param;\n            }\n            else {\n                this._newUniformInstances[kind + \"-\" + name] = param;\n            }\n        }\n        this._customUniform.push(\"uniform \" + kind + \" \" + name + \";\");\n        this._newUniforms.push(name);\n        return this;\n    }\n    AddAttribute(name) {\n        if (!this._customAttributes) {\n            this._customAttributes = [];\n        }\n        this._customAttributes.push(name);\n        return this;\n    }\n    Fragment_Begin(shaderPart) {\n        this.CustomParts.Fragment_Begin = shaderPart;\n        return this;\n    }\n    Fragment_Definitions(shaderPart) {\n        this.CustomParts.Fragment_Definitions = shaderPart;\n        return this;\n    }\n    Fragment_MainBegin(shaderPart) {\n        this.CustomParts.Fragment_MainBegin = shaderPart;\n        return this;\n    }\n    Fragment_MainEnd(shaderPart) {\n        this.CustomParts.Fragment_MainEnd = shaderPart;\n        return this;\n    }\n    Fragment_Custom_Diffuse(shaderPart) {\n        this.CustomParts.Fragment_Custom_Diffuse = shaderPart.replace(\"result\", \"diffuseColor\");\n        return this;\n    }\n    Fragment_Custom_Alpha(shaderPart) {\n        this.CustomParts.Fragment_Custom_Alpha = shaderPart.replace(\"result\", \"alpha\");\n        return this;\n    }\n    Fragment_Before_Lights(shaderPart) {\n        this.CustomParts.Fragment_Before_Lights = shaderPart;\n        return this;\n    }\n    Fragment_Before_Fog(shaderPart) {\n        this.CustomParts.Fragment_Before_Fog = shaderPart;\n        return this;\n    }\n    Fragment_Before_FragColor(shaderPart) {\n        this.CustomParts.Fragment_Before_FragColor = shaderPart.replace(\"result\", \"color\");\n        return this;\n    }\n    Vertex_Begin(shaderPart) {\n        this.CustomParts.Vertex_Begin = shaderPart;\n        return this;\n    }\n    Vertex_Definitions(shaderPart) {\n        this.CustomParts.Vertex_Definitions = shaderPart;\n        return this;\n    }\n    Vertex_MainBegin(shaderPart) {\n        this.CustomParts.Vertex_MainBegin = shaderPart;\n        return this;\n    }\n    Vertex_Before_PositionUpdated(shaderPart) {\n        this.CustomParts.Vertex_Before_PositionUpdated = shaderPart.replace(\"result\", \"positionUpdated\");\n        return this;\n    }\n    Vertex_Before_NormalUpdated(shaderPart) {\n        this.CustomParts.Vertex_Before_NormalUpdated = shaderPart.replace(\"result\", \"normalUpdated\");\n        return this;\n    }\n    Vertex_After_WorldPosComputed(shaderPart) {\n        this.CustomParts.Vertex_After_WorldPosComputed = shaderPart;\n        return this;\n    }\n    Vertex_MainEnd(shaderPart) {\n        this.CustomParts.Vertex_MainEnd = shaderPart;\n        return this;\n    }\n}\nCustomMaterial.ShaderIndexer = 1;\nRegisterClass(\"BABYLON.CustomMaterial\", CustomMaterial);\n//# sourceMappingURL=customMaterial.js.map","import { StandardMaterial } from '@babylonjs/core/Materials/standardMaterial'\nimport { Texture } from '@babylonjs/core/Materials/Textures/texture'\nimport { CustomMaterial } from '@babylonjs/materials/custom/customMaterial';\nimport { SerializationHelper } from '@babylonjs/core/Misc/decorators'\nimport { deepCopy } from '../helpers'\n\n// this is a monkey patch for cloning CustomMaterial in BabylonJS\nCustomMaterial.prototype.clone = function (name)  {\n  const th = this\n  const result = SerializationHelper.Clone(() => new CustomMaterial(name, this.getScene()), this)\n\n  result.name = name\n  result.id = name  \n  result.CustomParts.Fragment_Begin = th.CustomParts.Fragment_Begin\n  result.CustomParts.Fragment_Definitions = th.CustomParts.Fragment_Definitions\n  result.CustomParts.Fragment_MainBegin = th.CustomParts.Fragment_MainBegin\n  result.CustomParts.Fragment_Custom_Diffuse = th.CustomParts.Fragment_Custom_Diffuse\n  result.CustomParts.Fragment_Before_Lights = th.CustomParts.Fragment_Before_Lights\n  result.CustomParts.Fragment_Before_Fog = th.CustomParts.Fragment_Before_Fog\n  result.CustomParts.Fragment_Custom_Alpha = th.CustomParts.Fragment_Custom_Alpha\n  result.CustomParts.Fragment_Before_FragColor = th.CustomParts.Fragment_Before_FragColor\n  result.CustomParts.Vertex_Begin = th.CustomParts.Vertex_Begin\n  result.CustomParts.Vertex_Definitions = th.CustomParts.Vertex_Definitions\n  result.CustomParts.Vertex_MainBegin = th.CustomParts.Vertex_MainBegin\n  result.CustomParts.Vertex_Before_PositionUpdated = th.CustomParts.Vertex_Before_PositionUpdated\n  result.CustomParts.Vertex_Before_NormalUpdated = th.CustomParts.Vertex_Before_NormalUpdated\n  result.CustomParts.Vertex_After_WorldPosComputed = th.CustomParts.Vertex_After_WorldPosComputed\n  result.CustomParts.Vertex_MainEnd = th.CustomParts.Vertex_MainEnd \n\n  return result\n}\n\nclass ThemeLoader {\n  loadedThemes = {}\n  themeData = {}\n  constructor(options) {\n    this.scene = options.scene\n  }\n\n  async loadStandardMaterial(options) {\n    const {theme, material: matParams} = options\n    //TODO: apply more matParams\n    const diceMaterial = new StandardMaterial(theme, this.scene);\n\n    // TODO: make these methods reusable getDiffuseTexture(matParams, material)\n    if(matParams.diffuseTexture){\n      diceMaterial.diffuseTexture = await this.getTexture('diffuse', options)\n    }\n    if(matParams.bumpTexture){\n      diceMaterial.bumpTexture = await this.getTexture('bump', options)\n    }\n    if(matParams.specularTexture){\n      diceMaterial.specularTexture = await this.getTexture('specular', options)\n    }\n\n    diceMaterial.allowShaderHotSwapping = false\n\n    // other fun params for the future\n    // diceMaterial.useAlphaFromDiffuseTexture\n    // diceMaterial.useEmissiveAsIllumination\n    // diceMaterial.opacityTexture\n    // diceMaterial.emissiveTexture\n    // diceMaterial.ambientTexture\n    // diceMaterial.reflectionTexture\n    // diceMaterial.refractionTexture\n    // diceMaterial.lightmapTexture\n\n  }\n\n  // this will create two materials - one with light text and one with dark text, the underlying color can be changed by color instance buffers\n  async loadColorMaterial(options) {\n    const {theme, material: matParams} = options\n    // create the custom color material with white/light numbers\n    const diceMatLight = new CustomMaterial(theme+'_light',this.scene)\n    // Other fun params for the future\n    // diceMatLight.useEmissiveAsIllumination = true\n    // diceMatLight.useAlphaFromDiffuseTexture = true\n    // diceMatLight.ambientColor = Color3.White()\n    // diceMatLight.ambientTexture = diceTexture\n    // diceMatLight.emissiveTexture = diceTexture\n    // diceMatLight.opacityTexture = diceTexture\n    const opts = deepCopy(options)\n    if(matParams.diffuseTexture && matParams.diffuseTexture.light){\n      opts.material.diffuseTexture = options.material.diffuseTexture.light\n      diceMatLight.diffuseTexture = await this.getTexture('diffuse', opts)\n    }\n    if(matParams.bumpTexture){\n      diceMatLight.bumpTexture = await this.getTexture('bump', options)\n    }\n    if(matParams.specularTexture){\n      diceMatLight.specularTexture = await this.getTexture('specular', options)\n    }\n  \n    diceMatLight.allowShaderHotSwapping = false\n  \n    // the magic that allows for the material color to be changed on instances\n    diceMatLight.Vertex_Definitions(`\n      attribute vec3 customColor;\n      varying vec3 vColor;\n    `)\n    .Vertex_MainEnd(`\n      vColor = customColor;\n    `)\n    .Fragment_Definitions(`\n      varying vec3 vColor;\n    `)\n    .Fragment_Custom_Diffuse(`\n      baseColor.rgb = mix(vColor.rgb, baseColor.rgb, baseColor.a);\n    `)\n\n    diceMatLight.AddAttribute('customColor')\n  \n    // create the custom color material with black/dark numbers\n    const diceMatDark = diceMatLight.clone(theme+'_dark')\n    if(matParams.diffuseTexture && matParams.diffuseTexture.dark){\n      opts.material.diffuseTexture = options.material.diffuseTexture.dark\n      diceMatDark.diffuseTexture = await this.getTexture('diffuse', opts)\n    }\n    // this must be set again for some reason - does not clone\n    diceMatDark.AddAttribute('customColor')\n  }\n\n  async getTexture(type, options){\n    const {basePath, material: matParams, theme} = options\n    let texture\n    const level = type + 'Level'\n    const textureKey = type + 'Texture'\n    // const power = type + 'Power'\n    try {        \n      switch (type) {\n        case \"diffuse\":\n          texture = await this.importTextureAsync(`${basePath}/${matParams[textureKey]}`, theme)\n          if(matParams[level]) {\n            texture.level = matParams[level]\n          }\n          break;\n        case \"bump\":\n          texture = await this.importTextureAsync(`${basePath}/${matParams[textureKey]}`, theme)\n          if(matParams[level]) {\n            texture.level = matParams[level]\n          }\n          break;\n        case \"specular\":    \n            texture = await this.importTextureAsync(`${basePath}/${matParams[textureKey]}`, theme)\n            if(matParams.specularPower){\n              texture.specularPower = matParams.specularPower\n            }\n          break;\n      \n        default:\n          throw new Error(`Texture type: ${type} is not supported`)\n      }\n    } catch (error) {\n      console.error(error)\n    }\n    return texture\n  }\n\n  async importTextureAsync(url,theme) {\n    return new Promise((resolve, reject) => {\n      let fileName = url.match(/^(.*\\/)(.*)$/)\n      let texture = new Texture(\n          url, // url: Nullable<string>\n          this.scene, // sceneOrEngine: Nullable<Scene | ThinEngine>\n          undefined, // noMipmapOrOptions?: boolean | ITextureCreationOptions\n          true, // invertY?: boolean\n          undefined, // samplingMode?: number\n          () => resolve(texture), // onLoad?: Nullable<() => void>\n          () => reject(`Unable to load texture '${fileName[2]}' for theme: '${theme}'. Check that your assetPath is configured correctly and that the files exist at path: '${fileName[1]}'`) // onError?: Nullable<(message?: string\n        )\n    }).catch(error => console.error(error))\n  }\n\n  async load(options){\n    const { material } = options\n\n    if(material.type === \"color\") {\n      await this.loadColorMaterial(options)\n    } \n    else if (material.type === \"standard\") {\n      await this.loadStandardMaterial(options)\n    } \n    //TODO: more material options\n    // else if (material.type === \"semiTransparent\") {\n    //   await this.loadSemiTransparentMaterial(options)\n    // }\n    else {\n      console.error(`Material type: ${material.type} not supported`)\n    }\n  }\n}\n\n\nexport default ThemeLoader","import { Vector3 } from '@babylonjs/core/Maths/math.vector'\nimport { createEngine } from './world/engine'\nimport { createScene } from './world/scene'\nimport { createCamera } from './world/camera'\nimport { createLights } from './world/lights'\nimport Container from './Container'\nimport Dice from './Dice'\nimport ThemeLoader from './ThemeLoader'\n\nclass WorldOnscreen {\n\tconfig\n\tinitialized = false\n\t#dieCache = {}\n\t#count = 0\n\t#sleeperCount = 0\n\t#dieRollTimer = []\n\t#canvas\n\t#engine\n\t#scene\n\t#camera\n\t#lights\n\t#container\n\t#themeLoader\n\t#physicsWorkerPort\n\t#meshList = {}\n\tnoop = () => {}\n\tdiceBufferView = new Float32Array(8000)\n\n\tconstructor(options){\n\t\tthis.onInitComplete = options.onInitComplete || this.noop\n\t\tthis.onThemeLoaded = options.onThemeLoaded || this.noop\n\t\tthis.onRollResult = options.onRollResult || this.noop\n\t\tthis.onRollComplete = options.onRollComplete || this.noop\n\t\tthis.onDieRemoved = options.onDieRemoved || this.noop\n\t\tthis.initialized = this.initScene(options)\n\t}\n\t\n\t// initialize the babylon scene\n\tasync initScene(config) {\n\t\tthis.#canvas  = config.canvas\n\t\tthis.#canvas.width = config.width\n\t\tthis.#canvas.height = config.height\n\t\n\t\t// set the config from World\n\t\tthis.config = config.options\n\t\n\t\t// setup babylonJS scene\n\t\tthis.#engine  = createEngine(this.#canvas )\n\t\tthis.#scene = createScene({engine:this.#engine })\n\t\tthis.#camera  = createCamera({engine:this.#engine, scene: this.#scene})\n\t\tthis.#lights  = createLights({\n\t\t\tenableShadows: this.config.enableShadows,\n\t\t\tshadowTransparency: this.config.shadowTransparency,\n\t\t\tintensity: this.config.lightIntensity,\n\t\t\tscene: this.#scene\n\t\t})\n\t\n\t\t// create the box that provides surfaces for shadows to render on\n\t\tthis.#container  = new Container({\n\t\t\tenableShadows: this.config.enableShadows,\n\t\t\taspect: this.#canvas.width / this.#canvas.height,\n\t\t\tlights: this.#lights,\n\t\t\tscene: this.#scene\n\t\t})\n\t\t\n\t\tthis.#themeLoader = new ThemeLoader({scene: this.#scene})\n\n\t\t// init complete - let the world know\n\t\tthis.onInitComplete()\n\t}\n\n\tconnect(port){\n\t\tthis.#physicsWorkerPort = port\n\n\t\tthis.#physicsWorkerPort.postMessage({\n\t\t\taction: \"initBuffer\",\n\t\t\tdiceBuffer: this.diceBufferView.buffer\n\t\t}, [this.diceBufferView.buffer])\n\n\t\tthis.#physicsWorkerPort.onmessage = (e) => {\n\t\t\tswitch (e.data.action) {\n\t\t\t\tcase \"updates\": // dice status/position updates from physics worker\n\t\t\t\t\tthis.updatesFromPhysics(e.data.diceBuffer)\n\t\t\t\t\tbreak;\n\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.error(\"action from physicsWorker not found in offscreen worker\")\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateConfig(options){\n\t\tconst prevConfig = this.config\n\t\tthis.config = options\n\t\t// check if shadows setting has changed\n\t\tif(prevConfig.enableShadows !== this.config.enableShadows) {\n\t\t\t// regenerate the lights\n\t\t\tObject.values(this.#lights ).forEach(light => light.dispose())\n\t\t\tthis.#lights = createLights(\n\t\t\t\t{\n\t\t\t\t\tenableShadows: this.config.enableShadows,\n\t\t\t\t\tshadowTransparency: this.config.shadowTransparency,\n\t\t\t\t\tintensity: this.config.lightIntensity,\n\t\t\t\t\tscene: this.#scene\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t\tif(prevConfig.scale !== this.config.scale) {\n\t\t\tObject.values(this.#dieCache).forEach(({mesh}) => {\n\t\t\t\tif(mesh){\n\t\t\t\t\tconst {x = 1,y = 1,z = 1} = mesh?.metadata?.baseScale\n\t\t\t\t\tmesh.scaling = new Vector3(\n\t\t\t\t\t\tthis.config.scale * x,\n\t\t\t\t\t\tthis.config.scale * y,\n\t\t\t\t\t\tthis.config.scale * z\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\tif(prevConfig.shadowTransparency !== this.config.shadowTransparency) {\n\t\t\tthis.#lights.directional.shadowGenerator.darkness = this.config.shadowTransparency\n\t\t}\n\t\tif(prevConfig.lightIntensity !== this.config.lightIntensity) {\n\t\t\tthis.#lights.directional.intensity = .65 * this.config.lightIntensity\n\t\t\tthis.#lights.hemispheric.intensity = .4 * this.config.lightIntensity\n\t\t}\n\t}\n\n\t// all this does is start the render engine.\n\trender(newStartPoint) {\n\t\t// document.body.addEventListener('click',()=>engine.stopRenderLoop())\n\t\tthis.#engine.runRenderLoop(this.renderLoop.bind(this))\n\t\tthis.#physicsWorkerPort.postMessage({\n\t\t\taction: \"resumeSimulation\",\n\t\t\tnewStartPoint\n\t\t})\n\t}\n\n\trenderLoop() {\n\t\t// if no dice are awake then stop the render loop and save some CPU power\n\t\tif(this.#sleeperCount && this.#sleeperCount === Object.keys(this.#dieCache).length) {\n\t\t\t// console.log(`no dice moving`)\n\t\t\tthis.#engine.stopRenderLoop()\n\n\t\t\t// stop the physics engine\n\t\t\tthis.#physicsWorkerPort.postMessage({\n\t\t\t\taction: \"stopSimulation\",\n\t\t\t})\n\n\t\t\t// trigger callback that roll is complete\n\t\t\tthis.onRollComplete()\n\t\t}\n\t\t// otherwise keep on rendering\n\t\telse {\n\t\t\tthis.#scene.render() // not the same as this.render()\n\t\t}\n\t}\n\n\tasync loadTheme(options) {\n\t\t// await loadTheme(theme, this.config.origin + this.config.assetPath, this.#scene)\n\t\tconst {theme, basePath, material, meshFilePath, meshName} = options\n\t\t// load the textures and create the materials needed for this theme\n\t\tawait this.#themeLoader.load({theme,basePath,material})\n\t\n\t\t// Load the 3D meshes declared by the theme and return the collider mesh data to be passed on to the physics worker\n\t\t// don't load same models twice\n\t\tif(!Object.keys(this.#meshList).includes(meshName)){\n\t\t\tthis.#meshList[meshName] = meshFilePath\n\t\t\tconst colliders = await Dice.loadModels({meshFilePath,meshName}, this.#scene)\n\n\t\t\tif(!colliders){\n\t\t\t\tthrow new Error(\"No colliders returned from the 3D mesh file. Low poly colliders are expected to be in the same file as the high poly dice and the mesh name contains the word 'collider'\")\n\t\t\t}\n\t\t\n\t\t\tthis.#physicsWorkerPort.postMessage({\n\t\t\t\taction: \"loadModels\",\n\t\t\t\toptions: {\n\t\t\t\t\tcolliders,\n\t\t\t\t\tmeshName\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tthis.onThemeLoaded({id: theme})\n\t}\n\n\tclear() {\n\t\tif(!Object.keys(this.#dieCache).length && !this.#sleeperCount) {\n\t\t\treturn\n\t\t}\n\t\tif(this.diceBufferView.byteLength){\n\t\t\tthis.diceBufferView.fill(0)\n\t\t}\n\t\tthis.#dieRollTimer.forEach(timer=>clearTimeout(timer))\n\t\t// stop anything that's currently rendering\n\t\tthis.#engine.stopRenderLoop()\n\t\t// remove all dice\n\t\tObject.values(this.#dieCache).forEach(die => {\n\t\t\tif(die.mesh)\n\t\t\t\tdie.mesh.dispose()\n\t\t})\n\t\t\n\t\t// reset storage\n\t\tthis.#dieCache = {}\n\t\tthis.#count = 0\n\t\tthis.#sleeperCount = 0\n\n\t\t// step the animation forward\n\t\tthis.#scene.render()\n\t}\n\n\tadd(options) {\n\t\t// loadDie allows you to specify sides(dieType) and theme and returns the options you passed in\n\t\tDice.loadDie(options, this.#scene).then(resp => {\n\t\t\t// space out adding the dice so they don't lump together too much\n\t\t\tthis.#dieRollTimer.push(setTimeout(() => {\n\t\t\t\tthis.#add(resp)\n\t\t\t}, this.#count++ * this.config.delay))\n\t\t})\n\t}\n\n\taddNonDie(die){\n\t\tif(this.#engine.activeRenderLoops.length === 0) {\n\t\t\tthis.render(false)\n\t\t}\n\t\tconst {id, value, ...rest} = die\n\t\tconst newDie = {\n\t\t\tid,\n\t\t\tvalue,\n\t\t\tconfig: rest\n\t\t}\n\t\tthis.#dieCache[id] = newDie\n\t\t\n\t\t// double timeout to ensure any real dice have a chance to queue up and rollResults isn't triggered right away\n\t\tsetTimeout(()=>{\n\t\t\tthis.#dieRollTimer.push(setTimeout(() => {\n\t\t\t\tthis.handleAsleep(newDie)\n\t\t\t}, this.#count++ * this.config.delay))\n\t\t}, 10)\n\t}\n\n\t// add a die to the scene\n\tasync #add(options) {\n\t\tif(this.#engine.activeRenderLoops.length === 0) {\n\t\t\tthis.render(options.newStartPoint)\n\t\t}\n\t\tconst diceOptions = {\n\t\t\t...options,\n\t\t\tassetPath: this.config.assetPath,\n\t\t\tenableShadows: this.config.enableShadows,\n\t\t\tscale: this.config.scale,\n\t\t\tlights: this.#lights,\n\t\t}\n\t\t\n\t\tconst newDie = new Dice(diceOptions, this.#scene)\n\t\t\n\t\t// save the die just created to the cache\n\t\tthis.#dieCache[newDie.id] = newDie\n\t\t\n\t\t// tell the physics engine to roll this die type - which is a low poly collider\n\t\tthis.#physicsWorkerPort.postMessage({\n\t\t\taction: \"addDie\",\n\t\t\toptions: {\n\t\t\t\tsides: options.sides,\n\t\t\t\tscale: this.config.scale,\n\t\t\t\tid: newDie.id,\n\t\t\t\tnewStartPoint: options.newStartPoint,\n\t\t\t\ttheme: options.theme,\n\t\t\t\tmeshName: options.meshName,\n\t\t\t}\n\t\t})\n\t\n\t\t// for d100's we need to add an additional d10 and pair it up with the d100 just created\n\t\tif(options.sides === 100 && options.data !== 'single') {\n\t\t\t// assign the new die to a property on the d100 - spread the options in order to pass a matching theme\n\t\t\tnewDie.d10Instance = await Dice.loadDie({...diceOptions, dieType: 'd10', sides: 10, id: newDie.id + 10000}, this.#scene).then( response =>  {\n\t\t\t\tconst d10Instance = new Dice(response, this.#scene)\n\t\t\t\t// identify the parent of this d10 so we can calculate the roll result later\n\t\t\t\td10Instance.dieParent = newDie\n\t\t\t\treturn d10Instance\n\t\t\t})\n\t\t\t// add the d10 to the cache and ask the physics worker for a collider\n\t\t\tthis.#dieCache[`${newDie.d10Instance.id}`] = newDie.d10Instance\n\t\t\tthis.#physicsWorkerPort.postMessage({\n\t\t\t\taction: \"addDie\",\n\t\t\t\toptions: {\n\t\t\t\t\tsides: 10,\n\t\t\t\t\tscale: this.config.scale,\n\t\t\t\t\tid: newDie.d10Instance.id,\n\t\t\t\t\ttheme: options.theme,\n\t\t\t\t\tmeshName: options.meshName\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\n\t\t// return the die instance\n\t\treturn newDie\n\t\n\t}\n\t\n\tremove(data) {\n\t// TODO: test this with exploding dice\n\tconst dieData = this.#dieCache[data.id]\n\t\n\t// check if this is d100 and remove associated d10 first\n\tif(dieData.hasOwnProperty('d10Instance')){\n\t\t// remove die\n\t\tif(this.#dieCache[dieData.d10Instance.id].mesh){\n\t\t\tthis.#dieCache[dieData.d10Instance.id].mesh.dispose()\n\n\t\t\t// remove d10 physics body just for d100 items\n\t\t\tthis.#physicsWorkerPort.postMessage({\n\t\t\t\taction: \"removeDie\",\n\t\t\t\tid: dieData.d10Instance.id\n\t\t\t})\n\t\t}\n\t\t// delete entry\n\t\tdelete this.#dieCache[dieData.d10Instance.id]\n\t\t// decrement count\n\t\tthis.#sleeperCount--\n\t}\n\n\t// remove die\n\tif(this.#dieCache[data.id].mesh){\n\t\tthis.#dieCache[data.id].mesh.dispose()\n\t}\n\t// delete entry\n\tdelete this.#dieCache[data.id]\n\t// decrement count\n\tthis.#sleeperCount--\n\n\t// step the animation forward\n\tthis.#scene.render()\n\n\tthis.onDieRemoved(data.rollId)\n}\n\t\n\tupdatesFromPhysics(buffer) {\n\t\tthis.diceBufferView = new Float32Array(buffer)\n\t\tlet bufferIndex = 1\n\n\t\t// loop will be based on diceBufferView[0] value which is the bodies length in physics.worker\n\tfor (let i = 0, len = this.diceBufferView[0]; i < len; i++) {\n\t\tif(!Object.keys(this.#dieCache).length){\n\t\t\tcontinue\n\t\t}\n\t\tconst die = this.#dieCache[`${this.diceBufferView[bufferIndex]}`]\n\t\tif(!die) {\n\t\t\tconsole.log(\"Error: die not available in scene to animate\")\n\t\t\tbreak\n\t\t}\n\t\t// if the first position index is -1 then this die has been flagged as asleep\n\t\tif(this.diceBufferView[bufferIndex + 1] === -1) {\n\t\t\tthis.handleAsleep(die)\n\t\t} else {\n\t\t\tconst px = this.diceBufferView[bufferIndex + 1]\n\t\t\tconst py = this.diceBufferView[bufferIndex + 2]\n\t\t\tconst pz = this.diceBufferView[bufferIndex + 3]\n\t\t\tconst qx = this.diceBufferView[bufferIndex + 4]\n\t\t\tconst qy = this.diceBufferView[bufferIndex + 5]\n\t\t\tconst qz = this.diceBufferView[bufferIndex + 6]\n\t\t\tconst qw = this.diceBufferView[bufferIndex + 7]\n\n\t\t\tdie.mesh.position.set(px, py, pz)\n\t\t\tdie.mesh.rotationQuaternion.set(qx, qy, qz, qw)\n\t\t}\n\n\t\tbufferIndex = bufferIndex + 8\n\t}\n\n\t// transfer the buffer back to physics worker\n\trequestAnimationFrame(()=>{\n\t\tthis.#physicsWorkerPort.postMessage({\n\t\t\taction: \"stepSimulation\",\n\t\t\tdiceBuffer: this.diceBufferView.buffer\n\t\t}, [this.diceBufferView.buffer])\n\t})\n\t}\n\t\n\t// handle the position updates from the physics worker. It's a simple flat array of numbers for quick and easy transfer\n\tasync handleAsleep(die){\n\t\t// mark this die as asleep\n\t\tdie.asleep = true\n\t\n\t\t// get the roll result for this die\n\t\tawait Dice.getRollResult(die, this.#scene)\n\t\n\t\tif(die.d10Instance || die.dieParent) {\n\t\t\t// if one of the pair is asleep and the other isn't then it falls through without getting the roll result\n\t\t\t// otherwise both dice in the d100 are asleep and ready to calc their roll result\n\t\t\tif(die?.d10Instance?.asleep || die?.dieParent?.asleep) {\n\t\t\t\tconst d100 = die.config.sides === 100 ? die : die.dieParent\n\t\t\t\tconst d10 = die.config.sides === 10 ? die : die.d10Instance\n\t\t\t\tif(d100.rawValue){\n\t\t\t\t\t// this die is being processed again for some reason, probably a physics ineration that woke it before it was immobilized\n\t\t\t\t\td100.value = d100.rawValue\n\t\t\t\t}\n\t\t\t\t// save the original value\n\t\t\t\td100.rawValue = d100.value\n\n\t\t\t\td100.value = d100.value + d10.value\n\t\n\t\t\t\tthis.onRollResult({\n\t\t\t\t\trollId: d100.config.rollId,\n\t\t\t\t\tvalue : d100.value\n\t\t\t\t})\n\t\t\t}\n\t\t} else {\n\t\t\t// turn 0's on a d10 into a 10\n\t\t\tif(die.config.sides === 10 && die.value === 0) {\n\t\t\t\tdie.value = 10\n\t\t\t}\n\t\t\tthis.onRollResult({\n\t\t\t\trollId: die.config.rollId,\n\t\t\t\tvalue: die.value\n\t\t\t})\n\t\t}\n\t\t// add to the sleeper count\n\t\tthis.#sleeperCount++\n\t}\n\t\n\tresize(options) {\n\t\t// redraw the dicebox\n\t\tconst width = this.#canvas.width = options.width\n\t\tconst height = this.#canvas.height = options.height\n\t\tthis.#container.create({aspect: width / height})\n\t\tthis.#engine.resize()\n\t}\n}\n\nexport default WorldOnscreen","import { Engine } from '@babylonjs/core/Engines/engine'\n\nfunction createEngine(canvas) {\n  const engine = new Engine(canvas, true, {\n    preserveDrawingBuffer: true,\n    stencil: true,\n  })\n\n  return engine\n}\n\nexport { createEngine }","import { Color4 } from '@babylonjs/core/Maths/math.color'\nimport { Scene } from '@babylonjs/core/scene'\nimport { SceneOptimizer, SceneOptimizerOptions } from '@babylonjs/core/Misc/sceneOptimizer'\n\nfunction createScene(options) {\n  const { engine } = options\n  const scene = new Scene(engine)\n\n  // scene.useRightHandedSystem = true\n  scene.clearColor = new Color4(0,0,0,0);\n\n  scene.pointerMovePredicate = () => false;\n  scene.pointerDownPredicate = () => false;\n  scene.pointerUpPredicate = () => false;\n  scene.clearCachedVertexData();\n  // used to map 3D mesh faces to actual dice values\n  scene.themeData = {}\n\n  const optimizationSettings = SceneOptimizerOptions.LowDegradationAllowed()\n  optimizationSettings.optimizations = optimizationSettings.optimizations.splice(1)\n  optimizationSettings.targetFrameRate = 60\n\n  SceneOptimizer.OptimizeAsync(scene,optimizationSettings)\n\n  return scene\n}\n\nexport { createScene }","import { Vector3 } from '@babylonjs/core/Maths/math.vector'\nimport { TargetCamera } from '@babylonjs/core/Cameras/targetCamera'\n\n// this module has dynamically loaded modules so it's been made async\nfunction createCamera(options) {\n  const { scene } = options\n  let camera\n  const cameraDistance = 36.5\n\n\tcamera = new TargetCamera(\"TargetCamera1\", new Vector3(0, cameraDistance, 0), scene)\n\tcamera.fov = .25\n\tcamera.minZ = 5\n\tcamera.maxZ = cameraDistance + 1\n  camera.setTarget(Vector3.Zero())\n  return camera\n}\n\nexport { createCamera }"],"names":["Lt","constructor","e","this","_keys","_isDirty","_areLightsDirty","_areLightsDisposed","_areAttributesDirty","_areTexturesDirty","_areFresnelDirty","_areMiscDirty","_arePrePassDirty","_areImageProcessingDirty","_normals","_uvs","_needNormals","_needUVs","_externalProperties","t","Object","prototype","hasOwnProperty","call","_setDefaultValue","isDirty","markAsProcessed","markAsUnprocessed","markAllAsDirty","markAsImageProcessingDirty","markAsLightDirty","arguments","length","undefined","markAsAttributesDirty","markAsTexturesDirty","markAsFresnelDirty","markAsMiscDirty","markAsPrePassDirty","rebuild","keys","push","indexOf","isEqual","i","cloneTo","slice","reset","forEach","r","s","n","a","type","o","default","toString","Te","getDescription","apply","priority","vt","maximumSize","super","step","textures","canRescale","getContext","getSize","Math","max","width","height","scale","Ut","_currentScale","maximumScale","_directionOffset","getEngine","getHardwareScalingLevel","setHardwareScalingLevel","Et","shadowsEnabled","isInImprovementMode","St","postProcessesEnabled","Tt","lensFlaresEnabled","gi","onGetDescription","onApply","xt","particlesEnabled","Bt","renderTargetsEnabled","Ae","_canBeMerged","Ye","isDisposed","isVisible","isEnabled","instances","skeleton","hasLODLevels","getTotalVertices","UpdateSelectionTree","_UpdateSelectionTree","meshes","Array","l","d","h","material","checkCollisions","splice","MergeMeshes","createOrUpdateSelectionOctree","be","targetFrameRate","trackerDuration","optimizations","addOptimization","addCustomOptimization","LowDegradationAllowed","ModerateDegradationAllowed","HighDegradationAllowed","Ft","_improvementMode","currentPriorityLevel","_currentPriorityLevel","currentFrameRate","_currentFrameRate","_targetFrameRate","_trackerDuration","_options","_isRunning","onSuccessObservable","Y","onNewOptimizationAppliedObservable","onFailureObservable","_scene","bt","LastCreatedScene","_sceneDisposeObserver","onDisposeObservable","add","dispose","stop","start","executeWhenReady","setTimeout","_checkCurrentState","round","getFps","notifyObservers","clear","remove","OptimizeAsync","j","se","_tmpUpVector","M","Zero","_tmpTargetVector","cameraDirection","cameraRotation","$e","ignoreParentScaling","updateUpVectorFromRotation","_tmpQuaternion","Ie","rotation","speed","noRotationConstraint","invertRotation","inverseRotationSpeed","lockedTarget","_currentTarget","_initialFocalDistance","_viewMatrix","F","_camMatrix","_cameraTransformMatrix","_cameraRotationMatrix","_referencePoint","_transformedReferencePoint","_defaultUp","Up","_cachedRotationZ","_cachedQuaternionRotationZ","getFrontPosition","getWorldMatrix","getTarget","subtract","position","normalize","scaleInPlace","globalPosition","_getLockedTargetPosition","absolutePosition","computeWorldMatrix","getTranslationToRef","storeState","_storedPosition","clone","_storedRotation","rotationQuaternion","_storedRotationQuaternion","_restoreStateValues","copyFromFloats","_initCache","_cache","Number","MAX_VALUE","_updateCache","copyFrom","_isSynchronizedViewMatrix","equals","_computeLocalCameraSpeed","sqrt","getDeltaTime","setTarget","upVector","z","we","LookAtLHToRef","invert","x","atan","m","y","PI","isNaN","RotationYawPitchRollToRef","target","_decideIfNeedsToMove","abs","_updatePosition","parent","invertToRef","le","Matrix","TransformNormalToRef","Vector3","addInPlace","_checkInputs","toEulerAnglesToRef","lengthSquared","inertia","_updateCameraRotationMatrix","toRotationMatrix","_rotateUpVectorWithCameraRotationMatrix","_getViewMatrix","TransformCoordinatesToRef","addToRef","Ct","rotateByQuaternionToRef","FromEulerVectorToRef","_computeViewMatrix","_globalPosition","_markSyncedWithParent","getScene","useRightHandedSystem","LookAtRHToRef","multiplyToRef","createRigCamera","cameraRigMode","RIG_MODE_NONE","isRigCamera","rigParent","RIG_MODE_VR","RIG_MODE_WEBVR","_cameraRigParams","mode","orthoLeft","orthoRight","orthoTop","orthoBottom","_updateRigCameras","_rigCameras","RIG_MODE_STEREOSCOPIC_ANAGLYPH","RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL","RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED","RIG_MODE_STEREOSCOPIC_OVERUNDER","RIG_MODE_STEREOSCOPIC_INTERLACED","_getRigCamPositionAndTarget","stereoHalfAngle","subtractToRef","_TargetFocalPoint","TranslationToRef","_TargetTransformMatrix","RotationAxis","_RigCamTransformMatrix","getClassName","u","ht","S","ei","D","He","range","_range","_inverseSquaredRange","intensityMode","_intensityMode","_computePhotometricScale","radius","_radius","shadowEnabled","_shadowEnabled","_markMeshesAsLightDirty","includedOnlyMeshes","_includedOnlyMeshes","_hookArrayForIncludedOnly","excludedMeshes","_excludedMeshes","_hookArrayForExcluded","excludeWithLayerMask","_excludeWithLayerMask","_resyncMeshes","includeOnlyWithLayerMask","_includeOnlyWithLayerMask","lightmapMode","_lightmapMode","diffuse","he","specular","falloffType","FALLOFF_DEFAULT","intensity","_photometricScale","INTENSITYMODE_AUTOMATIC","renderPriority","_shadowGenerators","_excludedMeshesIds","_includedOnlyMeshesIds","_isLight","addLight","_uniformBuffer","ti","_buildUniformLayout","transferTexturesToEffect","_bindLight","bindToEffect","_renderId","getRenderId","_lastUseSpecular","useUbo","getScaledIntensity","transferToEffect","scaleToRef","tt","Color3","updateColor4","getShadowGenerator","activeCamera","bindShadowLight","update","bindUniformBuffer","name","getTypeID","animations","_syncParentEnabledState","setEnabled","get","getShadowGenerators","getAbsolutePosition","canAffectMesh","layerMask","values","next","done","value","stopAnimation","_parentContainer","lights","_removeLightSource","removeLight","GetConstructorFromName","Q","Clone","onClonedObservable","serialize","Serialize","uniqueId","_serializeAsParent","excludedMeshesIds","id","includedOnlyMeshesIds","AppendSerializedAnimations","ranges","serializeAnimationRanges","Construct","Parse","parentId","_waitingParentId","parentInstanceIndex","_waitingParentInstanceIndex","Pt","ParseAnimationRanges","autoAnimate","beginAnimation","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","_this","_len","_key","_resyncLightSource","_this2","_len2","_key2","lightSources","_markSubMeshesAsLightDirty","_getPhotometricScale","resetCachedMaterial","LIGHTTYPEID_DIRECTIONALLIGHT","INTENSITYMODE_ILLUMINANCE","INTENSITYMODE_LUMINOUSINTENSITY","LIGHTTYPEID_POINTLIGHT","LIGHTTYPEID_SPOTLIGHT","INTENSITYMODE_LUMINOUSPOWER","INTENSITYMODE_LUMINANCE","cos","LIGHTTYPEID_HEMISPHERICLIGHT","_reorderLightsInScene","_renderPriority","requireLightSorting","sortLightsByPriority","ee","FALLOFF_PHYSICAL","FALLOFF_GLTF","FALLOFF_STANDARD","LIGHTMAP_DEFAULT","LIGHTMAP_SPECULAR","LIGHTMAP_SHADOWSONLY","Pe","U","et","_needProjectionMatrixCompute","_setPosition","_position","_setDirection","_direction","direction","shadowMinZ","_shadowMinZ","forceProjectionMatrixCompute","shadowMaxZ","_shadowMaxZ","computeTransformedInformation","transformedPosition","transformedDirection","getDepthScale","getShadowDirection","setDirectionToTarget","Normalize","getRotation","Cross","RotationFromAxis","needCube","needProjectionMatrixCompute","_isSynchronized","isSynchronized","_currentRenderId","_worldMatrix","Identity","_worldMatrixDeterminantIsDirty","getDepthMinZ","minZ","getDepthMaxZ","maxZ","setShadowProjectionMatrix","customProjectionMatrixBuilder","_setDefaultShadowProjectionMatrix","AddNodeConstructor","f","_e","shadowFrustumSize","_shadowFrustumSize","shadowOrthoScale","_shadowOrthoScale","_orthoLeft","_orthoRight","_orthoTop","_orthoBottom","autoUpdateExtends","autoCalcShadowZBounds","MIN_VALUE","_setDefaultFixedFrustumShadowProjectionMatrix","_setDefaultAutoExtendShadowProjectionMatrix","OrthoLHToRef","isNDCHalfZRange","c","p","E","getBoundingInfo","boundingBox","T","vectorsWorld","useReverseDepthBuffer","OrthoOffCenterLHToRef","addUniform","create","updateFloat4","transferToNodeMaterialEffect","setFloat3","prepareLightSpecificDefines","ct","groundColor","updateColor3","Se","getHashCode","set","multiplyByFloats","surface","Lerp","wt","wrapU","_wrapU","wrapV","_wrapV","coordinatesMode","isCube","_texture","is3D","is2DArray","_IsRenderTargetWrapper","_shareDepth","wrapR","anisotropicFilteringLevel","delayLoadState","_engine","_cachedSize","_cachedBaseSize","_initialSamplingMode","texture","isReady","delayLoad","getInternalTexture","_size","getBaseSize","baseWidth","baseHeight","samplingMode","updateSamplingMode","updateTextureSamplingMode","releaseInternalTexture","hasAlpha","_hasAlpha","markAllMaterialsAsDirty","hasTexture","getAlphaFromRGB","_getAlphaFromRGB","coordinatesIndex","_coordinatesIndex","_coordinatesMode","_isCube","gammaSpace","_gammaSpace","_useSRGBBuffer","_markAllSubMeshesAsTexturesDirty","isRGBD","_isRGBD","noMipmap","lodGenerationOffset","_lodGenerationOffset","lodGenerationScale","_lodGenerationScale","linearSpecularLOD","_linearSpecularLOD","irradianceTexture","_irradianceTexture","uid","_uid","ii","onDispose","_onDisposeObserver","isBlocking","loadingError","_loadingError","errorObject","_errorObject","metadata","reservedDataStore","level","optimizeUVAllocation","DEFAULT_ANISOTROPIC_FILTERING_LEVEL","invertZ","lodLevelInAlpha","isRenderTarget","_prefiltered","_forceSerialize","_IsScene","getUniqueId","addTexture","_getEngine","checkTransformsAreIdentical","getTextureMatrix","IdentityReadOnly","getReflectionTextureMatrix","isReadyOrNotBlocking","_getFromCache","_getUseSRGBBuffer","getLoadedTexturesCache","invertY","url","generateMipMaps","incrementReferences","_rebuild","textureType","textureFormat","format","readPixels","pow","min","_readTexturePixels","_readPixelsSync","_readTexturePixelsSync","_lodTextureHigh","_lodTextureMid","_lodTextureLow","removePendingData","onTextureRemovedObservable","WhenAllReady","onLoadObservable","addOnce","Yt","Float32Array","byteLength","BYTES_PER_ELEMENT","Uint8Array","document","createElement","createImageData","data","putImageData","translate","drawImage","toDataURL","ue","v","_noMipmap","mimeType","_mimeType","_isBlocking","_invertY","TRILINEAR_SAMPLINGMODE","_","I","b","P","X","k","R","uOffset","vOffset","uScale","vScale","uAng","vAng","wAng","uRotationCenter","vRotationCenter","wRotationCenter","homogeneousRotationInUVTransform","inspectableCustomProperties","_rowGenerationMatrix","_cachedTextureMatrix","_projectionModeMatrix","_t0","_t1","_t2","_cachedUOffset","_cachedVOffset","_cachedUScale","_cachedVScale","_cachedUAng","_cachedVAng","_cachedWAng","_cachedReflectionProjectionMatrixId","_cachedURotationCenter","_cachedVRotationCenter","_cachedWRotationCenter","_cachedHomogeneousRotationInUVTransform","_cachedReflectionTextureMatrix","_cachedReflectionUOffset","_cachedReflectionVOffset","_cachedReflectionUScale","_cachedReflectionVScale","_cachedReflectionCoordinatesMode","_buffer","_deleteBuffer","_format","_delayedOnLoad","_delayedOnError","O","N","Ue","UseOpenGLOrientationForUV","onLoad","onError","buffer","deleteBuffer","loaderOptions","creationFlags","useSRGBBuffer","internalTexture","_loaderOptions","_creationFlags","_forcedExtension","ge","H","onBeforeTextureInitObservable","re","load","_invertVScale","_cachedWrapU","_cachedWrapV","_cachedWrapR","hasObservers","de","errorHandler","q","pe","message","exception","OnTextureLoadErrorObservable","yt","SetImmediate","onLoadedObservable","onErrorObservable","mt","useDelayedTextureLoading","createTexture","updateURL","startsWith","_prepareRowForTextureGeneration","TransformCoordinatesFromFloatsToRef","ScalingToRef","setRowFromFloats","subtractInPlace","FromValuesToRef","PROJECTION_MODE","getProjectionMatrix","updateFlag","PLANAR_MODE","IdentityToRef","getActiveTextures","SerializeBuffers","_SerializeInternalTextureUniqueId","ForceSerializeBuffers","substr","base64String","replace","ri","_features","supportSyncTextureRead","Si","async","Ti","internalTextureUniqueId","customType","si","Instantiate","_samplingMode","_CubeTextureParser","_setUniqueId","mirrorPlane","_CreateMirror","renderTargetSize","_waitingRenderList","renderList","ni","FromArray","reflectionProbes","cubeTexture","_CreateRenderTargetTexture","CreateFromBase64String","UseSerializedUrlIfAny","LoadFromDataString","ze","NEAREST_SAMPLINGMODE","NEAREST_NEAREST_MIPLINEAR","BILINEAR_SAMPLINGMODE","LINEAR_LINEAR_MIPNEAREST","LINEAR_LINEAR_MIPLINEAR","NEAREST_NEAREST_MIPNEAREST","NEAREST_LINEAR_MIPNEAREST","NEAREST_LINEAR_MIPLINEAR","NEAREST_LINEAR","NEAREST_NEAREST","LINEAR_NEAREST_MIPNEAREST","LINEAR_NEAREST_MIPLINEAR","LINEAR_LINEAR","LINEAR_NEAREST","EXPLICIT_MODE","SPHERICAL_MODE","CUBIC_MODE","SKYBOX_MODE","INVCUBIC_MODE","EQUIRECTANGULAR_MODE","FIXED_EQUIRECTANGULAR_MODE","FIXED_EQUIRECTANGULAR_MIRRORED_MODE","CLAMP_ADDRESSMODE","WRAP_ADDRESSMODE","MIRROR_ADDRESSMODE","We","_TextureParser","xi","depthStencilTexture","_depthStencilTexture","depthStencilTextureWithStencil","_depthStencilTextureWithStencil","isMulti","_isMulti","layers","size","_textures","faceIndices","_faceIndices","layerIndices","_layerIndices","samples","_samples","setSamples","updateMultipleRenderTargetTextureSampleCount","updateRenderTargetTextureSampleCount","_attachments","_generateStencilBuffer","_generateDepthBuffer","setTextures","isArray","setTexture","setLayerAndFaceIndices","setLayerAndFaceIndex","createDepthStencilTexture","bilinearFiltering","comparisonFunction","generateStencil","depthTextureFormat","label","_swapAndDie","_cloneRenderTargetWrapper","_source","Ze","Depth","DepthStencil","depth","samplingModes","generateDepthBuffer","generateStencilBuffer","generateDepthTexture","types","formats","textureCount","targetTypes","faceIndex","layerIndex","layerCounts","createMultipleRenderTarget","createRenderTargetCubeTexture","createRenderTargetTexture","_swapRenderTargetWrapper","_comparisonFunction","releaseTextures","_releaseRenderTargetWrapper","Mi","_framebuffer","_depthStencilBuffer","_MSAAFramebuffer","_colorTextureArray","_depthStencilTextureArray","_context","createMultiviewRenderTargetTexture","deleteRenderbuffer","_bindUnboundFramebuffer","framebufferRenderbuffer","FRAMEBUFFER","DEPTH_ATTACHMENT","RENDERBUFFER","_bindTextureRenderTarget","_hardwareTexture","_currentFramebuffer","webGLVersion","framebufferTextureLayer","underlyingResource","framebufferTexture2D","TEXTURE_CUBE_MAP_POSITIVE_X","TEXTURE_2D","deleteTexture","deleteFramebuffer","De","_createHardwareRenderTargetWrapper","_gl","_renderTargetWrapperCache","noColorAttachment","colorAttachment","_createInternalTexture","RenderTarget","createFramebuffer","_setupFramebufferDepthAttachments","COLOR_ATTACHMENT0","_createDepthStencilCubeTexture","_createDepthStencilTexture","TEXTURE_2D_ARRAY","kt","_caps","depthTextureExtension","rt","Error","_bindTextureDirectly","_setupDepthStencilTexture","UNSIGNED_INT","UNSIGNED_SHORT","UNSIGNED_INT_24_8","FLOAT","FLOAT_32_UNSIGNED_INT_24_8_REV","DEPTH_STENCIL","DEPTH_COMPONENT","DEPTH_COMPONENT16","DEPTH_COMPONENT24","DEPTH24_STENCIL8","DEPTH_COMPONENT32F","DEPTH32F_STENCIL8","texImage3D","texImage2D","_internalTexturesCache","DEPTH_STENCIL_ATTACHMENT","STENCIL_ATTACHMENT","getCaps","maxMSAASamples","releaseMSAARenderBuffers","renderbufferStorageMultisample","_createRenderBuffer","_getRGBAMultiSampleBufferFormat","addMSAARenderBuffer","textureFloatLinearFiltering","textureHalfFloatLinearFiltering","TEXTURE_CUBE_MAP","_getSamplingParameters","textureFloat","Warn","texParameteri","TEXTURE_MAG_FILTER","mag","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","_getRGBABufferInternalSizedFormat","_getInternalFormat","_getWebGLTextureType","generateMipmap","ShadersStore","Mt","positions","indices","Ri","_fullscreenViewport","ai","engine","_vertexBuffers","B","PositionKind","_indexBuffer","createIndexBuffer","_onContextRestoredObserver","onContextRestoredObservable","setViewport","bindBuffers","applyEffectWrapper","setState","depthCullingState","depthTest","stencilState","stencilTest","enableEffect","_drawWrapper","effect","onApplyObservable","restoreStates","draw","drawElementsType","_isRenderTargetTexture","renderTarget","render","bindFramebuffer","unBindFramebuffer","_releaseBuffer","Ii","uniformNames","vertexShader","fragmentSource","fragmentShader","vertexSource","spectorName","vertex","setFloat2","defines","join","Dt","useShaderStore","fragment","createEffect","attributeNames","samplerNames","onCompiled","shaderLanguage","ve","_pipelineContext","_wasPreviouslyReady","_prepareEffect","Zt","$t","Vt","shader","J","_CreateDumpRenderer","_DumpToolsEngine","preserveDrawingBuffer","stencil","alpha","premultipliedAlpha","antialias","failIfMajorPerformanceCaveat","parallelShaderCompile","canvas","renderer","wrapper","DumpFramebuffer","DumpData","DumpDataAsync","Promise","setSize","createRawTexture","_bindTexture","Ge","ToBlob","FileReader","onload","result","readAsArrayBuffer","EncodeScreenshotCanvasData","Dispose","ae","_renderList","_unObserveRenderList","oi","_renderListHasChanged","postProcesses","_postProcesses","_prePassEnabled","_prePassRenderTarget","enabled","onAfterUnbind","_onAfterUnbindObserver","onAfterUnbindObservable","onBeforeRender","_onBeforeRenderObserver","onBeforeRenderObservable","onAfterRender","_onAfterRenderObserver","onAfterRenderObservable","onClear","_onClearObserver","onClearObservable","renderPassIds","_renderPassIds","currentRefreshId","_currentRefreshId","setMaterialForRendering","setMaterialForRenderPass","_renderTarget","renderTargetOptions","_renderTargetOptions","_onRatioRescale","_sizeRatio","resize","_initialSizeParameter","boundingBoxSize","_boundingBoxSize","doNotChangeAspectRatio","delayAllocation","renderParticles","renderSprites","forceLayerMaskCheck","ignoreCameraViewport","onBeforeBindObservable","onResizeObservable","_cleared","skipInitialClear","_refreshRate","_canRescale","boundingBoxPosition","_isCubeData","_processSizeParameter","renderPassId","_resizeObserver","_generateMipMaps","_doNotChangeAspectRatio","_renderingManager","Rt","_useSceneAutoClearSetup","getRenderSize","_textureMatrix","_releaseRenderPassId","releaseRenderPassId","_createRenderPassId","getRenderLayers","createRenderPassId","ratio","_bestReflectionRenderTargetDimension","getRenderWidth","getRenderHeight","resetRefreshCounter","refreshRate","addPostProcess","_postProcessManager","Ht","autoClear","clearPostProcesses","removePostProcess","_shouldRender","disableRescaling","_render","isReadyForRendering","useCameraPostProcesses","getMeshById","renderListPredicate","currentRenderPassId","setTransformMatrix","getViewMatrix","viewport","_defaultRenderListPrepared","updateTransformMatrix","getActiveMeshes","getCustomRenderList","isBlocked","subMeshes","customIsReadyFunction","incrementRenderId","_renderToTarget","scenes","W","NearestPOT","FloorPOT","_prepareRenderingManager","_internalAbstractMeshDataInfo","_currentLODIsUpToDate","_currentLOD","customLODSelector","getLOD","_preActivateForIntermediateRendering","_activate","isAnInstance","_actAsRegularMesh","_onlyForInstancesIntermediate","_isActiveIntermediate","dispatch","particleSystems","emitter","isStarted","dispatchParticles","_bindFrameBuffer","_unbindFrameBuffer","_prepareFrame","postProcessManager","_debugPushGroup","snapshotRendering","snapshotRenderingMode","clearColor","_beforeRenderTargetClearStage","action","_beforeRenderTargetDrawStage","customRenderFunction","_afterRenderTargetDrawStage","_finalizeFrame","_afterRenderTargetPostProcessStage","generateMipMapsForCubemap","_debugPopGroup","setRenderingOrder","setRenderingAutoClearDepthStencil","disposeFramebufferObjects","customRenderTargets","cameras","REFRESHRATE_RENDER_ONCE","freeRenderingGroups","getViewCount","REFRESHRATE_RENDER_ONEVERYFRAME","REFRESHRATE_RENDER_ONEVERYTWOFRAMES","V","RegisterShaderCodeProcessing","_CustomShaderCodeProcessing","_GetShaderCodeProcessing","getEffectName","_fragmentUrl","onActivate","_onActivateObserver","onActivateObservable","onSizeChanged","_onSizeChangedObserver","onSizeChangedObservable","_onApplyObserver","inputTexture","_currentRenderTextureInd","_forcedOutputTexture","restoreDefaultInputTexture","markTextureDirty","getCamera","_camera","texelSize","_shareOutputWithPostProcess","_texelSize","hi","GLSL","nodeMaterialSource","_outputTexture","forceAutoClearInAlphaMode","alphaMode","enablePixelPerfectMode","forceFullscreenViewport","scaleMode","alwaysForcePOT","adaptScaleToCurrentViewport","_reusable","externalTextureSamplerBinding","It","_textureCache","_scaleRatio","attachPostProcess","renderTargetSamplingMode","_textureType","_textureFormat","_shaderLanguage","_samplers","_vertexUrl","_parameters","_indexParameters","updateEffect","getEffect","shareOutputWith","_disposeTextures","useOwnOutput","defineCustomBindings","_postProcessDefines","attributes","uniformsNames","uniformBuffersNames","samplers","fallbacks","indexParameters","processCodeAfterIncludes","processFinalCode","isReusable","_createRenderTargetTexture","postProcessChannel","lastUsedRenderId","_flushTextureCache","_resize","isStencilEnable","activate","maxTextureSize","leftCamera","rightCamera","currentViewport","needPOTTextures","GetExponentOfTwo","_debugInsertMarker","_allowPostProcessClearColor","isSupported","aspectRatio","setDepthBuffer","setDepthWrite","setAlphaMode","alphaConstants","setAlphaConstants","g","setVector2","bindCustomBindings","_disposeTextureCache","setPrePassRenderer","_prePassEffectConfiguration","addEffectConfiguration","detachPostProcess","_getFirstPostProcess","cameraId","reusable","fragmentUrl","parameters","options","vertexUrl","_Parse","getCameraById","li","IncludesShadersStore","Ce","kernel","_idealKernel","_kernel","_nearestBestKernel","_blockCompilation","_updateParameters","packedFloat","_packedFloat","varyingCount","depCount","_staticDefines","_gaussianWeight","floor","w","maxVaryingVectors","_glslFloat","exp","toFixed","di","Ot","_defines","_currentRank","_maxRank","_mesh","unBindMesh","addFallback","addCPUSkinningFallback","hasMoreFallbacks","reduce","computeBonesUsingShaders","numBoneInfluencers","_bonesComputationForcedToCPU","A","bias","_bias","normalBias","_normalBias","blurBoxOffset","_blurBoxOffset","_disposeBlurPostProcesses","blurScale","_blurScale","blurKernel","_blurKernel","useKernelBlur","_useKernelBlur","depthScale","_depthScale","_light","_validateFilter","filter","_filter","FILTER_BLUREXPONENTIALSHADOWMAP","useExponentialShadowMap","FILTER_BLURCLOSEEXPONENTIALSHADOWMAP","useCloseExponentialShadowMap","FILTER_PCF","FILTER_PCSS","usePoissonSampling","supportShadowSamplers","_applyFilterValues","FILTER_POISSONSAMPLING","FILTER_NONE","FILTER_EXPONENTIALSHADOWMAP","useBlurExponentialShadowMap","FILTER_CLOSEEXPONENTIALSHADOWMAP","useBlurCloseExponentialShadowMap","usePercentageCloserFiltering","filteringQuality","_filteringQuality","useContactHardeningShadow","contactHardeningLightSizeUVRatio","_contactHardeningLightSizeUVRatio","darkness","_darkness","setDarkness","getDarkness","transparencyShadow","_transparencyShadow","setTransparencyShadow","getShadowMap","_shadowMap","getShadowMapForRendering","_shadowMap2","CLASSNAME","addShadowCaster","getChildMeshes","removeShadowCaster","getChildren","getLight","_getCamera","mapSize","_mapSize","recreateShadowMap","onBeforeShadowMapRenderObservable","onAfterShadowMapRenderObservable","onBeforeShadowMapRenderMeshObservable","onAfterShadowMapRenderMeshObservable","QUALITY_HIGH","enableSoftTransparentShadow","useOpacityTextureForTransparentShadow","frustumEdgeFalloff","forceBackFacesOnly","_lightDirection","_projectionMatrix","_transformMatrix","_cachedPosition","_cachedDirection","_currentFaceIndex","_currentFaceIndexCache","_defaultTextureMatrix","Map","_useUBO","supportsUniformBuffers","_sceneUBOs","createSceneUniformBuffer","_SceneComponentInitialization","textureFloatRender","textureHalfFloatRender","_initializeGenerator","_initializeShadowMap","_createTargetRenderTexture","supportDepthStencilTexture","_storedUniqueId","_renderForShadowMap","bind","_currentSceneUBO","getSceneUniformBuffer","setSceneUniformBuffer","setColorWrite","getTransformMatrix","unbindEffect","finalizeSceneUbo","directRender","_blurPostProcesses","Xe","MIN_RENDERINGGROUPS","MAX_RENDERINGGROUPS","_initializeBlurRTTAndPostProcesses","_kernelBlurXPostprocess","_kernelBlurYPostprocess","_boxBlurPostprocess","_renderSubMeshForShadowMap","getEffectiveMesh","_bindCustomEffectForRenderSubMeshForShadowMap","setMatrix","getRenderingMesh","getMaterial","verticesCount","_getWorldMatrixDeterminant","overrideMaterialSideOrientation","sideOrientation","backFaceCulling","cullBackFaces","_getInstancesRenderList","_id","getReplacementMesh","mustReturn","instancedArrays","visibleInstances","hasThinInstances","customAllowRendering","shadowDepthWrapper","_getDrawWrapper","GetEffect","_bind","fillMode","setVector3","setFloat","visibility","standalone","baseMaterial","bindForSubMesh","_setMainDrawWrapperOverride","_opacityTexture","useBones","isUsingTextureForMatrices","getTransformMatrixTexture","bones","setMatrices","getTransformMatrices","L","BindMorphTargetParameters","morphTargetManager","isUsingTextureForTargets","dt","BindSceneUniformBuffer","getMeshUniformBuffer","_processRendering","forceCompilation","useInstances","checkReady","needAlphaBlendingForMesh","getMesh","forceCompilationAsync","_isReadyCustomDefines","_prepareShadowDefines","toUpperCase","isVerticesDataPresent","NormalKind","isReadyForSubMesh","nonUniformScaling","needAlphaTesting","needAlphaBlending","opacityTexture","getAlphaTestTexture","alphaCutOff","DEFAULT_ALPHA_CUTOFF","UVKind","UV2Kind","MatricesIndicesKind","MatricesWeightsKind","MatricesIndicesExtraKind","MatricesWeightsExtraKind","numInfluencers","PrepareAttributesForMorphTargetsInfluencers","Gt","PushAttributesForInstances","customShaderOptions","ft","shaderName","uniforms","maxSimultaneousMorphTargets","setEffect","prepareDefines","QUALITY_LOW","QUALITY_MEDIUM","setDepthStencilTexture","updateFloat2","NormalizeToRef","Dot","_disposeRTTandPostProcesses","_disposeSceneUBOs","entries","delete","className","lightId","getLightById","getMeshesById","useVarianceShadowMap","useBlurVarianceShadowMap","ut","_depthMap","forceDepthWriteTransparentMeshes","useOnlyInActiveCamera","reverseCulling","_storeNonLinearDepth","_storeCameraSpaceZ","isPacked","supportExtendedTextureFormats","infiniteDistance","disableDepthWrite","_materialForRenderPass","ORTHOGRAPHIC_CAMERA","getDepthMap","_depthRenderer","rs","onAfterReductionPerformed","_forceFullscreenViewport","_activated","sourceTexture","_sourceTexture","setSourceTexture","_reductionSteps","setInt2","func","activated","deactivate","ss","depthRenderer","setDepthRenderer","_depthRendererId","Xt","ns","G","Ne","it","$","console","error","numCascades","_numCascades","MIN_CASCADES_COUNT","MAX_CASCADES_COUNT","_recreateSceneUBOs","freezeShadowCastersBoundingInfo","_freezeShadowCastersBoundingInfo","_freezeShadowCastersBoundingInfoObservable","_computeShadowCastersBoundingInfo","_scbiMin","_scbiMax","minimizeInPlace","minimumWorld","maximizeInPlace","maximumWorld","receiveShadows","_shadowCastersBoundingInfo","reConstruct","shadowCastersBoundingInfo","setMinMaxDistance","_minDistance","_maxDistance","_breaksAreDirty","minDistance","maxDistance","getCascadeMinExtents","_cascadeMinExtents","getCascadeMaxExtents","_cascadeMaxExtents","debug","_debug","depthClamp","_depthClamp","cascadeBlendPercentage","_cascadeBlendPercentage","lambda","_lambda","getCascadeViewMatrix","_viewMatrices","getCascadeProjectionMatrix","_projectionMatrices","getCascadeTransformMatrix","_transformMatrices","_depthReducer","autoCalcDepthBounds","_autoCalcDepthBounds","autoCalcDepthBoundsRefreshRate","splitFrustum","_splitFrustum","_cascades","prevBreakDistance","breakDistance","_viewSpaceFrustumsZ","_frustumLengths","_computeMatrices","_computeFrustumInWorldSpace","_computeCascadeFrustum","_frustumCenter","_shadowCameraPos","copyToArray","_transformMatricesAsArray","Invert","getTransformationMatrix","_FrustumCornersNDCSpace","_frustumCornersWorldSpace","stabilizeCascades","ceil","IsSupported","LastCreatedEngine","supportCSM","penumbraDarkness","DEFAULT_CASCADES_COUNT","fi","_currentLayer","_lightSizeUVCorrection","_depthCorrection","setArray","setArray2","ci","AddParser","st","NAME_SHADOWGENERATOR","shadowGenerators","as","scene","register","_gatherRenderTargetsStage","registerStep","STEP_GATHERRENDERTARGETS_SHADOWGENERATOR","_gatherRenderTargets","addFromContainer","removeFromContainer","_getComponent","_addComponent","os","enableShadows","zt","shadowTransparency","shadowGenerator","directional","hemispheric","jt","wrap","topBaseAt","bottomBaseAt","unshift","pop","flat","concat","ke","DEFAULTSIDE","faceUV","faceColors","ui","_ComputeSides","frontUVs","backUVs","normals","uvs","DOUBLESIDE","colors","ye","_GetDefaultSideOrientation","_originalBuilderSideOrientation","applyToMesh","updatable","CreateBox","Wt","previousWorldMatrices","previousBones","AddUniforms","AddSamplers","prePassRenderer","currentRTisSceneRT","getIndex","previousViewProjection","currentViewProjection","_lastUpdateFrameId","frameId","Qt","nt","_normalMatrix","_storeEffectOnSubMeshes","_activeEffect","_isReadyForSubMesh","materialDefines","checkReadyOnEveryCall","bindOnlyWorldMatrix","bindOnlyNormalMatrix","_afterBind","_cachedEffect","_forceRebindOnNextCall","_mustRebind","isCachedMaterialInvalid","DiffuseTextureEnabled","_DiffuseTextureEnabled","MarkAllMaterialsAsDirty","DetailTextureEnabled","_DetailTextureEnabled","DecalMapEnabled","_DecalMapEnabled","AmbientTextureEnabled","_AmbientTextureEnabled","OpacityTextureEnabled","_OpacityTextureEnabled","ReflectionTextureEnabled","_ReflectionTextureEnabled","EmissiveTextureEnabled","_EmissiveTextureEnabled","SpecularTextureEnabled","_SpecularTextureEnabled","BumpTextureEnabled","_BumpTextureEnabled","LightmapTextureEnabled","_LightmapTextureEnabled","RefractionTextureEnabled","_RefractionTextureEnabled","ColorGradingTextureEnabled","_ColorGradingTextureEnabled","FresnelEnabled","_FresnelEnabled","ClearCoatTextureEnabled","_ClearCoatTextureEnabled","ClearCoatBumpTextureEnabled","_ClearCoatBumpTextureEnabled","ClearCoatTintTextureEnabled","_ClearCoatTintTextureEnabled","SheenTextureEnabled","_SheenTextureEnabled","AnisotropicTextureEnabled","_AnisotropicTextureEnabled","ThicknessTextureEnabled","_ThicknessTextureEnabled","RefractionIntensityTextureEnabled","_RefractionIntensityTextureEnabled","TranslucencyIntensityTextureEnabled","_TranslucencyIntensityTextureEnabled","IridescenceTextureEnabled","_IridescenceTextureEnabled","$n","RegExp","Me","_plugins","_activePlugins","_activePluginsForExtraEvents","_material","_addPlugin","_uniformBufferLayoutBuilt","_MaterialPluginClassToMainDefine","_MaterialPluginCounter","_callbackPluginEventGeneric","_handlePluginEvent","sort","_codeInjectionPoints","collectDefines","_collectPointNames","getCustomCode","_defineNamesFromPlugins","_activatePlugin","_callbackPluginEventIsReadyForSubMesh","_handlePluginEventIsReadyForSubMesh","_callbackPluginEventPrepareDefinesBeforeAttributes","_handlePluginEventPrepareDefinesBeforeAttributes","_callbackPluginEventPrepareDefines","_handlePluginEventPrepareDefines","_callbackPluginEventBindForSubMesh","_handlePluginEventBindForSubMesh","registerForExtraEvents","_callbackPluginEventHasRenderTargetTextures","_handlePluginEventHasRenderTargetTextures","_callbackPluginEventFillRenderTargetTextures","_handlePluginEventFillRenderTargetTextures","_callbackPluginEventHardBindForSubMesh","_handlePluginEventHardBindForSubMesh","getPlugin","subMesh","prepareDefinesBeforeAttributes","mesh","hardBindForSubMesh","hasRenderTargetTextures","fillRenderTargetTextures","renderTargets","Ee","GetActiveTextures","activeTextures","GetAnimatables","getAnimatables","animatables","HasTexture","Disposed","forceDisposeTextures","GetDefineNames","defineNames","PrepareEffect","fallbackRank","addFallbacks","getAttributes","_uniformList","_samplerList","_uboList","customCode","_injectCustomCode","PrepareUniformBuffer","_uboDeclaration","_vertexDeclaration","_fragmentDeclaration","getUniforms","ubo","arraySize","getSamplers","getUniformBuffersNames","charAt","substring","exec","pt","_enable","_pluginManager","pluginManager","_pluginDefineNames","markAllDefinesAsDirty","_dirtyCallbacks","copyTo","parse","Zn","DETAIL","DETAILDIRECTUV","DETAIL_NORMALBLENDMETHOD","Le","_isEnabled","_internalMarkAllSubMeshesAsTexturesDirty","diffuseBlendLevel","roughnessBlendLevel","bumpLevel","_normalBlendMethod","MATERIAL_NORMALBLENDMETHOD_WHITEOUT","texturesEnabled","standardDerivatives","PrepareDefinesForMergedUV","isFrozen","isSync","BindTextureMatrix","At","jn","MAINUV1","MAINUV2","MAINUV3","MAINUV4","MAINUV5","MAINUV6","DIFFUSE","DIFFUSEDIRECTUV","BAKED_VERTEX_ANIMATION_TEXTURE","AMBIENT","AMBIENTDIRECTUV","OPACITY","OPACITYDIRECTUV","OPACITYRGB","REFLECTION","EMISSIVE","EMISSIVEDIRECTUV","SPECULAR","SPECULARDIRECTUV","BUMP","BUMPDIRECTUV","PARALLAX","PARALLAXOCCLUSION","SPECULAROVERALPHA","CLIPPLANE","CLIPPLANE2","CLIPPLANE3","CLIPPLANE4","CLIPPLANE5","CLIPPLANE6","ALPHATEST","DEPTHPREPASS","ALPHAFROMDIFFUSE","POINTSIZE","FOG","SPECULARTERM","DIFFUSEFRESNEL","OPACITYFRESNEL","REFLECTIONFRESNEL","REFRACTIONFRESNEL","EMISSIVEFRESNEL","FRESNEL","NORMAL","TANGENT","UV1","UV2","UV3","UV4","UV5","UV6","VERTEXCOLOR","VERTEXALPHA","NUM_BONE_INFLUENCERS","BonesPerMesh","BONETEXTURE","BONES_VELOCITY_ENABLED","INSTANCES","THIN_INSTANCES","INSTANCESCOLOR","GLOSSINESS","ROUGHNESS","EMISSIVEASILLUMINATION","LINKEMISSIVEWITHDIFFUSE","REFLECTIONFRESNELFROMSPECULAR","LIGHTMAP","LIGHTMAPDIRECTUV","OBJECTSPACE_NORMALMAP","USELIGHTMAPASSHADOWMAP","REFLECTIONMAP_3D","REFLECTIONMAP_SPHERICAL","REFLECTIONMAP_PLANAR","REFLECTIONMAP_CUBIC","USE_LOCAL_REFLECTIONMAP_CUBIC","USE_LOCAL_REFRACTIONMAP_CUBIC","REFLECTIONMAP_PROJECTION","REFLECTIONMAP_SKYBOX","REFLECTIONMAP_EXPLICIT","REFLECTIONMAP_EQUIRECTANGULAR","REFLECTIONMAP_EQUIRECTANGULAR_FIXED","REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED","REFLECTIONMAP_OPPOSITEZ","INVERTCUBICMAP","LOGARITHMICDEPTH","REFRACTION","REFRACTIONMAP_3D","REFLECTIONOVERALPHA","TWOSIDEDLIGHTING","SHADOWFLOAT","MORPHTARGETS","MORPHTARGETS_NORMAL","MORPHTARGETS_TANGENT","MORPHTARGETS_UV","NUM_MORPH_INFLUENCERS","MORPHTARGETS_TEXTURE","NONUNIFORMSCALING","PREMULTIPLYALPHA","ALPHATEST_AFTERALLALPHACOMPUTATIONS","ALPHABLEND","PREPASS","PREPASS_IRRADIANCE","PREPASS_IRRADIANCE_INDEX","PREPASS_ALBEDO_SQRT","PREPASS_ALBEDO_SQRT_INDEX","PREPASS_DEPTH","PREPASS_DEPTH_INDEX","PREPASS_NORMAL","PREPASS_NORMAL_INDEX","PREPASS_POSITION","PREPASS_POSITION_INDEX","PREPASS_VELOCITY","PREPASS_VELOCITY_INDEX","PREPASS_REFLECTIVITY","PREPASS_REFLECTIVITY_INDEX","SCENE_MRT_COUNT","RGBDLIGHTMAP","RGBDREFLECTION","RGBDREFRACTION","IMAGEPROCESSING","VIGNETTE","VIGNETTEBLENDMODEMULTIPLY","VIGNETTEBLENDMODEOPAQUE","TONEMAPPING","TONEMAPPING_ACES","CONTRAST","COLORCURVES","COLORGRADING","COLORGRADING3D","SAMPLER3DGREENDEPTH","SAMPLER3DBGRMAP","DITHER","IMAGEPROCESSINGPOSTPROCESS","SKIPFINALCOLORCLAMP","MULTIVIEW","ORDER_INDEPENDENT_TRANSPARENCY","ORDER_INDEPENDENT_TRANSPARENCY_16BITS","CAMERA_ORTHOGRAPHIC","CAMERA_PERSPECTIVE","IS_REFLECTION_LINEAR","IS_REFRACTION_LINEAR","EXPOSURE","setReflectionMode","imageProcessingConfiguration","_imageProcessingConfiguration","_attachImageProcessingConfiguration","_imageProcessingObserver","onUpdateParameters","_markAllSubMeshesAsImageProcessingDirty","isPrePassCapable","cameraColorCurvesEnabled","colorCurvesEnabled","cameraColorGradingEnabled","colorGradingEnabled","cameraToneMappingEnabled","toneMappingEnabled","cameraExposure","exposure","cameraContrast","contrast","cameraColorGradingTexture","colorGradingTexture","cameraColorCurves","colorCurves","canRenderToMRT","_diffuseTexture","_ambientTexture","_reflectionTexture","_emissiveTexture","_specularTexture","_bumpTexture","_lightmapTexture","_refractionTexture","ambientColor","diffuseColor","specularColor","emissiveColor","specularPower","_useAlphaFromDiffuseTexture","_useEmissiveAsIllumination","_linkEmissiveWithDiffuse","_useSpecularOverAlpha","_useReflectionOverAlpha","_disableLighting","_useObjectSpaceNormalMap","_useParallax","_useParallaxOcclusion","parallaxScaleBias","_roughness","indexOfRefraction","invertRefractionY","_useLightmapAsShadowmap","_useReflectionFresnelFromSpecular","_useGlossinessFromSpecularMapAlpha","_maxSimultaneousLights","_invertNormalMapX","_invertNormalMapY","_twoSidedLighting","_renderTargets","_worldViewProjectionMatrix","_globalAmbientColor","_cacheHasRenderTargetTextures","detailMap","prePassConfiguration","getRenderTargetTextures","_eventInfo","useLogarithmicDepth","_useLogarithmicDepth","fragmentDepthSupported","_markAllSubMeshesAsMiscDirty","_disableAlphaBlending","_shouldUseAlphaFromDiffuseTexture","_opacityFresnelParameters","_forceAlphaTest","_hasAlphaChannel","_transparencyMode","MATERIAL_ALPHATEST","MATERIAL_OPAQUE","buildUniformLayout","_wasPreviouslyUsingInstances","PrepareDefinesForLights","PrepareDefinesForMultiview","useOrderIndependentTransparency","PrepareDefinesForPrePass","PrepareDefinesForOIT","_backFaceCulling","transparencyMode","reflectionTexture","refractionTexture","_diffuseFresnelParameters","_emissiveFresnelParameters","_refractionFresnelParameters","_reflectionFresnelParameters","PrepareDefinesForMisc","pointsCloud","fogEnabled","_shouldTurnAlphaTestOn","PrepareDefinesForFrameBoundValues","PrepareDefinesForAttributes","lt","pointerMovePredicate","pointerDownPredicate","pointerUpPredicate","clearCachedVertexData","themeData","fov"],"sourceRoot":""}